<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Chromium Css解析深入分析</title>
    <link href="/2022/05/04/Chromium-Css%E8%A7%A3%E6%9E%90%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90/"/>
    <url>/2022/05/04/Chromium-Css%E8%A7%A3%E6%9E%90%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h2 id="Css代码"><a href="#Css代码" class="headerlink" title="Css代码"></a>Css代码</h2><figure class="highlight css"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-selector-tag">p</span> &#123;<br> <span class="hljs-attribute">color</span>: <span class="hljs-number">#00000f</span>;<br>&#125;<br><br><span class="hljs-selector-class">.my</span> &#123;<br> <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="词法分析"><a href="#词法分析" class="headerlink" title="词法分析"></a>词法分析</h2><p>上面的Css代码词法解析到一个个的CSSParserToken token，如下图就是解析后的。<br><img src="/2022/05/04/Chromium-Css%E8%A7%A3%E6%9E%90%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90/1.jpg"><br>CSSParserToken是如何被解析的，其实本质上是在词法解析的时候，识别到对应的关键字则调用对应的函数生生成对应的token。</p><p>如下代码（路径out&#x2F;android-Debug&#x2F;gen&#x2F;third_party&#x2F;blink&#x2F;renderer&#x2F;core&#x2F;css&#x2F;css_tokenizer_codepoints.cc注意这个是编译后生成代码）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">const</span> CSSTokenizer::CodePoint CSSTokenizer::kCodePoints[<span class="hljs-number">128</span>] = &#123;<br>    &amp;CSSTokenizer::EndOfFile,<br>    <span class="hljs-number">0</span>,<br>    <span class="hljs-number">0</span>,<br>    <span class="hljs-number">0</span>,<br>    <span class="hljs-number">0</span>,<br>    <span class="hljs-number">0</span>,<br>    <span class="hljs-number">0</span>,<br>    <span class="hljs-number">0</span>,<br>    <span class="hljs-number">0</span>,<br>    &amp;CSSTokenizer::WhiteSpace,<br>    &amp;CSSTokenizer::WhiteSpace,<br>    <span class="hljs-number">0</span>,<br>    &amp;CSSTokenizer::WhiteSpace,<br>    &amp;CSSTokenizer::WhiteSpace,<br>    <span class="hljs-number">0</span>,<br>    <span class="hljs-number">0</span>,<br>    <span class="hljs-number">0</span>,<br>    <span class="hljs-number">0</span>,<br>    <span class="hljs-number">0</span>,<br>    <span class="hljs-number">0</span>,<br>    <span class="hljs-number">0</span>,<br>    <span class="hljs-number">0</span>,<br>    <span class="hljs-number">0</span>,<br>    <span class="hljs-number">0</span>,<br>    <span class="hljs-number">0</span>,<br>    <span class="hljs-number">0</span>,<br>    <span class="hljs-number">0</span>,<br>    <span class="hljs-number">0</span>,<br>    <span class="hljs-number">0</span>,<br>    <span class="hljs-number">0</span>,<br>    <span class="hljs-number">0</span>,<br>    <span class="hljs-number">0</span>,<br>    &amp;CSSTokenizer::WhiteSpace,<br>    <span class="hljs-number">0</span>,<br>    &amp;CSSTokenizer::StringStart,<br>    &amp;CSSTokenizer::Hash,<br>    &amp;CSSTokenizer::DollarSign,<br>    <span class="hljs-number">0</span>,<br>    <span class="hljs-number">0</span>,<br>    &amp;CSSTokenizer::StringStart,<br>    &amp;CSSTokenizer::LeftParenthesis,<br>    &amp;CSSTokenizer::RightParenthesis,<br>    &amp;CSSTokenizer::Asterisk,<br>    &amp;CSSTokenizer::PlusOrFullStop,<br>    &amp;CSSTokenizer::Comma,<br>    &amp;CSSTokenizer::HyphenMinus,<br>    &amp;CSSTokenizer::PlusOrFullStop,<br>    &amp;CSSTokenizer::Solidus,<br>    &amp;CSSTokenizer::AsciiDigit,<br>    &amp;CSSTokenizer::AsciiDigit,<br>    &amp;CSSTokenizer::AsciiDigit,<br>    &amp;CSSTokenizer::AsciiDigit,<br>    &amp;CSSTokenizer::AsciiDigit,<br>    &amp;CSSTokenizer::AsciiDigit,<br>    &amp;CSSTokenizer::AsciiDigit,<br>    &amp;CSSTokenizer::AsciiDigit,<br>    &amp;CSSTokenizer::AsciiDigit,<br>    &amp;CSSTokenizer::AsciiDigit,<br>    &amp;CSSTokenizer::Colon,<br>    &amp;CSSTokenizer::SemiColon,<br>    &amp;CSSTokenizer::LessThan,<br>    <span class="hljs-number">0</span>,<br>    <span class="hljs-number">0</span>,<br>    <span class="hljs-number">0</span>,<br>    &amp;CSSTokenizer::CommercialAt,<br>    &amp;CSSTokenizer::NameStart,<br>    &amp;CSSTokenizer::NameStart,<br>    &amp;CSSTokenizer::NameStart,<br>    &amp;CSSTokenizer::NameStart,<br>    &amp;CSSTokenizer::NameStart,<br>    &amp;CSSTokenizer::NameStart,<br>    &amp;CSSTokenizer::NameStart,<br>    &amp;CSSTokenizer::NameStart,<br>    &amp;CSSTokenizer::NameStart,<br>    &amp;CSSTokenizer::NameStart,<br>    &amp;CSSTokenizer::NameStart,<br>    &amp;CSSTokenizer::NameStart,<br>    &amp;CSSTokenizer::NameStart,<br>    &amp;CSSTokenizer::NameStart,<br>    &amp;CSSTokenizer::NameStart,<br>    &amp;CSSTokenizer::NameStart,<br>    &amp;CSSTokenizer::NameStart,<br>    &amp;CSSTokenizer::NameStart,<br>    &amp;CSSTokenizer::NameStart,<br>    &amp;CSSTokenizer::NameStart,<br>    &amp;CSSTokenizer::LetterU,<br>    &amp;CSSTokenizer::NameStart,<br>    &amp;CSSTokenizer::NameStart,<br>    &amp;CSSTokenizer::NameStart,<br>    &amp;CSSTokenizer::NameStart,<br>    &amp;CSSTokenizer::NameStart,<br>    &amp;CSSTokenizer::LeftBracket,<br>    &amp;CSSTokenizer::ReverseSolidus,<br>    &amp;CSSTokenizer::RightBracket,<br>    &amp;CSSTokenizer::CircumflexAccent,<br>    &amp;CSSTokenizer::NameStart,<br>    <span class="hljs-number">0</span>,<br>    &amp;CSSTokenizer::NameStart,<br>    &amp;CSSTokenizer::NameStart,<br>    &amp;CSSTokenizer::NameStart,<br>    &amp;CSSTokenizer::NameStart,<br>    &amp;CSSTokenizer::NameStart,<br>    &amp;CSSTokenizer::NameStart,<br>    &amp;CSSTokenizer::NameStart,<br>    &amp;CSSTokenizer::NameStart,<br>    &amp;CSSTokenizer::NameStart,<br>    &amp;CSSTokenizer::NameStart,<br>    &amp;CSSTokenizer::NameStart,<br>    &amp;CSSTokenizer::NameStart,<br>    &amp;CSSTokenizer::NameStart,<br>    &amp;CSSTokenizer::NameStart,<br>    &amp;CSSTokenizer::NameStart,<br>    &amp;CSSTokenizer::NameStart,<br>    &amp;CSSTokenizer::NameStart,<br>    &amp;CSSTokenizer::NameStart,<br>    &amp;CSSTokenizer::NameStart,<br>    &amp;CSSTokenizer::NameStart,<br>    &amp;CSSTokenizer::LetterU,<br>    &amp;CSSTokenizer::NameStart,<br>    &amp;CSSTokenizer::NameStart,<br>    &amp;CSSTokenizer::NameStart,<br>    &amp;CSSTokenizer::NameStart,<br>    &amp;CSSTokenizer::NameStart,<br>    &amp;CSSTokenizer::LeftBrace,<br>    &amp;CSSTokenizer::VerticalLine,<br>    &amp;CSSTokenizer::RightBrace,<br>    &amp;CSSTokenizer::Tilde,<br>    <span class="hljs-number">0</span>,<br>&#125;;<br><br></code></pre></td></tr></table></figure><p>kCodePoints是一个数组，里面存储的是128个字符生成的对应的token生成函数指针地址。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">CSSParserToken <span class="hljs-title">CSSTokenizer::NextToken</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-comment">// Unlike the HTMLTokenizer, the CSS Syntax spec is written</span><br>  <span class="hljs-comment">// as a stateless, (fixed-size) look-ahead tokenizer.</span><br>  <span class="hljs-comment">// We could move to the stateful model and instead create</span><br>  <span class="hljs-comment">// states for all the &quot;next 3 codepoints are X&quot; cases.</span><br>  <span class="hljs-comment">// State-machine tokenizers are easier to write to handle</span><br>  <span class="hljs-comment">// incremental tokenization of partial sources.</span><br>  <span class="hljs-comment">// However, for now we follow the spec exactly.</span><br>  UChar cc = <span class="hljs-built_in">Consume</span>();<br>  CodePoint code_point_func = <span class="hljs-literal">nullptr</span>;<br><br>  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">IsASCII</span>(cc)) &#123; <span class="hljs-comment">// 是否是ASCII字符</span><br>    <span class="hljs-built_in">SECURITY_DCHECK</span>(cc &lt; codePointsNumber);<br>    code_point_func = kCodePoints[cc]; <span class="hljs-comment">// 是则获取对应的函数</span><br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    code_point_func = &amp;CSSTokenizer::NameStart;<br>  &#125;<br><br>  ++token_count_;<br>  <span class="hljs-keyword">if</span> (code_point_func)<br>    <span class="hljs-keyword">return</span> ((<span class="hljs-keyword">this</span>)-&gt;*(code_point_func))(cc); <span class="hljs-comment">// 调用对应的字符函数生成对应token</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">CSSParserToken</span>(kDelimiterToken, cc);<br>&#125;<br></code></pre></td></tr></table></figure><p>如上代码，当识别到对应的字符则调用对应的函数生成token</p><h2 id="StyleSheetContents"><a href="#StyleSheetContents" class="headerlink" title="StyleSheetContents"></a>StyleSheetContents</h2><p><img src="/2022/05/04/Chromium-Css%E8%A7%A3%E6%9E%90%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90/2.jpg"><br>如上图</p><p>StyleSheetContents：是存储的样式表，一个style标签对应一个StyleSheetContents</p><p>StyleRule：每一个Css Block对应一个StyleRule。例如.my{width: 200px;} 就会对应一个StyleRule，</p><p>里面还存储Css里面的属性和值</p><p>CSSSelectorList：表示Css Block选择器列表，因为Css 选择器可能是一个列表</p><p>CSSSelector：表示Css选择器，有Class，Tag，Id等类型<br><img src="/2022/05/04/Chromium-Css%E8%A7%A3%E6%9E%90%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90/3.jpg"><br>如上图，StyleSheetContents还会整理样式表，样式表中的Css匹配是按照选择器的优先级来的，所以StyleSheetContents会把Id，Class，Tag的Css规则分别收集起来，方便匹配。</p><p>RuleSet：整理后的规则集合类</p><p>CompactRuleMap：rules的集合，在StyleSheetContents中有三个变量，分别为了 id_rules_，class_rules_，tag_rules_</p><p>RuleDate：里面存储的就是StyleRule</p><h2 id="多个Style标签"><a href="#多个Style标签" class="headerlink" title="多个Style标签"></a>多个Style标签</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs CSS">&lt;style&gt;<br><span class="hljs-selector-id">#id1</span> &#123;<br> <span class="hljs-attribute">color</span>: <span class="hljs-number">#00000f</span>;<br>&#125;<br>&lt;/style&gt;<br><br>&lt;style&gt;<br><span class="hljs-selector-id">#id2</span> &#123;<br> <span class="hljs-attribute">color</span>: <span class="hljs-number">#00000f</span>;<br>&#125;<br>&lt;/style&gt;<br></code></pre></td></tr></table></figure><p>如上Css代码，里面有两个style标签，那它的结构如下：<br><img src="/2022/05/04/Chromium-Css%E8%A7%A3%E6%9E%90%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90/4.jpg"><br>如上图Document下会对应一个StyleEngine样式引擎，下会有个DocumentStyleSheetCollection用于样式表收集存储一系列的StyleSheet，StyleSheet 对应一个StyleSheetContents。</p><p>文章有出入的请及时指出。</p><p>同步知乎：<a href="https://zhuanlan.zhihu.com/p/508761172">https://zhuanlan.zhihu.com/p/508761172</a></p>]]></content>
    
    
    <categories>
      
      <category>Chromium</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Css</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Chromium Mojo Binding 深入分析</title>
    <link href="/2022/05/04/Chromium-Mojo-Binding-%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90/"/>
    <url>/2022/05/04/Chromium-Mojo-Binding-%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<p>用于IDL语言生成包装，通过IDL可以生成接口通信，上层可以通过接口包装直接进行进程间通信，使用方式和函数调用无区别，极大的简化代码的可读性。</p><p>本篇文章主要讲解内部关系，需要一定的mojo基础。</p><h2 id="Mojo-IDL"><a href="#Mojo-IDL" class="headerlink" title="Mojo IDL"></a>Mojo IDL</h2><p>用于简化接口生成的语言，可以学习下。官方说明文档Mojom Interface Definition Language (IDL)</p><h2 id="Mojo-Binding"><a href="#Mojo-Binding" class="headerlink" title="Mojo Binding"></a>Mojo Binding</h2><p>代码路径mojo&#x2F;public&#x2F;cpp&#x2F;bindings</p><p>官方讲解：Mojo C++ Bindings API</p><p>主要的涉及的接口Remote，PendingRemote，Receiver，PendingReceiver，这些类的作用我就不过多讲解了，大家可以看官方文档。</p><h3 id="普通mojo接口创建"><a href="#普通mojo接口创建" class="headerlink" title="普通mojo接口创建"></a>普通mojo接口创建</h3><p>在接口通信过程中有两种情况，一种是Remote主创建，一种是Receiver主创建。<br><img src="/2022/05/04/Chromium-Mojo-Binding-%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90/1.jpg"><br>如上图：</p><p>模式一remote端负责创建MessagePipe，会存在两个ScopedMessagePipeHandle handle（hanlde0，handle1），Receiver端会有一个handle1负责接受处理消息。每个handle都会对应一个MessagePipeDispatcher。handle0创建MultiplexRouter，接下来会创建MultiplexRouter::InterfaceEndpoint和EndPointClient。MultiplexRouter会对应多个InterfaceEndpoint用于多路复用，创建后会返回一个ScopedInterfaceEndpointHandle。</p><p>模式二刚好相反。这里不多讲解</p><p>MessagePipe如何创建呢？<br><img src="/2022/05/04/Chromium-Mojo-Binding-%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90/2.jpg"><br>MessagePipe的创建是通过Remote::BindNewPipeAndPassReceiver或则Receiver::BindNewPipeAndPassRemote创建的。不同的模式下调用不同的接口。如下图MessagePipe的与handle和MessagePipeDispatcher的关系<br><img src="/2022/05/04/Chromium-Mojo-Binding-%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90/3.jpg"><br>我们知道MessagePipe是非常宝贵的，不可能一个mojo接口MessagePipe，为了节省资源，则有了关联接口，接下来讲解关联接口</p><h3 id="关联接口"><a href="#关联接口" class="headerlink" title="关联接口"></a>关联接口</h3><p>关联接口会关联在一个主的mojo接口中，大家共用MessagePipe，主要用ScopedInterfaceEndpointHandle区分关联接口的处理对象。</p><p>主要涉及的相关类AssociatedReceiver，AssociatedRemote<br><img src="/2022/05/04/Chromium-Mojo-Binding-%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90/4.jpg"><br>如上图是两种模式的关联接口hanlde关系。每个关联接口都会对应有个receiver_handle和remote_handle，handle会创建InterfaceEndpointClient，这样就可以绑定了进程两端，进程通信的时候就可以找到正确的处理消息类。<br><img src="/2022/05/04/Chromium-Mojo-Binding-%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90/5.jpg"><br>如上图ScopedInterfaceEndpointHandle的创建是通过AssociatedReceiver::BindNewEndpointAndPassRemote或者AssociatedRemote::BindNewEndpointAndPassReceiver创建的。</p><p>接下来有个疑问，Associated关联接口如何关联到主接口的呢？<br><img src="/2022/05/04/Chromium-Mojo-Binding-%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90/6.jpg"><br>创建关联接口是由主接口调用的，然后会系列化AssociatedEndpointHandle，通过主接口的mojo通道进行通信，发送给另一端，接受端会反系列化AssociatedEndpointHandle从而创建出endpoint。这样就实现了关联接口的两个进程之间的关联。</p><h3 id="关联接口和主接口之间关系"><a href="#关联接口和主接口之间关系" class="headerlink" title="关联接口和主接口之间关系"></a>关联接口和主接口之间关系</h3><p>例如主接口A，A接口下面有 B，C，D接口，那他们之间是什么关系，如何识别？<br><img src="/2022/05/04/Chromium-Mojo-Binding-%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90/7.jpg"><br>Interface A会通过MojoMessageHandle Handle0去创建个MultiplexRouter，所以主接口的MultiplexRouter管理着关联接口的地方。每个关联接口会对应个InterfaceId，InterfaceId就是去消息去区分属于哪个关联接口的。InterfaceId，MultiplexRouter::InterfaceEndpoint，InterfaceEndPointClient是一一对应的关系。这样每个接口都有自己的处理端口。<br><img src="/2022/05/04/Chromium-Mojo-Binding-%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90/8.jpg"></p><h3 id="接口调用"><a href="#接口调用" class="headerlink" title="接口调用"></a>接口调用</h3><p><img src="/2022/05/04/Chromium-Mojo-Binding-%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90/9.jpg"><br>上图就是Remote端接口调用时候Binding层流程</p><h3 id="接口处理"><a href="#接口处理" class="headerlink" title="接口处理"></a>接口处理</h3><p><img src="/2022/05/04/Chromium-Mojo-Binding-%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90/10.png"><br>上图就是Receiver端接口调用时候Binding层流程</p><p>上面具体的代码就不贴出来了，大家自行去对应即可。如果有出入，请多多指教</p><p>同步知乎：<a href="https://zhuanlan.zhihu.com/p/508534942">https://zhuanlan.zhihu.com/p/508534942</a></p>]]></content>
    
    
    <categories>
      
      <category>Chromium</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Mojo</tag>
      
      <tag>Binding</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Chromium IPC 深入分析（基于Mojo）</title>
    <link href="/2022/05/04/Chromium-IPC-%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90%EF%BC%88%E5%9F%BA%E4%BA%8EMojo%EF%BC%89/"/>
    <url>/2022/05/04/Chromium-IPC-%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90%EF%BC%88%E5%9F%BA%E4%BA%8EMojo%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>本文主要讲解是最新版的chromium ipc，需要有mojo的基础知识。</p><p>最新版的chromium ipc的底层通信是通过mojo接口通信的，ipc.mojom是ipc的mojo接口通道。</p><h2 id="Browser与Render之间通信"><a href="#Browser与Render之间通信" class="headerlink" title="Browser与Render之间通信"></a>Browser与Render之间通信</h2><p><img src="/2022/05/04/Chromium-IPC-%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90%EF%BC%88%E5%9F%BA%E4%BA%8EMojo%EF%BC%89/1.jpg"><br>如上图Render进程的RenderFrameImpl发送消息给Browser进程RenderFrameHostImpl，中间是通过ipc.mojo接口。</p><p>ipc.mojo的idl代码</p><figure class="highlight c++"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></div></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">module</span> IPC.mojom;<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;mojo/public/interfaces/bindings/native_struct.mojom&quot;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;mojo/public/mojom/base/generic_pending_associated_receiver.mojom&quot;</span>;<br><br><span class="hljs-comment">// Typemapped such that arbitrarily large IPC::Message objects can be sent and</span><br><span class="hljs-comment">// received with minimal copying.</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Message</span> &#123;<br>  array&lt;uint8&gt; bytes;<br>  array&lt;mojo.native.SerializedHandle&gt;? handles;<br>&#125;;<br><br>interface Channel &#123;<br>  <span class="hljs-comment">// Informs the remote end of this client&#x27;s PID. Must be called exactly once,</span><br>  <span class="hljs-comment">// before any calls to Receive() below.</span><br>  <span class="hljs-built_in">SetPeerPid</span>(int32 pid);<br><br>  <span class="hljs-comment">// Transmits a classical Chrome IPC message.</span><br>  [UnlimitedSize]<br>  <span class="hljs-built_in">Receive</span>(Message message);<br><br>  <span class="hljs-comment">// Requests a Channel-associated interface.</span><br>  <span class="hljs-built_in">GetAssociatedInterface</span>(<br>      mojo_base.mojom.GenericPendingAssociatedReceiver receiver);<br>&#125;;<br><br><span class="hljs-comment">// A strictly nominal interface used to identify Channel bootstrap requests.</span><br><span class="hljs-comment">// This is only used in `AgentSchedulingGroup` initialization.</span><br>interface ChannelBootstrap &#123;&#125;;<br></code></pre></td></tr></table></figure><p>如上可以看出mojo接口是Channel，Channel中有Receive就是消息处理和发送函数，GetAssociatedInterface是用于创建mojo接口关联函数。接下来围绕Channel讲解.</p><h2 id="IPC核心讲解"><a href="#IPC核心讲解" class="headerlink" title="IPC核心讲解"></a>IPC核心讲解</h2><p>主要代码路径在src&#x2F;ipc<br><img src="/2022/05/04/Chromium-IPC-%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90%EF%BC%88%E5%9F%BA%E4%BA%8EMojo%EF%BC%89/2.jpg"><br>如上图主要类的关系：</p><p>注意Listener和Sender两个接口类，主要是发送消息和接受消息的虚接口，最终的实现调用还是MessagePipeReader类。</p><p>MessagePipeReader类是mojo::Channel的实现，MessagePipeReader这个类就是ipc消息处理和发送类。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">class</span> <span class="hljs-title">COMPONENT_EXPORT</span><span class="hljs-params">(IPC)</span> MessagePipeReader : public mojom::Channel &#123;</span><br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-keyword">class</span> <span class="hljs-title class_">Delegate</span> &#123;<br>   <span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">OnPeerPidReceived</span><span class="hljs-params">(<span class="hljs-type">int32_t</span> peer_pid)</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">OnMessageReceived</span><span class="hljs-params">(<span class="hljs-type">const</span> Message&amp; message)</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">OnBrokenDataReceived</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">OnPipeError</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">OnAssociatedInterfaceRequest</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">        mojo::GenericPendingAssociatedReceiver receiver)</span> </span>= <span class="hljs-number">0</span>;<br>  &#125;;<br><br>.......<br><br>  <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Send</span><span class="hljs-params">(std::unique_ptr&lt;Message&gt; message)</span></span>;<br>.......<br><br> <span class="hljs-keyword">protected</span>:<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">OnPipeClosed</span><span class="hljs-params">()</span></span>;<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">OnPipeError</span><span class="hljs-params">(MojoResult error)</span></span>;<br><br> <span class="hljs-keyword">private</span>:<br>  <span class="hljs-comment">// mojom::Channel:</span><br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SetPeerPid</span><span class="hljs-params">(<span class="hljs-type">int32_t</span> peer_pid)</span> <span class="hljs-keyword">override</span></span>;<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Receive</span><span class="hljs-params">(MessageView message_view)</span> <span class="hljs-keyword">override</span></span>;<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">GetAssociatedInterface</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">      mojo::GenericPendingAssociatedReceiver receiver)</span> <span class="hljs-keyword">override</span></span>;<br><br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ForwardMessage</span><span class="hljs-params">(mojo::Message message)</span></span>;<br><br>  <span class="hljs-comment">// |delegate_| is null once the message pipe is closed.</span><br>  raw_ptr&lt;Delegate&gt; delegate_; <span class="hljs-comment">// 用于调用消息处理</span><br>  mojo::AssociatedRemote&lt;mojom::Channel&gt; sender_; <span class="hljs-comment">// AssociatedRemote用于消息发送</span><br>  std::unique_ptr&lt;mojo::ThreadSafeForwarder&lt;mojom::Channel&gt;&gt;<br>      thread_safe_sender_;<br>  mojo::AssociatedReceiver&lt;mojom::Channel&gt; receiver_;<br>  base::ThreadChecker thread_checker_;<br>  base::WeakPtrFactory&lt;MessagePipeReader&gt; weak_ptr_factory_&#123;<span class="hljs-keyword">this</span>&#125;;<br>&#125;;<br></code></pre></td></tr></table></figure><p>如上代码，MessagePipeReader 继承mojom::Channel，MessagePipeReader中有mojo::AssociatedRemote<a href="mojom::Channel">mojom::Channel</a> sender_成员用于消息发送。</p><h2 id="IPC消息发送"><a href="#IPC消息发送" class="headerlink" title="IPC消息发送"></a>IPC消息发送</h2><p>下面是以Render进程中RenderFrameImpl的消息发送流程图<br><img src="/2022/05/04/Chromium-IPC-%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90%EF%BC%88%E5%9F%BA%E4%BA%8EMojo%EF%BC%89/3.jpg"><br>如上图，我们以RenderFrameImpl为例，最终调用的是MessagePipeReader::Send函数，通过sender_-&gt;Receive函数mojo通道发送到另一个进程</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">MessagePipeReader::Send</span><span class="hljs-params">(std::unique_ptr&lt;Message&gt; message)</span> </span>&#123;<br>  <span class="hljs-built_in">CHECK</span>(message-&gt;<span class="hljs-built_in">IsValid</span>());<br>  <span class="hljs-built_in">TRACE_EVENT_WITH_FLOW0</span>(<span class="hljs-string">&quot;toplevel.flow&quot;</span>, <span class="hljs-string">&quot;MessagePipeReader::Send&quot;</span>,<br>                         message-&gt;<span class="hljs-built_in">flags</span>(), TRACE_EVENT_FLAG_FLOW_OUT);<br>  absl::optional&lt;std::vector&lt;mojo::native::SerializedHandlePtr&gt;&gt; handles;<br>  MojoResult result = MOJO_RESULT_OK;<br>  result = ChannelMojo::<span class="hljs-built_in">ReadFromMessageAttachmentSet</span>(message.<span class="hljs-built_in">get</span>(), &amp;handles);<br>  <span class="hljs-keyword">if</span> (result != MOJO_RESULT_OK)<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>  <span class="hljs-keyword">if</span> (!sender_)<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>  <span class="hljs-function">base::span&lt;<span class="hljs-type">const</span> <span class="hljs-type">uint8_t</span>&gt; <span class="hljs-title">bytes</span><span class="hljs-params">(<span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-type">const</span> <span class="hljs-type">uint8_t</span>*&gt;(message-&gt;data()),</span></span><br><span class="hljs-params"><span class="hljs-function">                                  message-&gt;size())</span></span>;<br>  sender_-&gt;<span class="hljs-built_in">Receive</span>(<span class="hljs-built_in">MessageView</span>(bytes, std::<span class="hljs-built_in">move</span>(handles)));<br>  <span class="hljs-built_in">DVLOG</span>(<span class="hljs-number">4</span>) &lt;&lt; <span class="hljs-string">&quot;Send &quot;</span> &lt;&lt; message-&gt;<span class="hljs-built_in">type</span>() &lt;&lt; <span class="hljs-string">&quot;: &quot;</span> &lt;&lt; message-&gt;<span class="hljs-built_in">size</span>();<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="IPC消息处理"><a href="#IPC消息处理" class="headerlink" title="IPC消息处理"></a>IPC消息处理</h2><p>下面是以Render进程中RenderFrameImpl的消息处理流程图<br><img src="/2022/05/04/Chromium-IPC-%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90%EF%BC%88%E5%9F%BA%E4%BA%8EMojo%EF%BC%89/4.jpg"><br>1.mojo通过调用MessagePipeReader::Receive然后分发给对应的类处理</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">MessagePipeReader::Receive</span><span class="hljs-params">(MessageView message_view)</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (message_view.<span class="hljs-built_in">bytes</span>().<span class="hljs-built_in">empty</span>()) &#123;<br>    delegate_-&gt;<span class="hljs-built_in">OnBrokenDataReceived</span>();<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br>  <span class="hljs-function">Message <span class="hljs-title">message</span><span class="hljs-params">(<span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-type">const</span> <span class="hljs-type">char</span>*&gt;(message_view.bytes().data()),</span></span><br><span class="hljs-params"><span class="hljs-function">                  message_view.bytes().size())</span></span>;<br>  <span class="hljs-keyword">if</span> (!message.<span class="hljs-built_in">IsValid</span>()) &#123;<br>    delegate_-&gt;<span class="hljs-built_in">OnBrokenDataReceived</span>();<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br><br>  <span class="hljs-built_in">DVLOG</span>(<span class="hljs-number">4</span>) &lt;&lt; <span class="hljs-string">&quot;Receive &quot;</span> &lt;&lt; message.<span class="hljs-built_in">type</span>() &lt;&lt; <span class="hljs-string">&quot;: &quot;</span> &lt;&lt; message.<span class="hljs-built_in">size</span>();<br>  MojoResult write_result = ChannelMojo::<span class="hljs-built_in">WriteToMessageAttachmentSet</span>(<br>      message_view.<span class="hljs-built_in">TakeHandles</span>(), &amp;message);<br>  <span class="hljs-keyword">if</span> (write_result != MOJO_RESULT_OK) &#123;<br>    <span class="hljs-built_in">OnPipeError</span>(write_result);<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br><br>  <span class="hljs-built_in">TRACE_EVENT_WITH_FLOW0</span>(<span class="hljs-string">&quot;toplevel.flow&quot;</span>, <span class="hljs-string">&quot;MessagePipeReader::Receive&quot;</span>,<br>                         message.<span class="hljs-built_in">flags</span>(), TRACE_EVENT_FLAG_FLOW_IN);<br>  delegate_-&gt;<span class="hljs-built_in">OnMessageReceived</span>(message); <span class="hljs-comment">// 通过代理分发处理</span><br>&#125;<br></code></pre></td></tr></table></figure><p>2.在消息处理函数中，delegate_指的是ChannelMojo，代码路径ipc&#x2F;ipc_channel_mojo.h</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">class</span> <span class="hljs-title">COMPONENT_EXPORT</span><span class="hljs-params">(IPC)</span> ChannelMojo</span><br><span class="hljs-function">    : public Channel,</span><br><span class="hljs-function">      public Channel::AssociatedInterfaceSupport,</span><br><span class="hljs-function">      public internal::MessagePipeReader::Delegate &#123;</span><br> <span class="hljs-keyword">public</span>:<br>......<br>  <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Send</span><span class="hljs-params">(Message* message)</span> <span class="hljs-keyword">override</span></span>;<br>......<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">OnMessageReceived</span><span class="hljs-params">(<span class="hljs-type">const</span> Message&amp; message)</span> <span class="hljs-keyword">override</span></span>;<br>......<br><br> <span class="hljs-keyword">private</span>:<br>......<br><br>  <span class="hljs-type">const</span> mojo::MessagePipeHandle pipe_;<br>  std::unique_ptr&lt;MojoBootstrap&gt; bootstrap_;<br>  raw_ptr&lt;Listener&gt; listener_;<br><br>  std::unique_ptr&lt;internal::MessagePipeReader&gt; message_reader_;<br>......<br>&#125;;<br><br></code></pre></td></tr></table></figure><p>ChannelMojo的基类有MessagePipeReader::Delegate，ChannelMojo::OnMessageReceived来转发消息处理</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ChannelMojo::OnMessageReceived</span><span class="hljs-params">(<span class="hljs-type">const</span> Message&amp; message)</span> </span>&#123;<br>  <span class="hljs-type">const</span> Message* message_ptr = &amp;message;<br>  <span class="hljs-built_in">TRACE_IPC_MESSAGE_SEND</span>(<span class="hljs-string">&quot;ipc,toplevel&quot;</span>, <span class="hljs-string">&quot;ChannelMojo::OnMessageReceived&quot;</span>,<br>                         message_ptr);<br>  listener_-&gt;<span class="hljs-built_in">OnMessageReceived</span>(message);<br>  <span class="hljs-keyword">if</span> (message.<span class="hljs-built_in">dispatch_error</span>())<br>    listener_-&gt;<span class="hljs-built_in">OnBadMessageReceived</span>(message);<br>&#125;<br></code></pre></td></tr></table></figure><p>如上代码，是通过listener_来转发消息。</p><p>listener_本质上就是ChannelProxy::Context，在创建Channel的时候会把ChannelProxy::Context传入给ChannelMojo中。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">void</span> ChannelProxy::Context::<span class="hljs-built_in">CreateChannel</span>(<br>    std::unique_ptr&lt;ChannelFactory&gt; factory) &#123;<br>  <span class="hljs-function">base::AutoLock <span class="hljs-title">channel_lock</span><span class="hljs-params">(channel_lifetime_lock_)</span></span>;<br>  <span class="hljs-built_in">DCHECK</span>(!channel_);<br>  <span class="hljs-built_in">DCHECK_EQ</span>(factory-&gt;<span class="hljs-built_in">GetIPCTaskRunner</span>(), ipc_task_runner_);<br>  channel_ = factory-&gt;<span class="hljs-built_in">BuildChannel</span>(<span class="hljs-keyword">this</span>); <span class="hljs-comment">// 创建Channel</span><br><br>  Channel::AssociatedInterfaceSupport* support =<br>      channel_-&gt;<span class="hljs-built_in">GetAssociatedInterfaceSupport</span>();<br>  <span class="hljs-keyword">if</span> (support) &#123;<br>    thread_safe_channel_ = support-&gt;<span class="hljs-built_in">CreateThreadSafeChannel</span>();<br><br>    <span class="hljs-function">base::AutoLock <span class="hljs-title">filter_lock</span><span class="hljs-params">(pending_filters_lock_)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; entry : pending_io_thread_interfaces_)<br>      support-&gt;<span class="hljs-built_in">AddGenericAssociatedInterface</span>(entry.first, entry.second);<br>    pending_io_thread_interfaces_.<span class="hljs-built_in">clear</span>();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>3.接下来ChannelProxy::Context::OnMessageReceived处理消息</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">bool</span> ChannelProxy::Context::<span class="hljs-built_in">OnMessageReceived</span>(<span class="hljs-type">const</span> Message&amp; message) &#123;<br>  <span class="hljs-comment">// First give a chance to the filters to process this message.</span><br>  <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">TryFilters</span>(message))<br>    <span class="hljs-built_in">OnMessageReceivedNoFilter</span>(message);<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>如上代码本质上是调用ChannelProxy::Context::OnMessageReceivedNoFilter，这里我们发现有个PostTask。</p><p>为什么需要post任务的方式去处理消息？因为我们知道每个IPC消息不一定在同一个线程，所以在处理message的时候会根据消息的routing_id去查找对应的TaskRunner，这样就可以保证IPC消息在正确的线程上处理。如下代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">bool</span> ChannelProxy::Context::<span class="hljs-built_in">OnMessageReceivedNoFilter</span>(<span class="hljs-type">const</span> Message&amp; message) &#123;<br>  <span class="hljs-built_in">GetTaskRunner</span>(message.<span class="hljs-built_in">routing_id</span>())<br>      -&gt;<span class="hljs-built_in">PostTask</span>(FROM_HERE,<br>                 base::<span class="hljs-built_in">BindOnce</span>(&amp;Context::OnDispatchMessage, <span class="hljs-keyword">this</span>, message));<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后调用到ChannelProxy::Context::OnDispatchMessage处理消息，这里真正会调用listener_-&gt;OnMessageReceived的函数去处理消息。listener_是Listener，在这个流程中是AgentSchedulingGroup。如下代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// Called on the listener&#x27;s thread</span><br><span class="hljs-type">void</span> ChannelProxy::Context::<span class="hljs-built_in">OnDispatchMessage</span>(<span class="hljs-type">const</span> Message&amp; message) &#123;<br>  <span class="hljs-keyword">if</span> (!listener_)<br>    <span class="hljs-keyword">return</span>;<br><br>  <span class="hljs-built_in">OnDispatchConnected</span>();<br><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> BUILDFLAG(IPC_MESSAGE_LOG_ENABLED)</span><br>  Logging* logger = Logging::<span class="hljs-built_in">GetInstance</span>();<br>  <span class="hljs-keyword">if</span> (message.<span class="hljs-built_in">type</span>() == IPC_LOGGING_ID) &#123;<br>    logger-&gt;<span class="hljs-built_in">OnReceivedLoggingMessage</span>(message);<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br><br>  <span class="hljs-keyword">if</span> (logger-&gt;<span class="hljs-built_in">Enabled</span>())<br>    logger-&gt;<span class="hljs-built_in">OnPreDispatchMessage</span>(message);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>  listener_-&gt;<span class="hljs-built_in">OnMessageReceived</span>(message); <span class="hljs-comment">// 真正调用listener处理</span><br>  <span class="hljs-keyword">if</span> (message.<span class="hljs-built_in">dispatch_error</span>())<br>    listener_-&gt;<span class="hljs-built_in">OnBadMessageReceived</span>(message);<br><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> BUILDFLAG(IPC_MESSAGE_LOG_ENABLED)</span><br>  <span class="hljs-keyword">if</span> (logger-&gt;<span class="hljs-built_in">Enabled</span>())<br>    logger-&gt;<span class="hljs-built_in">OnPostDispatchMessage</span>(message);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>&#125;<br></code></pre></td></tr></table></figure><p>4.调用AgentSchedulingGroup去处理消息，每个消息会有一个routing_id，message这个routing_id会找到对应的listener。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">AgentSchedulingGroup::OnMessageReceived</span><span class="hljs-params">(<span class="hljs-type">const</span> IPC::Message&amp; message)</span> </span>&#123;<br>  <span class="hljs-built_in">DCHECK_NE</span>(message.<span class="hljs-built_in">routing_id</span>(), MSG_ROUTING_CONTROL);<br><br>  <span class="hljs-keyword">auto</span>* listener = <span class="hljs-built_in">GetListener</span>(message.<span class="hljs-built_in">routing_id</span>());<br>  <span class="hljs-keyword">if</span> (!listener)<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>  <span class="hljs-keyword">return</span> listener-&gt;<span class="hljs-built_in">OnMessageReceived</span>(message);<br>&#125;<br></code></pre></td></tr></table></figure><p>5.上面根据routing_id找到RenderFrameImpl，RenderFrameImpl的基类会有IPC::Listener，所以调用RenderFrameImpl::OnMessageReceived进行处理对应的IPC</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">RenderFrameImpl::OnMessageReceived</span><span class="hljs-params">(<span class="hljs-type">const</span> IPC::Message&amp; msg)</span> </span>&#123;<br>  <span class="hljs-comment">// We may get here while detaching, when the WebFrame has been deleted.  Do</span><br>  <span class="hljs-comment">// not process any messages in this state.</span><br>  <span class="hljs-keyword">if</span> (!frame_)<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>  <span class="hljs-built_in">DCHECK</span>(!frame_-&gt;<span class="hljs-built_in">GetDocument</span>().<span class="hljs-built_in">IsNull</span>());<br><br>  <span class="hljs-built_in">GetContentClient</span>()-&gt;<span class="hljs-built_in">SetActiveURL</span>(<br>      frame_-&gt;<span class="hljs-built_in">GetDocument</span>().<span class="hljs-built_in">Url</span>(),<br>      frame_-&gt;<span class="hljs-built_in">Top</span>()-&gt;<span class="hljs-built_in">GetSecurityOrigin</span>().<span class="hljs-built_in">ToString</span>().<span class="hljs-built_in">Utf8</span>());<br><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; observer : observers_) &#123;<br>    <span class="hljs-keyword">if</span> (observer.<span class="hljs-built_in">OnMessageReceived</span>(msg))<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="管理IPC-Listener"><a href="#管理IPC-Listener" class="headerlink" title="管理IPC::Listener"></a>管理IPC::Listener</h2><p>管理IPC::Listener的类有很多，RenderThreadImpl，AgentSchedulingGroup，AgentSchedulingGroupHost，ChildThreadImpl等等。</p><p>这里主要讲解Render进程管理的AgentSchedulingGroup管理IPC::Listener，主要存储在listener_map_变量中<br><img src="/2022/05/04/Chromium-IPC-%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90%EF%BC%88%E5%9F%BA%E4%BA%8EMojo%EF%BC%89/5.jpg"><br>routing_id和listener通过AgentSchedulingGroup::AddRoute进行添加的</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">AgentSchedulingGroup::AddRoute</span><span class="hljs-params">(<span class="hljs-type">int32_t</span> routing_id, Listener* listener)</span> </span>&#123;<br>  <span class="hljs-built_in">DCHECK</span>(!listener_map_.<span class="hljs-built_in">Lookup</span>(routing_id));<br>  listener_map_.<span class="hljs-built_in">AddWithID</span>(listener, routing_id); <span class="hljs-comment">// 存储routing_id和listener</span><br>  render_thread_.<span class="hljs-built_in">AddRoute</span>(routing_id, listener);<br><br>  <span class="hljs-comment">// See warning in `GetAssociatedInterface`.</span><br>  <span class="hljs-comment">// Replay any `GetAssociatedInterface` calls for this route.</span><br>  <span class="hljs-keyword">auto</span> range = pending_receivers_.<span class="hljs-built_in">equal_range</span>(routing_id);<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> iter = range.first; iter != range.second; ++iter) &#123;<br>    ReceiverData&amp; data = iter-&gt;second;<br>    listener-&gt;<span class="hljs-built_in">OnAssociatedInterfaceRequest</span>(data.name,<br>                                           data.receiver.<span class="hljs-built_in">PassHandle</span>());<br>  &#125;<br>  pending_receivers_.<span class="hljs-built_in">erase</span>(range.first, range.second);<br>&#125;<br></code></pre></td></tr></table></figure><p>文章到此结束，如果有出入请多多指教！</p><p>同步知乎：<a href="https://zhuanlan.zhihu.com/p/508362483">https://zhuanlan.zhihu.com/p/508362483</a></p>]]></content>
    
    
    <categories>
      
      <category>Chromium</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Mojo</tag>
      
      <tag>IPC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Chromium Mojo Core深入分析</title>
    <link href="/2022/05/04/Chromium-Mojo-Core%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90/"/>
    <url>/2022/05/04/Chromium-Mojo-Core%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<p>本文是mojo源码的分析，需要对mojo有一定的基础知识</p><h2 id="Mojo是什么？"><a href="#Mojo是什么？" class="headerlink" title="Mojo是什么？"></a>Mojo是什么？</h2><p>Mojom是chromium最新的跨平台进程通信框架</p><h2 id="Mojo架构"><a href="#Mojo架构" class="headerlink" title="Mojo架构"></a>Mojo架构</h2><p><img src="/2022/05/04/Chromium-Mojo-Core%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90/1.jpg"><br>由官方架构图可知，mojom是分层设计：</p><p>Mojo Core：内核层，主要是底层数据通信连接和消息编解码，C++代码实现</p><p>Mojo System API：Mojo接口层，1. 暴露给上层使用，例如MessagePipe，Message；2. 对接平台特殊接口</p><p>Mojo System（C++&#x2F;Js&#x2F;Java）：Mojo 的语言包装层，Mojo C API 包装成多种语言。所以Mojo可以是个多语言使用的库</p><p>Bindings：用于IDL语言生成包装，通过IDL可以生成接口通信，上层可以通过接口包装直接进行进程间通信，使用方式和函数调用无区别，极大的增加了代码的可读性</p><h2 id="Mojo-Core底层结构"><a href="#Mojo-Core底层结构" class="headerlink" title="Mojo Core底层结构"></a>Mojo Core底层结构</h2><p><img src="/2022/05/04/Chromium-Mojo-Core%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90/2.jpg"><br>1.Core 为mojo的核心类，接口暴露给外部用，一个进程只对应一个Core，这个类管理成员NodeController和Handletable<br>2.MessagePipe是消息管道，保存了两个MessagePipeHandle，用于找到对应的MessagePipeDispatcher，每个mojo接口对应一个MessagePipe<br>3.MessagePipeDispatcher是每个mojo接口的消息处理类，MessagePipeDispatcher对应一个MessagePipeHandle<br>4.Handletable是用于存储MojoHanlde和MessagePipeDispatcher，MojoHanlde和MessagePipeDispatcher是一一对应关系，MojoHanlde是uint64_t数字<br>5.MessagePipeHandle实质上就是MojoHanlde<br>6.Node是相当于ip节点概念<br>7.Port相当于端口概念，每个mojo接口都有自己的Port，这样就可以方便进程间通信，可以寻找到应的接口处理<br>8.NodeController用于管理Node<br>9.Channel是进程建通信通道管理，每个平台有对应的实现，Linux对应的实现是ChannelPosix，主要是用于创建Unix Socket，用于进程间通信的消息读写等<br>10.SimpleWatcher用于监听Port消息<br>11.Connector用于读取和处理Port的消息队列事件</p><h2 id="Core类"><a href="#Core类" class="headerlink" title="Core类"></a>Core类</h2><p><img src="/2022/05/04/Chromium-Mojo-Core%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90/3.jpg"><br>文件路径：mojo&#x2F;core&#x2F;core.h mojo&#x2F;core&#x2F;core.cc</p><p>Core主要成员函数对外暴露的接口，主要的接口有创建消息管道，写消息，读消息等等</p><figure class="highlight c++"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></div></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MOJO_SYSTEM_IMPL_EXPORT</span> Core &#123;<br>......<br><br>  <span class="hljs-comment">// These methods correspond to the API functions defined in</span><br>  <span class="hljs-comment">// &quot;mojo/public/c/system/message_pipe.h&quot;:</span><br>  <span class="hljs-function">MojoResult <span class="hljs-title">CreateMessagePipe</span><span class="hljs-params">(<span class="hljs-type">const</span> MojoCreateMessagePipeOptions* options,</span></span><br><span class="hljs-params"><span class="hljs-function">                               MojoHandle* message_pipe_handle0,</span></span><br><span class="hljs-params"><span class="hljs-function">                               MojoHandle* message_pipe_handle1)</span></span>;<br>  <span class="hljs-function">MojoResult <span class="hljs-title">WriteMessage</span><span class="hljs-params">(MojoHandle message_pipe_handle,</span></span><br><span class="hljs-params"><span class="hljs-function">                          MojoMessageHandle message_handle,</span></span><br><span class="hljs-params"><span class="hljs-function">                          <span class="hljs-type">const</span> MojoWriteMessageOptions* options)</span></span>;<br>  <span class="hljs-function">MojoResult <span class="hljs-title">ReadMessage</span><span class="hljs-params">(MojoHandle message_pipe_handle,</span></span><br><span class="hljs-params"><span class="hljs-function">                         <span class="hljs-type">const</span> MojoReadMessageOptions* options,</span></span><br><span class="hljs-params"><span class="hljs-function">                         MojoMessageHandle* message_handle)</span></span>;<br>  <span class="hljs-function">MojoResult <span class="hljs-title">FuseMessagePipes</span><span class="hljs-params">(MojoHandle handle0,</span></span><br><span class="hljs-params"><span class="hljs-function">                              MojoHandle handle1,</span></span><br><span class="hljs-params"><span class="hljs-function">                              <span class="hljs-type">const</span> MojoFuseMessagePipesOptions* options)</span></span>;<br>  <span class="hljs-function">MojoResult <span class="hljs-title">NotifyBadMessage</span><span class="hljs-params">(MojoMessageHandle message_handle,</span></span><br><span class="hljs-params"><span class="hljs-function">                              <span class="hljs-type">const</span> <span class="hljs-type">char</span>* error,</span></span><br><span class="hljs-params"><span class="hljs-function">                              <span class="hljs-type">size_t</span> error_num_bytes,</span></span><br><span class="hljs-params"><span class="hljs-function">                              <span class="hljs-type">const</span> MojoNotifyBadMessageOptions* options)</span></span>;<br>......<br><br> <span class="hljs-keyword">private</span>:<br>......<br><br>  <span class="hljs-comment">// This is lazily initialized on first access. Always use GetNodeController()</span><br>  <span class="hljs-comment">// to access it.</span><br>  std::unique_ptr&lt;NodeController&gt; node_controller_;<br><br>  <span class="hljs-comment">// The default callback to invoke, if any, when a process error is reported</span><br>  <span class="hljs-comment">// but cannot be associated with a specific process.</span><br>  ProcessErrorCallback default_process_error_callback_;<br><br>  std::unique_ptr&lt;HandleTable&gt; handles_;<br>......<br>&#125;;<br><br></code></pre></td></tr></table></figure><p>如上代码可知，Core成员是NodeController和Handletable，所以一个进程中只有一份NodeController和Handletable</p><h2 id="MessagePipe类"><a href="#MessagePipe类" class="headerlink" title="MessagePipe类"></a>MessagePipe类</h2><p><img src="/2022/05/04/Chromium-Mojo-Core%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90/4.jpg"><br>路径：mojo&#x2F;public&#x2F;cpp&#x2F;system&#x2F;message_pipe.h mojo&#x2F;public&#x2F;cpp&#x2F;system&#x2F;message_pipe.cc</p><p>MessagsePipe类主要是存储了两个ScopedMessagePipeHandle handle，ScopedMessagePipeHandle是本质是MessagePipeHandle的包装，MessagePipeHandle是一个MojoHandle，MojoHandle就是一个uint64_t的id，这个主要就是用于查找MessagePipeDispatcher的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MessagePipe</span> &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-built_in">MessagePipe</span>();<br>  <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">MessagePipe</span><span class="hljs-params">(<span class="hljs-type">const</span> MojoCreateMessagePipeOptions&amp; options)</span></span>;<br>  ~<span class="hljs-built_in">MessagePipe</span>();<br><br>  ScopedMessagePipeHandle handle0;<br>  ScopedMessagePipeHandle handle1;<br>&#125;;<br></code></pre></td></tr></table></figure><p>如上是MessagePipe的源代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">typedef</span> ScopedHandleBase&lt;MessagePipeHandle&gt; ScopedMessagePipeHandle;<br></code></pre></td></tr></table></figure><p>如上是ScopedMessagePipeHandle的源码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MessagePipeHandle</span> : <span class="hljs-keyword">public</span> Handle &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-built_in">MessagePipeHandle</span>() &#123;&#125;<br>  <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">MessagePipeHandle</span><span class="hljs-params">(MojoHandle value)</span> : Handle(value) &#123;</span>&#125;<br><br>  <span class="hljs-comment">// Copying and assignment allowed.</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>如上是MessagePipeHandle的代码，可以看出它的基类是Handle</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// Wrapper base class for |MojoHandle|.</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Handle</span> &#123;<br>......<br> <span class="hljs-keyword">private</span>:<br>  MojoHandle value_;<br><br>  <span class="hljs-comment">// Copying and assignment allowed.</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>如上可以知道Handle就是MojoHandle包装</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">typedef</span> <span class="hljs-type">uint64_t</span> MojoHandle;<br></code></pre></td></tr></table></figure><p>MojoHandle就是一个uint64_t数字</p><p>整体关系如下图：<br><img src="/2022/05/04/Chromium-Mojo-Core%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90/5.png"></p><h2 id="Handletable类"><a href="#Handletable类" class="headerlink" title="Handletable类"></a>Handletable类</h2><p><img src="/2022/05/04/Chromium-Mojo-Core%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90/6.jpg"><br>路径：mojo&#x2F;core&#x2F;handle_table.h mojo&#x2F;core&#x2F;handle_table.cc</p><p>Handletable主要是用于管理存储MojoHanlde和MessagePipeDispatcher（基类是Dispatcher），他们之间的对应关系是通过unordered_map存储的，key是MojoHanlde，value是MessagePipeDispatcher，每添加一个MessagePipeDispatcher就会绑定一个handle。MojoHanlde是通过next_available_handle_++得到的，这样可可以保证每个hanlde都是唯一的。</p><p>可以查看HandleTable源码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MOJO_SYSTEM_IMPL_EXPORT</span> HandleTable<br>    : <span class="hljs-keyword">public</span> base::trace_event::MemoryDumpProvider &#123;<br>......<br>  <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Entry</span> &#123;<br>    <span class="hljs-built_in">Entry</span>();<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">Entry</span><span class="hljs-params">(scoped_refptr&lt;Dispatcher&gt; dispatcher)</span></span>;<br>    <span class="hljs-built_in">Entry</span>(<span class="hljs-type">const</span> Entry&amp; other);<br>    ~<span class="hljs-built_in">Entry</span>();<br><br>    scoped_refptr&lt;Dispatcher&gt; dispatcher;<br>    <span class="hljs-type">bool</span> busy = <span class="hljs-literal">false</span>;<br>  &#125;;<br><br>  <span class="hljs-keyword">using</span> HandleMap = std::unordered_map&lt;MojoHandle, Entry&gt;;<br><br>  HandleMap handles_;<br>  base::Lock lock_;<br><br>  <span class="hljs-type">uint64_t</span> next_available_handle_ = <span class="hljs-number">1</span>;<br>&#125;;<br></code></pre></td></tr></table></figure><p>可以看到handles_就是一个 std::unordered_map&lt;MojoHandle, Entry&gt;，而Entry上是Dispatcher的包装。</p><p>接下来我们看下MojoHandle的由来</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">MojoHandle <span class="hljs-title">HandleTable::AddDispatcher</span><span class="hljs-params">(scoped_refptr&lt;Dispatcher&gt; dispatcher)</span> </span>&#123;<br>  <span class="hljs-comment">// Oops, we&#x27;re out of handles.</span><br>  <span class="hljs-keyword">if</span> (next_available_handle_ == MOJO_HANDLE_INVALID)<br>    <span class="hljs-keyword">return</span> MOJO_HANDLE_INVALID;<br><br>  MojoHandle handle = next_available_handle_++; <span class="hljs-comment">// j计算handle</span><br>  <span class="hljs-keyword">auto</span> result =<br>      handles_.<span class="hljs-built_in">insert</span>(std::<span class="hljs-built_in">make_pair</span>(handle, <span class="hljs-built_in">Entry</span>(std::<span class="hljs-built_in">move</span>(dispatcher)))); <span class="hljs-comment">// handle和dispatcher绑定到一起</span><br>  <span class="hljs-built_in">DCHECK</span>(result.second);<br><br>  <span class="hljs-keyword">return</span> handle;<br>&#125;<br></code></pre></td></tr></table></figure><p>由上代码可以知道当AddDispatcher一个Dispatcher时候next_available_handle_++这样就得到了一个唯一的handle与dispatcher对应，然后插入到handles_中</p><h2 id="MessagePipeDispatcher类"><a href="#MessagePipeDispatcher类" class="headerlink" title="MessagePipeDispatcher类"></a>MessagePipeDispatcher类</h2><p><img src="/2022/05/04/Chromium-Mojo-Core%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90/7.jpg"><br>路径：mojo&#x2F;core&#x2F;message_pipe_dispatcher.h mojo&#x2F;core&#x2F;message_pipe_dispatcher.cc</p><p>MessagePipeDispatcher类是一个消息处理中间类，它的基类是Dispatcher。</p><p>当Proxy端调用则通过调用MessagePipeDispatcher::WriteMessage函数通过NodeContorl发送消息给另一个进程</p><p>当在Impl端则通过MessagePipeDispatcher::ReadMessage向Port读取消息队列读取消息，然后传给对应的mojo接口实现处理。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MessagePipeDispatcher</span> : <span class="hljs-keyword">public</span> Dispatcher &#123;<br> <span class="hljs-keyword">public</span>:<br>.......<br>  <span class="hljs-comment">// Dispatcher:</span><br>  <span class="hljs-function">Type <span class="hljs-title">GetType</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span></span>;<br>  <span class="hljs-function">MojoResult <span class="hljs-title">Close</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span></span>;<br>  <span class="hljs-function">MojoResult <span class="hljs-title">WriteMessage</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">      std::unique_ptr&lt;ports::UserMessageEvent&gt; message)</span> <span class="hljs-keyword">override</span></span>;<br>  <span class="hljs-function">MojoResult <span class="hljs-title">ReadMessage</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">      std::unique_ptr&lt;ports::UserMessageEvent&gt;* message)</span> <span class="hljs-keyword">override</span></span>;<br>.......<br><br> <span class="hljs-keyword">private</span>:<br>.......<br>  NodeController* <span class="hljs-type">const</span> node_controller_;<br>  <span class="hljs-type">const</span> ports::PortRef port_;<br>  <span class="hljs-type">const</span> <span class="hljs-type">uint64_t</span> pipe_id_; <span class="hljs-comment">// 一个随机值</span><br>  <span class="hljs-type">const</span> <span class="hljs-type">int</span> endpoint_; <span class="hljs-comment">// 0或者1</span><br>.......<br>&#125;;<br></code></pre></td></tr></table></figure><p>可以看MessagePipeDispatcher中存储了NodeController和PortRef。PortRef是存储消息对应的Port和PortName，主要用于读取对应的Port的消息队列。如下源码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">class</span> <span class="hljs-title">COMPONENT_EXPORT</span><span class="hljs-params">(MOJO_CORE_PORTS)</span> PortRef </span>&#123;<br> <span class="hljs-keyword">public</span>:<br>  ~<span class="hljs-built_in">PortRef</span>();<br>  <span class="hljs-built_in">PortRef</span>();<br>  <span class="hljs-built_in">PortRef</span>(<span class="hljs-type">const</span> PortName&amp; name, scoped_refptr&lt;Port&gt; port);<br><br>  <span class="hljs-built_in">PortRef</span>(<span class="hljs-type">const</span> PortRef&amp; other);<br>  <span class="hljs-built_in">PortRef</span>(PortRef&amp;&amp; other);<br><br>  PortRef&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> PortRef&amp; other);<br>  PortRef&amp; <span class="hljs-keyword">operator</span>=(PortRef&amp;&amp; other);<br><br>  <span class="hljs-function"><span class="hljs-type">const</span> PortName&amp; <span class="hljs-title">name</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> name_; &#125;<br><br>  <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">is_valid</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> !!port_; &#125;<br><br> <span class="hljs-keyword">private</span>:<br>  <span class="hljs-keyword">friend</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PortLocker</span>;<br><br>  <span class="hljs-function">Port* <span class="hljs-title">port</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> port_.<span class="hljs-built_in">get</span>(); &#125;<br><br>  PortName name_; <span class="hljs-comment">// port的name</span><br>  scoped_refptr&lt;Port&gt; port_;<span class="hljs-comment">// port的指针</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>1.Proxy端消息发送主要的调用函数MessagePipeDispatcher::WriteMessage</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">MojoResult <span class="hljs-title">MessagePipeDispatcher::WriteMessage</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">    std::unique_ptr&lt;ports::UserMessageEvent&gt; message)</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (port_closed_ || in_transit_)<br>    <span class="hljs-keyword">return</span> MOJO_RESULT_INVALID_ARGUMENT;<br><br>  <span class="hljs-type">int</span> rv = node_controller_-&gt;<span class="hljs-built_in">SendUserMessage</span>(port_, std::<span class="hljs-built_in">move</span>(message));<br>......<br>  <span class="hljs-keyword">return</span> MOJO_RESULT_OK;<br>&#125;<br></code></pre></td></tr></table></figure><p>如上代码主要是通过node_controller_-&gt;SendUserMessage把message发送给另一个进程，然后可以看到会把port带上，这样就可以发送给另一个进程对应的mojo impl处理。</p><p>2.Impl端读取消息主要的调用函数MessagePipeDispatcher::ReadMessage</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">MojoResult <span class="hljs-title">MessagePipeDispatcher::ReadMessage</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">    std::unique_ptr&lt;ports::UserMessageEvent&gt;* message)</span> </span>&#123;<br>  <span class="hljs-comment">// We can&#x27;t read from a port that&#x27;s closed or in transit!</span><br>  <span class="hljs-keyword">if</span> (port_closed_ || in_transit_)<br>    <span class="hljs-keyword">return</span> MOJO_RESULT_INVALID_ARGUMENT;<br><br>  <span class="hljs-type">int</span> rv = node_controller_-&gt;<span class="hljs-built_in">node</span>()-&gt;<span class="hljs-built_in">GetMessage</span>(port_, message, <span class="hljs-literal">nullptr</span>);<br>......<br>  <span class="hljs-keyword">return</span> MOJO_RESULT_OK;<br>&#125;<br></code></pre></td></tr></table></figure><p>如上代码，则可以知道消息读取的时候是通过node_controller_-&gt;node()-&gt;GetMessage上读取的，本质上就是读取port里面的消息队列</p><h2 id="Node类"><a href="#Node类" class="headerlink" title="Node类"></a>Node类</h2><p>路径：mojo&#x2F;core&#x2F;ports&#x2F;node.h mojo&#x2F;core&#x2F;ports&#x2F;node.cc</p><p>相当于ip的概念，管理着port端口，在每个进程中只有一个node，但是可以多个port端口，因为在进程中肯定不止一个mojo接口，那怎么去区分接口呢？那就是通过port概念区分。<br><img src="/2022/05/04/Chromium-Mojo-Core%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90/8.jpg"><br>Node管理着PortName和Port，PortName和Port存储的数据结构是unordered_map。如下代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">class</span> <span class="hljs-title">COMPONENT_EXPORT</span><span class="hljs-params">(MOJO_CORE_PORTS)</span> Node </span>&#123;<br>......<br>  <span class="hljs-type">const</span> NodeName name_;<br>  <span class="hljs-type">const</span> DelegateHolder delegate_;<br><br>  <span class="hljs-comment">// Just to clarify readability of the types below.</span><br>  <span class="hljs-keyword">using</span> LocalPortName = PortName;<br>  <span class="hljs-keyword">using</span> PeerPortName = PortName;<br><br>  <span class="hljs-comment">// Guards access to |ports_| and |peer_port_maps_| below.</span><br>  <span class="hljs-comment">//</span><br>  <span class="hljs-comment">// This must never be acquired while an individual port&#x27;s lock is held on the</span><br>  <span class="hljs-comment">// same thread. Conversely, individual port locks may be acquired while this</span><br>  <span class="hljs-comment">// one is held.</span><br>  <span class="hljs-comment">//</span><br>  <span class="hljs-comment">// Because UserMessage events may execute arbitrary user code during</span><br>  <span class="hljs-comment">// destruction, it is also important to ensure that such events are never</span><br>  <span class="hljs-comment">// destroyed while this (or any individual Port) lock is held.</span><br>  base::Lock ports_lock_;<br>  std::unordered_map&lt;LocalPortName, scoped_refptr&lt;Port&gt;&gt; ports_;<br>......<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="Port类"><a href="#Port类" class="headerlink" title="Port类"></a>Port类</h2><p>路径：mojo&#x2F;core&#x2F;ports&#x2F;port.h mojo&#x2F;core&#x2F;ports&#x2F;port.cc<br><img src="/2022/05/04/Chromium-Mojo-Core%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90/9.jpg"><br>port主要是存储消息队列的，当进程1的接口向进程2发送一个消息，则进程2的会从底层Socket读取到消息存在port的MessageQueue队列中，然后等待node读取进行处理。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Port</span> : <span class="hljs-keyword">public</span> base::RefCountedThreadSafe&lt;Port&gt; &#123;<br>......<br>  <span class="hljs-comment">// The queue of incoming user messages received by this Port. Only non-empty</span><br>  <span class="hljs-comment">// for buffering or receiving Ports. When a buffering port enters the proxying</span><br>  <span class="hljs-comment">// state, it flushes its queue and the proxy then bypasses the queue</span><br>  <span class="hljs-comment">// indefinitely.</span><br>  <span class="hljs-comment">//</span><br>  <span class="hljs-comment">// A receiving port&#x27;s queue only has elements removed by user code reading</span><br>  <span class="hljs-comment">// messages from the port.</span><br>  <span class="hljs-comment">//</span><br>  <span class="hljs-comment">// Note that this is a priority queue which only exposes messages to consumers</span><br>  <span class="hljs-comment">// in strict sequential order.</span><br>  MessageQueue message_queue;<br>......<br>&#125;;<br></code></pre></td></tr></table></figure><p>如上MessageQueue就是消息队列</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">class</span> <span class="hljs-title">COMPONENT_EXPORT</span><span class="hljs-params">(MOJO_CORE_PORTS)</span> MessageQueue </span>&#123;<br>......<br> <span class="hljs-keyword">private</span>:<br>  std::vector&lt;std::unique_ptr&lt;UserMessageEvent&gt;&gt; heap_;<br>  <span class="hljs-type">uint64_t</span> next_sequence_num_;<br>  <span class="hljs-type">bool</span> signalable_ = <span class="hljs-literal">true</span>;<br>  <span class="hljs-type">size_t</span> total_queued_bytes_ = <span class="hljs-number">0</span>;<br>&#125;;<br></code></pre></td></tr></table></figure><p>如上源码可以看出UserMessageEvent是存储的为一个vector数组结构。</p><h2 id="ChannelPosix类"><a href="#ChannelPosix类" class="headerlink" title="ChannelPosix类"></a>ChannelPosix类</h2><p>路径：mojo&#x2F;core&#x2F;channel_posix.h mojo&#x2F;core&#x2F;channel_posix.cc</p><p>用于保存进程间通道fd句柄，最底层的消息读取，消息发送。不同的平台有差异，Linux平台是采用Unix Socket跨进程通信的，实现类是ChannelPosix。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ChannelPosix</span> : <span class="hljs-keyword">public</span> Channel,<br>                     <span class="hljs-keyword">public</span> base::CurrentThread::DestructionObserver,<br>                     <span class="hljs-keyword">public</span> base::MessagePumpForIO::FdWatcher &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-built_in">ChannelPosix</span>(Delegate* delegate,<br>               ConnectionParams connection_params,<br>               HandlePolicy handle_policy,<br>               scoped_refptr&lt;base::SingleThreadTaskRunner&gt; io_task_runner);<br><br>  <span class="hljs-built_in">ChannelPosix</span>(<span class="hljs-type">const</span> ChannelPosix&amp;) = <span class="hljs-keyword">delete</span>;<br>  ChannelPosix&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> ChannelPosix&amp;) = <span class="hljs-keyword">delete</span>;<br><br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Start</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span></span>;<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ShutDownImpl</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span></span>;<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Write</span><span class="hljs-params">(MessagePtr message)</span> <span class="hljs-keyword">override</span></span>; <span class="hljs-comment">// 消息发送</span><br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">LeakHandle</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span></span>;<br>  <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">GetReadPlatformHandles</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">void</span>* payload,</span></span><br><span class="hljs-params"><span class="hljs-function">                              <span class="hljs-type">size_t</span> payload_size,</span></span><br><span class="hljs-params"><span class="hljs-function">                              <span class="hljs-type">size_t</span> num_handles,</span></span><br><span class="hljs-params"><span class="hljs-function">                              <span class="hljs-type">const</span> <span class="hljs-type">void</span>* extra_header,</span></span><br><span class="hljs-params"><span class="hljs-function">                              <span class="hljs-type">size_t</span> extra_header_size,</span></span><br><span class="hljs-params"><span class="hljs-function">                              std::vector&lt;PlatformHandle&gt;* handles,</span></span><br><span class="hljs-params"><span class="hljs-function">                              <span class="hljs-type">bool</span>* deferred)</span> <span class="hljs-keyword">override</span></span>;<br>  <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">OnControlMessage</span><span class="hljs-params">(Message::MessageType message_type,</span></span><br><span class="hljs-params"><span class="hljs-function">                        <span class="hljs-type">const</span> <span class="hljs-type">void</span>* payload,</span></span><br><span class="hljs-params"><span class="hljs-function">                        <span class="hljs-type">size_t</span> payload_size,</span></span><br><span class="hljs-params"><span class="hljs-function">                        std::vector&lt;PlatformHandle&gt; handles)</span> <span class="hljs-keyword">override</span></span>;<br>......<br> <span class="hljs-keyword">private</span>:<br>......<br>  <span class="hljs-comment">// We may be initialized with a server socket, in which case this will be</span><br>  <span class="hljs-comment">// valid until it accepts an incoming connection.</span><br>  PlatformChannelServerEndpoint server_;<br><br>  <span class="hljs-comment">// The socket over which to communicate. May be passed in at construction time</span><br>  <span class="hljs-comment">// or accepted over |server_|.</span><br>  base::ScopedFD socket_;<span class="hljs-comment">// fd句柄</span><br><br>  <span class="hljs-comment">// These watchers must only be accessed on the IO thread.</span><br>  std::unique_ptr&lt;base::MessagePumpForIO::FdWatchController&gt; read_watcher_;<br>  std::unique_ptr&lt;base::MessagePumpForIO::FdWatchController&gt; write_watcher_;<br>.......<br>&#125;;<br></code></pre></td></tr></table></figure><p>如上socket_就是socket的fd通信句柄。那创建fd是在哪里呢？<br>1.PlatformChannel是用于创建fd的地方（mojo&#x2F;public&#x2F;cpp&#x2F;platform&#x2F;platform_channel.cc）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">CreateChannel</span><span class="hljs-params">(PlatformHandle* local_endpoint,</span></span><br><span class="hljs-params"><span class="hljs-function">                   PlatformHandle* remote_endpoint)</span> </span>&#123;<br>  <span class="hljs-type">int</span> fds[<span class="hljs-number">2</span>];<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> BUILDFLAG(IS_NACL)</span><br>  <span class="hljs-built_in">PCHECK</span>(<span class="hljs-built_in">imc_socketpair</span>(fds) == <span class="hljs-number">0</span>);<br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>  <span class="hljs-built_in">PCHECK</span>(<span class="hljs-built_in">socketpair</span>(AF_UNIX, SOCK_STREAM, <span class="hljs-number">0</span>, fds) == <span class="hljs-number">0</span>);<br><br>  <span class="hljs-comment">// Set non-blocking on both ends.</span><br>  <span class="hljs-built_in">PCHECK</span>(<span class="hljs-built_in">fcntl</span>(fds[<span class="hljs-number">0</span>], F_SETFL, O_NONBLOCK) == <span class="hljs-number">0</span>);<br>  <span class="hljs-built_in">PCHECK</span>(<span class="hljs-built_in">fcntl</span>(fds[<span class="hljs-number">1</span>], F_SETFL, O_NONBLOCK) == <span class="hljs-number">0</span>);<br><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> BUILDFLAG(IS_APPLE)</span><br>  <span class="hljs-comment">// This turns off |SIGPIPE| when writing to a closed socket, causing the call</span><br>  <span class="hljs-comment">// to fail with |EPIPE| instead. On Linux we have to use |send...()| with</span><br>  <span class="hljs-comment">// |MSG_NOSIGNAL| instead, which is not supported on Mac.</span><br>  <span class="hljs-type">int</span> no_sigpipe = <span class="hljs-number">1</span>;<br>  <span class="hljs-built_in">PCHECK</span>(<span class="hljs-built_in">setsockopt</span>(fds[<span class="hljs-number">0</span>], SOL_SOCKET, SO_NOSIGPIPE, &amp;no_sigpipe,<br>                    <span class="hljs-built_in">sizeof</span>(no_sigpipe)) == <span class="hljs-number">0</span>);<br>  <span class="hljs-built_in">PCHECK</span>(<span class="hljs-built_in">setsockopt</span>(fds[<span class="hljs-number">1</span>], SOL_SOCKET, SO_NOSIGPIPE, &amp;no_sigpipe,<br>                    <span class="hljs-built_in">sizeof</span>(no_sigpipe)) == <span class="hljs-number">0</span>);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span>  <span class="hljs-comment">// BUILDFLAG(IS_APPLE)</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span>  <span class="hljs-comment">// BUILDFLAG(IS_NACL)</span></span><br><br>  *local_endpoint = <span class="hljs-built_in">PlatformHandle</span>(base::<span class="hljs-built_in">ScopedFD</span>(fds[<span class="hljs-number">0</span>]));<br>  *remote_endpoint = <span class="hljs-built_in">PlatformHandle</span>(base::<span class="hljs-built_in">ScopedFD</span>(fds[<span class="hljs-number">1</span>]));<br>  <span class="hljs-built_in">DCHECK</span>(local_endpoint-&gt;<span class="hljs-built_in">is_valid</span>());<br>  <span class="hljs-built_in">DCHECK</span>(remote_endpoint-&gt;<span class="hljs-built_in">is_valid</span>());<br>&#125;<br></code></pre></td></tr></table></figure><p>如上代码CreateChannel就是用于创建fd通信句柄的函数，主要是调用系统的socketpair创建。</p><p>2.ChannelPosix::WriteNoLock函数用于发送消息，最终是调用send发送消息</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">ssize_t</span> <span class="hljs-title">SocketWrite</span><span class="hljs-params">(base::PlatformFile socket,</span></span><br><span class="hljs-params"><span class="hljs-function">                    <span class="hljs-type">const</span> <span class="hljs-type">void</span>* bytes,</span></span><br><span class="hljs-params"><span class="hljs-function">                    <span class="hljs-type">size_t</span> num_bytes)</span> </span>&#123;<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> BUILDFLAG(IS_APPLE)</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">HANDLE_EINTR</span>(<span class="hljs-built_in">write</span>(socket, bytes, num_bytes));<br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">send</span>(socket, bytes, num_bytes, kSendmsgFlags);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>&#125;<br></code></pre></td></tr></table></figure><p>3.ChannelPosix::OnFileCanReadWithoutBlocking用于读取消息，最终读取到port消息队列中</p><h2 id="Mojo消息发送流程"><a href="#Mojo消息发送流程" class="headerlink" title="Mojo消息发送流程"></a>Mojo消息发送流程</h2><p><img src="/2022/05/04/Chromium-Mojo-Core%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90/10.jpg"><br>上图就是在Proxy端调用mojo接口，到系统底层发送给另一进程的主要流程图。注意图中Endpoint和MultiplexRouter::InterfaceEndpoint的基类是InterfaceEndpointController，他们区别是Endpoint是用于非关联接口的，而MultiplexRouter::InterfaceEndpoint用于关联接口的</p><h2 id="Mojo消息读取处理流程"><a href="#Mojo消息读取处理流程" class="headerlink" title="Mojo消息读取处理流程"></a>Mojo消息读取处理流程</h2><p><img src="/2022/05/04/Chromium-Mojo-Core%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90/11.jpg"><br>上图就是mojo的接口Impl消息处理流程图，这里要注意异步关系，消息是先从socket读取到port消息队列中，然后SimpleWatcher监听到有port有消息需要处理，则进行处理，所以读消息和处理消息不是在一个任务中。如果消息携带需要创建其他接口Handle，则调用ExtractSerializedHandles最终创建一个MessagePipeDispatcher</p><h2 id="Mojo-接口内部类关系"><a href="#Mojo-接口内部类关系" class="headerlink" title="Mojo 接口内部类关系"></a>Mojo 接口内部类关系</h2><p>假设有3个进程，有3个mojo接口，他们之间相互通信，那Mojo Core内部的对应关系是怎么样的？</p><p>A接口，在进程1中创建，作用是和进程3通信</p><p>B接口，在进程2中创建，作用是和进程1通信</p><p>C接口，在进程3中创建，作用是和进程2通信<br><img src="/2022/05/04/Chromium-Mojo-Core%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90/12.jpg"><br>通过这3个进程和3个mojo接口，我们看下mojo core内部对应的结构<br><img src="/2022/05/04/Chromium-Mojo-Core%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90/13.jpg"><br>解释：</p><p>1.从上面可以看出每个mojo接口有进程发送的Proxy端，实现端是Impl端<br>2.每个mojo接口对一一对应一个InterfaceEndPointClient和InterfaceEnd<br>3.在Proxy端对应两个MessagePipeDispatcher消息处理，这个是存储在HanldeTable中<br>4.每个MessagePipeDispatcher会对应一个port（端口），端口会对应一个port_name<br>5.一个进程只有一个Node<br>6.一个进程只有一个NodeController<br>7.假如进程1和2,3进程通信，则在进程1中会有对相应2，3的NodeChannel和ChannelPosix（Linux平台），Socket fd</p><p>以上有错误，请多多指教</p><p>同步知乎：<a href="https://zhuanlan.zhihu.com/p/426069459">https://zhuanlan.zhihu.com/p/426069459</a></p>]]></content>
    
    
    <categories>
      
      <category>Chromium</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Mojo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>V8 CreateObjectLiteral字节码处理程序</title>
    <link href="/2022/05/04/V8-CreateObjectLiteral%E5%AD%97%E8%8A%82%E7%A0%81%E5%A4%84%E7%90%86%E7%A8%8B%E5%BA%8F/"/>
    <url>/2022/05/04/V8-CreateObjectLiteral%E5%AD%97%E8%8A%82%E7%A0%81%E5%A4%84%E7%90%86%E7%A8%8B%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<p>CreateObjectLiteral <element_idx> <literal_idx> <flags></p><p>作用：对象生成</p><p>js代码用例代码：</p><figure class="highlight js"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs JS"><span class="hljs-keyword">var</span> x = &#123;<span class="hljs-attr">x</span>:<span class="hljs-number">0</span>,<span class="hljs-attr">y</span>:<span class="hljs-number">0</span>&#125;;<br></code></pre></td></tr></table></figure><p>上述js生成的对应字节字节码</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-symbol">LdaConstant</span> [<span class="hljs-number">0</span>]<br><span class="hljs-symbol">Star</span> <span class="hljs-built_in">r1</span> <br><span class="hljs-symbol">LdaZero</span><br><span class="hljs-symbol">Star</span> <span class="hljs-built_in">r2</span><br><span class="hljs-keyword">Mov</span> &lt;closure&gt;, <span class="hljs-built_in">r3</span><br><span class="hljs-symbol">CallRuntime</span> [DeclareGlobalsForInterpreter], <span class="hljs-built_in">r1</span>-<span class="hljs-built_in">r3</span><br><span class="hljs-symbol">StackCheck</span><br><span class="hljs-symbol">CreateObjectLiteral</span> [<span class="hljs-number">1</span>], [<span class="hljs-number">2</span>], <span class="hljs-number">#41</span>, <span class="hljs-built_in">r1</span><br><span class="hljs-symbol">Ldar</span> <span class="hljs-built_in">r1</span><br><span class="hljs-symbol">StaGlobal</span> [<span class="hljs-number">2</span>], [<span class="hljs-number">3</span>]<br><span class="hljs-symbol">LdaUndefined</span> <br><span class="hljs-symbol">Return</span><br></code></pre></td></tr></table></figure><p>CreateObjectLiteral字节码处理程序</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-built_in">IGNITION_HANDLER</span>(CreateObjectLiteral, InterpreterAssembler) &#123;<br>  Node* feedback_vector = <span class="hljs-built_in">LoadFeedbackVector</span>();<br>  Node* slot_id = <span class="hljs-built_in">BytecodeOperandIdx</span>(<span class="hljs-number">1</span>);<br>  Node* bytecode_flags = <span class="hljs-built_in">BytecodeOperandFlag</span>(<span class="hljs-number">2</span>);<br><br>  <span class="hljs-comment">// Check if we can do a fast clone or have to call the runtime.</span><br>  <span class="hljs-function">Label <span class="hljs-title">if_fast_clone</span><span class="hljs-params">(<span class="hljs-keyword">this</span>)</span>, <span class="hljs-title">if_not_fast_clone</span><span class="hljs-params">(<span class="hljs-keyword">this</span>, Label::kDeferred)</span></span>;<br>  <span class="hljs-built_in">Branch</span>(<span class="hljs-built_in">IsSetWord32</span>&lt;CreateObjectLiteralFlags::FastCloneSupportedBit&gt;(<br>             bytecode_flags),<br>         &amp;if_fast_clone, &amp;if_not_fast_clone);<br><br>  <span class="hljs-built_in">BIND</span>(&amp;if_fast_clone);<br>  &#123;<br>    <span class="hljs-comment">// If we can do a fast clone do the fast-path in CreateShallowObjectLiteral.</span><br>    <span class="hljs-function">ConstructorBuiltinsAssembler <span class="hljs-title">constructor_assembler</span><span class="hljs-params">(state())</span></span>;<br>    Node* result = constructor_assembler.<span class="hljs-built_in">EmitCreateShallowObjectLiteral</span>(<br>        feedback_vector, slot_id, &amp;if_not_fast_clone);<br>    <span class="hljs-built_in">StoreRegister</span>(result, <span class="hljs-built_in">BytecodeOperandReg</span>(<span class="hljs-number">3</span>));<br>    <span class="hljs-built_in">Dispatch</span>();<br>  &#125;<br><br>  <span class="hljs-built_in">BIND</span>(&amp;if_not_fast_clone);<br>  &#123;<br>    <span class="hljs-comment">// If we can&#x27;t do a fast clone, call into the runtime.</span><br>    Node* index = <span class="hljs-built_in">BytecodeOperandIdx</span>(<span class="hljs-number">0</span>);<br>    Node* boilerplate_description = <span class="hljs-built_in">LoadConstantPoolEntry</span>(index);<br>    Node* context = <span class="hljs-built_in">GetContext</span>();<br><br>    Node* flags_raw = <span class="hljs-built_in">DecodeWordFromWord32</span>&lt;CreateObjectLiteralFlags::FlagsBits&gt;(<br>        bytecode_flags);<br>    Node* flags = <span class="hljs-built_in">SmiTag</span>(flags_raw);<br><br>    Node* result =<br>        <span class="hljs-built_in">CallRuntime</span>(Runtime::kCreateObjectLiteral, context, feedback_vector,<br>                    <span class="hljs-built_in">SmiTag</span>(slot_id), boilerplate_description, flags); <span class="hljs-comment">// 调用CreateObjectLiteral处理程序</span><br>    <span class="hljs-built_in">StoreRegister</span>(result, <span class="hljs-built_in">BytecodeOperandReg</span>(<span class="hljs-number">3</span>));<br>    <span class="hljs-comment">// TODO(klaasb) build a single dispatch once the call is inlined</span><br>    <span class="hljs-built_in">Dispatch</span>();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>调用运行时函数CreateObjectLiteral</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-built_in">RUNTIME_FUNCTION</span>(Runtime_CreateObjectLiteral) &#123;<br>  <span class="hljs-function">HandleScope <span class="hljs-title">scope</span><span class="hljs-params">(isolate)</span></span>;<br>  <span class="hljs-built_in">DCHECK_EQ</span>(<span class="hljs-number">4</span>, args.<span class="hljs-built_in">length</span>());<br>  <span class="hljs-built_in">CONVERT_ARG_HANDLE_CHECKED</span>(FeedbackVector, vector, <span class="hljs-number">0</span>);<br>  <span class="hljs-built_in">CONVERT_SMI_ARG_CHECKED</span>(literals_index, <span class="hljs-number">1</span>);<br>  <span class="hljs-built_in">CONVERT_ARG_HANDLE_CHECKED</span>(BoilerplateDescription, description, <span class="hljs-number">2</span>);<br>  <span class="hljs-built_in">CONVERT_SMI_ARG_CHECKED</span>(flags, <span class="hljs-number">3</span>);<br>  <span class="hljs-built_in">RETURN_RESULT_OR_FAILURE</span>(<br>      isolate, <span class="hljs-built_in">CreateLiteral</span>&lt;ObjectBoilerplate&gt;(isolate, vector, literals_index,<br>                                                description, flags));<br>&#125;<br></code></pre></td></tr></table></figure><p>调用运行时函数CreateLiteral，结果最终返回一个JSObject对象</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Boilerplate&gt;<br><span class="hljs-function">MaybeHandle&lt;JSObject&gt; <span class="hljs-title">CreateLiteral</span><span class="hljs-params">(Isolate* isolate,</span></span><br><span class="hljs-params"><span class="hljs-function">                                    Handle&lt;FeedbackVector&gt; vector,</span></span><br><span class="hljs-params"><span class="hljs-function">                                    <span class="hljs-type">int</span> literals_index,</span></span><br><span class="hljs-params"><span class="hljs-function">                                    Handle&lt;HeapObject&gt; description, <span class="hljs-type">int</span> flags)</span> </span>&#123;<br>  <span class="hljs-function">FeedbackSlot <span class="hljs-title">literals_slot</span><span class="hljs-params">(FeedbackVector::ToSlot(literals_index))</span></span>;<br>  <span class="hljs-built_in">CHECK</span>(literals_slot.<span class="hljs-built_in">ToInt</span>() &lt; vector-&gt;<span class="hljs-built_in">length</span>());<br>  <span class="hljs-function">Handle&lt;Object&gt; <span class="hljs-title">literal_site</span><span class="hljs-params">(vector-&gt;Get(literals_slot), isolate)</span></span>;<br>  DeepCopyHints copy_hints =<br>      (flags &amp; AggregateLiteral::kIsShallow) ? kObjectIsShallow : kNoHints;<br>  <span class="hljs-keyword">if</span> (FLAG_track_double_fields &amp;&amp; !FLAG_unbox_double_fields) &#123;<br>    <span class="hljs-comment">// Make sure we properly clone mutable heap numbers on 32-bit platforms.</span><br>    copy_hints = kNoHints;<br>  &#125;<br><br>  Handle&lt;AllocationSite&gt; site;<br>  Handle&lt;JSObject&gt; boilerplate;<br><br>  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">HasBoilerplate</span>(isolate, literal_site)) &#123;<br>    site = Handle&lt;AllocationSite&gt;::<span class="hljs-built_in">cast</span>(literal_site);<br>    boilerplate = <span class="hljs-built_in">Handle</span>&lt;JSObject&gt;(site-&gt;<span class="hljs-built_in">boilerplate</span>(), isolate);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// Eagerly create AllocationSites for literals that contain an Array.</span><br>    <span class="hljs-type">bool</span> needs_initial_allocation_site =<br>        (flags &amp; AggregateLiteral::kNeedsInitialAllocationSite) != <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// TODO(cbruni): Even in the case where we need an initial allocation site</span><br>    <span class="hljs-comment">// we could still create the boilerplate lazily to save memory.</span><br>    <span class="hljs-keyword">if</span> (!needs_initial_allocation_site &amp;&amp;<br>        <span class="hljs-built_in">IsUninitializedLiteralSite</span>(*literal_site)) &#123;<br>      <span class="hljs-built_in">PreInitializeLiteralSite</span>(vector, literals_slot);<br>      boilerplate =<br>          Boilerplate::<span class="hljs-built_in">Create</span>(isolate, description, flags, NOT_TENURED);<br>      <span class="hljs-keyword">if</span> (copy_hints == kNoHints) &#123;<br>        <span class="hljs-function">DeprecationUpdateContext <span class="hljs-title">update_context</span><span class="hljs-params">(isolate)</span></span>;<br>        <span class="hljs-built_in">RETURN_ON_EXCEPTION</span>(isolate, <span class="hljs-built_in">DeepWalk</span>(boilerplate, &amp;update_context),<br>                            JSObject);<br>      &#125;<br>      <span class="hljs-keyword">return</span> boilerplate;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      PretenureFlag pretenure_flag =<br>          isolate-&gt;<span class="hljs-built_in">heap</span>()-&gt;<span class="hljs-built_in">InNewSpace</span>(*vector) ? NOT_TENURED : TENURED;<br>      boilerplate =<br>          Boilerplate::<span class="hljs-built_in">Create</span>(isolate, description, flags, pretenure_flag);<br>    &#125;<br>    <span class="hljs-comment">// Install AllocationSite objects.</span><br>    <span class="hljs-function">AllocationSiteCreationContext <span class="hljs-title">creation_context</span><span class="hljs-params">(isolate)</span></span>;<br>    site = creation_context.<span class="hljs-built_in">EnterNewScope</span>();<br>    <span class="hljs-built_in">RETURN_ON_EXCEPTION</span>(isolate, <span class="hljs-built_in">DeepWalk</span>(boilerplate, &amp;creation_context),<br>                        JSObject);<br>    creation_context.<span class="hljs-built_in">ExitScope</span>(site, boilerplate);<br><br>    vector-&gt;<span class="hljs-built_in">Set</span>(literals_slot, *site);<br>  &#125;<br><br>  <span class="hljs-built_in">STATIC_ASSERT</span>(<span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">int</span>&gt;(ObjectLiteral::kDisableMementos) ==<br>                <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">int</span>&gt;(ArrayLiteral::kDisableMementos));<br>  <span class="hljs-type">bool</span> enable_mementos = (flags &amp; ObjectLiteral::kDisableMementos) == <span class="hljs-number">0</span>;<br><br>  <span class="hljs-comment">// Copy the existing boilerplate.</span><br>  <span class="hljs-function">AllocationSiteUsageContext <span class="hljs-title">usage_context</span><span class="hljs-params">(isolate, site, enable_mementos)</span></span>;<br>  usage_context.<span class="hljs-built_in">EnterNewScope</span>();<br>  MaybeHandle&lt;JSObject&gt; copy =<br>      <span class="hljs-built_in">DeepCopy</span>(boilerplate, &amp;usage_context, copy_hints);<br>  usage_context.<span class="hljs-built_in">ExitScope</span>(site, boilerplate);<br>  <span class="hljs-keyword">return</span> copy;<br>&#125;<br></code></pre></td></tr></table></figure><p>同步知乎：<a href="https://zhuanlan.zhihu.com/p/80167095">https://zhuanlan.zhihu.com/p/80167095</a></p>]]></content>
    
    
    <categories>
      
      <category>V8</category>
      
    </categories>
    
    
    <tags>
      
      <tag>字节码</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>V8 StaNamedProperty字节码处理程序</title>
    <link href="/2022/05/04/V8-StaNamedProperty%E5%AD%97%E8%8A%82%E7%A0%81%E5%A4%84%E7%90%86%E7%A8%8B%E5%BA%8F/"/>
    <url>/2022/05/04/V8-StaNamedProperty%E5%AD%97%E8%8A%82%E7%A0%81%E5%A4%84%E7%90%86%E7%A8%8B%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<p>js代码</p><figure class="highlight js"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><pre><code class="hljs JS"><span class="hljs-keyword">var</span> x = &#123;<span class="hljs-attr">x</span>:<span class="hljs-number">0</span>,<span class="hljs-attr">y</span>:<span class="hljs-number">0</span>&#125;;<br>x.<span class="hljs-property">c</span> = <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><p>d8 –print_bytecode 生成对应的字节码</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-symbol">LdaConstant</span> [<span class="hljs-number">0</span>]<br><span class="hljs-symbol">Star</span> <span class="hljs-built_in">r1</span><br><span class="hljs-symbol">LdaZero</span> <br><span class="hljs-symbol">Star</span> <span class="hljs-built_in">r2</span><br><span class="hljs-keyword">Mov</span> &lt;closure&gt;, <span class="hljs-built_in">r3</span><br><span class="hljs-symbol">CallRuntime</span> [DeclareGlobalsForInterpreter], <span class="hljs-built_in">r1</span>-<span class="hljs-built_in">r3</span><br><span class="hljs-symbol">StackCheck</span><br><span class="hljs-symbol">CreateObjectLiteral</span> [<span class="hljs-number">1</span>], [<span class="hljs-number">2</span>], <span class="hljs-number">#41</span>, <span class="hljs-built_in">r1</span><br><span class="hljs-symbol">Ldar</span> <span class="hljs-built_in">r1</span><br><span class="hljs-symbol">StaGlobal</span> [<span class="hljs-number">2</span>], [<span class="hljs-number">3</span>]<br><span class="hljs-symbol">LdaGlobal</span> [<span class="hljs-number">2</span>], [<span class="hljs-number">0</span>]<br><span class="hljs-symbol">Star</span> <span class="hljs-built_in">r1</span><br><span class="hljs-symbol">LdaSmi</span> [<span class="hljs-number">1</span>]<br><span class="hljs-symbol">Star</span> <span class="hljs-built_in">r2</span><br><span class="hljs-symbol">StaNamedProperty</span> <span class="hljs-built_in">r1</span>, [<span class="hljs-number">3</span>], [<span class="hljs-number">5</span>]<br><span class="hljs-keyword">Mov</span> <span class="hljs-built_in">r2</span>, <span class="hljs-built_in">r0</span><br><span class="hljs-symbol">Ldar</span> <span class="hljs-built_in">r0</span><br><span class="hljs-symbol">Return</span><br></code></pre></td></tr></table></figure><h3 id="StaNamedProperty字节码代码处理程序"><a href="#StaNamedProperty字节码代码处理程序" class="headerlink" title="StaNamedProperty字节码代码处理程序"></a>StaNamedProperty字节码代码处理程序</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-built_in">IGNITION_HANDLER</span>(StaNamedProperty, InterpreterStoreNamedPropertyAssembler) &#123;<br>  Callable ic = Builtins::<span class="hljs-built_in">CallableFor</span>(<span class="hljs-built_in">isolate</span>(), Builtins::kStoreIC);<br>  <span class="hljs-built_in">StaNamedProperty</span>(ic);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="StoreIC内置函数"><a href="#StoreIC内置函数" class="headerlink" title="StoreIC内置函数"></a>StoreIC内置函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">AccessorAssembler::StoreIC</span><span class="hljs-params">(<span class="hljs-type">const</span> StoreICParameters* p)</span> </span>&#123;<br>  <span class="hljs-built_in">VARIABLE</span>(var_handler, MachineRepresentation::kTagged);<br>  <span class="hljs-function">Label <span class="hljs-title">if_handler</span><span class="hljs-params">(<span class="hljs-keyword">this</span>, &amp;var_handler)</span>, <span class="hljs-title">try_polymorphic</span><span class="hljs-params">(<span class="hljs-keyword">this</span>, Label::kDeferred)</span>,</span><br><span class="hljs-function">      <span class="hljs-title">try_megamorphic</span><span class="hljs-params">(<span class="hljs-keyword">this</span>, Label::kDeferred)</span>,</span><br><span class="hljs-function">      <span class="hljs-title">try_uninitialized</span><span class="hljs-params">(<span class="hljs-keyword">this</span>, Label::kDeferred)</span>, <span class="hljs-title">miss</span><span class="hljs-params">(<span class="hljs-keyword">this</span>, Label::kDeferred)</span></span>;<br><br>  Node* receiver_map = <span class="hljs-built_in">LoadReceiverMap</span>(p-&gt;receiver);<br>  <span class="hljs-built_in">GotoIf</span>(<span class="hljs-built_in">IsDeprecatedMap</span>(receiver_map), &amp;miss);<br><br>  <span class="hljs-comment">// Check monomorphic case.</span><br>  Node* feedback =<br>      <span class="hljs-built_in">TryMonomorphicCase</span>(p-&gt;slot, p-&gt;vector, receiver_map, &amp;if_handler,<br>                         &amp;var_handler, &amp;try_polymorphic);<br>  <span class="hljs-built_in">BIND</span>(&amp;if_handler);<br>  &#123;<br>    <span class="hljs-built_in">Comment</span>(<span class="hljs-string">&quot;StoreIC_if_handler&quot;</span>);<br>    <span class="hljs-built_in">HandleStoreICHandlerCase</span>(p, var_handler.<span class="hljs-built_in">value</span>(), &amp;miss,<br>                             ICMode::kNonGlobalIC);<br>  &#125;<br><br>  <span class="hljs-built_in">BIND</span>(&amp;try_polymorphic);<br>  &#123;<br>    <span class="hljs-comment">// Check polymorphic case.</span><br>    <span class="hljs-built_in">Comment</span>(<span class="hljs-string">&quot;StoreIC_try_polymorphic&quot;</span>);<br>    <span class="hljs-built_in">GotoIfNot</span>(<br>        <span class="hljs-built_in">WordEqual</span>(<span class="hljs-built_in">LoadMap</span>(feedback), <span class="hljs-built_in">LoadRoot</span>(Heap::kFixedArrayMapRootIndex)),<br>        &amp;try_megamorphic);<br>    <span class="hljs-built_in">HandlePolymorphicCase</span>(receiver_map, feedback, &amp;if_handler, &amp;var_handler,<br>                          &amp;miss, <span class="hljs-number">2</span>);<br>  &#125;<br><br>  <span class="hljs-built_in">BIND</span>(&amp;try_megamorphic);<br>  &#123;<br>    <span class="hljs-comment">// Check megamorphic case.</span><br>    <span class="hljs-built_in">GotoIfNot</span>(<span class="hljs-built_in">WordEqual</span>(feedback, <span class="hljs-built_in">LoadRoot</span>(Heap::kmegamorphic_symbolRootIndex)),<br>              &amp;try_uninitialized);<br><br>    <span class="hljs-built_in">TryProbeStubCache</span>(<span class="hljs-built_in">isolate</span>()-&gt;<span class="hljs-built_in">store_stub_cache</span>(), p-&gt;receiver, p-&gt;name,<br>                      &amp;if_handler, &amp;var_handler, &amp;miss);<br>  &#125;<br>  <span class="hljs-built_in">BIND</span>(&amp;try_uninitialized);<br>  &#123;<br>    <span class="hljs-comment">// Check uninitialized case.</span><br>    <span class="hljs-built_in">GotoIfNot</span>(<br>        <span class="hljs-built_in">WordEqual</span>(feedback, <span class="hljs-built_in">LoadRoot</span>(Heap::kuninitialized_symbolRootIndex)),<br>        &amp;miss);<br>    Callable stub =<br>        Builtins::<span class="hljs-built_in">CallableFor</span>(<span class="hljs-built_in">isolate</span>(), Builtins::kStoreIC_Uninitialized);<br>    <span class="hljs-built_in">TailCallStub</span>(stub, p-&gt;context, p-&gt;receiver, p-&gt;name, p-&gt;value, p-&gt;slot,<br>                 p-&gt;vector);<br>  &#125;<br>  <span class="hljs-built_in">BIND</span>(&amp;miss);<br>  &#123;<br>    <span class="hljs-built_in">TailCallRuntime</span>(Runtime::kStoreIC_Miss, p-&gt;context, p-&gt;value, p-&gt;slot,<br>                    p-&gt;vector, p-&gt;receiver, p-&gt;name);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="内置函数StoreIC-Uninitialized"><a href="#内置函数StoreIC-Uninitialized" class="headerlink" title="内置函数StoreIC_Uninitialized"></a>内置函数StoreIC_Uninitialized</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">KeyedStoreGenericAssembler::StoreIC_Uninitialized</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-keyword">typedef</span> StoreWithVectorDescriptor Descriptor;<br><br>  Node* receiver = <span class="hljs-built_in">Parameter</span>(Descriptor::kReceiver);<br>  Node* name = <span class="hljs-built_in">Parameter</span>(Descriptor::kName);<br>  Node* value = <span class="hljs-built_in">Parameter</span>(Descriptor::kValue);<br>  Node* slot = <span class="hljs-built_in">Parameter</span>(Descriptor::kSlot);<br>  Node* vector = <span class="hljs-built_in">Parameter</span>(Descriptor::kVector);<br>  Node* context = <span class="hljs-built_in">Parameter</span>(Descriptor::kContext);<br><br>  <span class="hljs-function">Label <span class="hljs-title">miss</span><span class="hljs-params">(<span class="hljs-keyword">this</span>)</span></span>;<br><br>  <span class="hljs-built_in">GotoIf</span>(<span class="hljs-built_in">TaggedIsSmi</span>(receiver), &amp;miss);<br>  Node* receiver_map = <span class="hljs-built_in">LoadMap</span>(receiver);<br>  Node* instance_type = <span class="hljs-built_in">LoadMapInstanceType</span>(receiver_map);<br>  <span class="hljs-comment">// Receivers requiring non-standard element accesses (interceptors, access</span><br>  <span class="hljs-comment">// checks, strings and string wrappers, proxies) are handled in the runtime.</span><br>  <span class="hljs-built_in">GotoIf</span>(<span class="hljs-built_in">Int32LessThanOrEqual</span>(instance_type,<br>                              <span class="hljs-built_in">Int32Constant</span>(LAST_SPECIAL_RECEIVER_TYPE)),<br>         &amp;miss);<br><br>  <span class="hljs-comment">// Optimistically write the state transition to the vector.</span><br>  <span class="hljs-built_in">StoreFeedbackVectorSlot</span>(vector, slot,<br>                          <span class="hljs-built_in">LoadRoot</span>(Heap::kpremonomorphic_symbolRootIndex),<br>                          SKIP_WRITE_BARRIER, <span class="hljs-number">0</span>, SMI_PARAMETERS);<br><br>  <span class="hljs-function">StoreICParameters <span class="hljs-title">p</span><span class="hljs-params">(context, receiver, name, value, slot, vector)</span></span>;<br>  <span class="hljs-built_in">EmitGenericPropertyStore</span>(receiver, receiver_map, &amp;p, &amp;miss,<br>                           kDontUseStubCache);<br><br>  <span class="hljs-built_in">BIND</span>(&amp;miss);<br>  &#123;<br>    <span class="hljs-comment">// Undo the optimistic state transition.</span><br>    <span class="hljs-built_in">StoreFeedbackVectorSlot</span>(vector, slot,<br>                            <span class="hljs-built_in">LoadRoot</span>(Heap::kuninitialized_symbolRootIndex),<br>                            SKIP_WRITE_BARRIER, <span class="hljs-number">0</span>, SMI_PARAMETERS);<br>    <span class="hljs-built_in">Print</span>(<span class="hljs-string">&quot;laiyonggao KeyedStoreGenericAssembler::kStoreIC_Miss \n&quot;</span>);<br>    <span class="hljs-built_in">TailCallRuntime</span>(Runtime::kStoreIC_Miss, context, value, slot, vector,<br>                    receiver, name);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="StoreIC-Miss"><a href="#StoreIC-Miss" class="headerlink" title="StoreIC_Miss"></a>StoreIC_Miss</h3><p>如果对象没有此属性，则走miss流程，调用运行时函数StoreIC_Miss</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-built_in">RUNTIME_FUNCTION</span>(Runtime_StoreIC_Miss) &#123;<br>  <span class="hljs-function">HandleScope <span class="hljs-title">scope</span><span class="hljs-params">(isolate)</span></span>;<br>  <span class="hljs-built_in">DCHECK_EQ</span>(<span class="hljs-number">5</span>, args.<span class="hljs-built_in">length</span>());<br>  <span class="hljs-comment">// Runtime functions don&#x27;t follow the IC&#x27;s calling convention.</span><br>  Handle&lt;Object&gt; value = args.<span class="hljs-built_in">at</span>(<span class="hljs-number">0</span>);<br>  Handle&lt;Smi&gt; slot = args.<span class="hljs-built_in">at</span>&lt;Smi&gt;(<span class="hljs-number">1</span>);<br>  Handle&lt;FeedbackVector&gt; vector = args.<span class="hljs-built_in">at</span>&lt;FeedbackVector&gt;(<span class="hljs-number">2</span>);<br>  Handle&lt;Object&gt; receiver = args.<span class="hljs-built_in">at</span>(<span class="hljs-number">3</span>);<br>  Handle&lt;Name&gt; key = args.<span class="hljs-built_in">at</span>&lt;Name&gt;(<span class="hljs-number">4</span>);<br>  FeedbackSlot vector_slot = vector-&gt;<span class="hljs-built_in">ToSlot</span>(slot-&gt;<span class="hljs-built_in">value</span>());<br>  FeedbackSlotKind kind = vector-&gt;<span class="hljs-built_in">GetKind</span>(vector_slot);<br>  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">IsStoreICKind</span>(kind) || <span class="hljs-built_in">IsStoreOwnICKind</span>(kind)) &#123;<br>    <span class="hljs-function">StoreICNexus <span class="hljs-title">nexus</span><span class="hljs-params">(vector, vector_slot)</span></span>;<br>    <span class="hljs-function">StoreIC <span class="hljs-title">ic</span><span class="hljs-params">(isolate, &amp;nexus)</span></span>;<br>    ic.<span class="hljs-built_in">UpdateState</span>(receiver, key);<br>    <span class="hljs-built_in">RETURN_RESULT_OR_FAILURE</span>(isolate, ic.<span class="hljs-built_in">Store</span>(receiver, key, value));<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">IsStoreGlobalICKind</span>(kind)) &#123;<br>    <span class="hljs-built_in">DCHECK_EQ</span>(isolate-&gt;<span class="hljs-built_in">native_context</span>()-&gt;<span class="hljs-built_in">global_proxy</span>(), *receiver);<br>    receiver = isolate-&gt;<span class="hljs-built_in">global_object</span>();<br>    <span class="hljs-function">StoreGlobalICNexus <span class="hljs-title">nexus</span><span class="hljs-params">(vector, vector_slot)</span></span>;<br>    <span class="hljs-function">StoreGlobalIC <span class="hljs-title">ic</span><span class="hljs-params">(isolate, &amp;nexus)</span></span>;<br>    ic.<span class="hljs-built_in">UpdateState</span>(receiver, key);<br>    <span class="hljs-built_in">RETURN_RESULT_OR_FAILURE</span>(isolate, ic.<span class="hljs-built_in">Store</span>(key, value));<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-built_in">DCHECK</span>(<span class="hljs-built_in">IsKeyedStoreICKind</span>(kind));<br>    <span class="hljs-function">KeyedStoreICNexus <span class="hljs-title">nexus</span><span class="hljs-params">(vector, vector_slot)</span></span>;<br>    <span class="hljs-function">KeyedStoreIC <span class="hljs-title">ic</span><span class="hljs-params">(isolate, &amp;nexus)</span></span>;<br>    ic.<span class="hljs-built_in">UpdateState</span>(receiver, key);<br>    <span class="hljs-built_in">RETURN_RESULT_OR_FAILURE</span>(isolate, ic.<span class="hljs-built_in">Store</span>(receiver, key, value));<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="StoreIC-Store"><a href="#StoreIC-Store" class="headerlink" title="StoreIC::Store"></a>StoreIC::Store</h3><p>调用StoreIC::Store</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">MaybeHandle&lt;Object&gt; <span class="hljs-title">StoreIC::Store</span><span class="hljs-params">(Handle&lt;Object&gt; object, Handle&lt;Name&gt; name,</span></span><br><span class="hljs-params"><span class="hljs-function">                                   Handle&lt;Object&gt; value,</span></span><br><span class="hljs-params"><span class="hljs-function">                                   JSReceiver::StoreFromKeyed store_mode)</span> </span>&#123;<br>  <span class="hljs-comment">// TODO(verwaest): Let SetProperty do the migration, since storing a property</span><br>  <span class="hljs-comment">// might deprecate the current map again, if value does not fit.</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">MigrateDeprecated</span>(object)) &#123;<br>    Handle&lt;Object&gt; result;<br>    <span class="hljs-built_in">ASSIGN_RETURN_ON_EXCEPTION</span>(<br>        <span class="hljs-built_in">isolate</span>(), result,<br>        Object::<span class="hljs-built_in">SetProperty</span>(object, name, value, <span class="hljs-built_in">language_mode</span>()), Object);<br>    <span class="hljs-keyword">return</span> result;<br>  &#125;<br><br>  <span class="hljs-comment">// If the object is undefined or null it&#x27;s illegal to try to set any</span><br>  <span class="hljs-comment">// properties on it; throw a TypeError in that case.</span><br>  <span class="hljs-keyword">if</span> (object-&gt;<span class="hljs-built_in">IsNullOrUndefined</span>(<span class="hljs-built_in">isolate</span>())) &#123;<br>    <span class="hljs-keyword">if</span> (FLAG_use_ic &amp;&amp; <span class="hljs-built_in">state</span>() != PREMONOMORPHIC) &#123;<br>      <span class="hljs-comment">// Ensure the IC state progresses.</span><br>      <span class="hljs-built_in">TRACE_HANDLER_STATS</span>(<span class="hljs-built_in">isolate</span>(), StoreIC_NonReceiver);<br>      <span class="hljs-built_in">update_receiver_map</span>(object);<br>      <span class="hljs-built_in">PatchCache</span>(name, <span class="hljs-built_in">slow_stub</span>());<br>      <span class="hljs-built_in">TRACE_IC</span>(<span class="hljs-string">&quot;StoreIC&quot;</span>, name);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">TypeError</span>(MessageTemplate::kNonObjectPropertyStore, object, name);<br>  &#125;<br><br>  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">state</span>() != UNINITIALIZED) &#123;<br>    JSObject::<span class="hljs-built_in">MakePrototypesFast</span>(object, kStartAtPrototype, <span class="hljs-built_in">isolate</span>());<br>  &#125;<br>  MaybeHandle&lt;Object&gt; cached_handler;<br>  Handle&lt;Map&gt; transition_map;<br>  <span class="hljs-keyword">if</span> (object-&gt;<span class="hljs-built_in">IsJSReceiver</span>()) &#123;<br>    name = <span class="hljs-built_in">isolate</span>()-&gt;<span class="hljs-built_in">factory</span>()-&gt;<span class="hljs-built_in">InternalizeName</span>(name);<br>    <span class="hljs-function">TransitionsAccessor <span class="hljs-title">transitions</span><span class="hljs-params">(receiver_map())</span></span>;<br>    Object* maybe_handler = transitions.<span class="hljs-built_in">SearchHandler</span>(*name, &amp;transition_map);<br>    <span class="hljs-keyword">if</span> (maybe_handler != <span class="hljs-literal">nullptr</span>) &#123;<br>      cached_handler = <span class="hljs-built_in">MaybeHandle</span>&lt;Object&gt;(maybe_handler, <span class="hljs-built_in">isolate</span>());<br>    &#125;<br>  &#125;<br><br>  LookupIterator it = LookupIterator::<span class="hljs-built_in">ForTransitionHandler</span>(<br>      <span class="hljs-built_in">isolate</span>(), object, name, value, cached_handler, transition_map);<br>  <span class="hljs-keyword">if</span> (FLAG_use_ic) <span class="hljs-built_in">UpdateCaches</span>(&amp;it, value, store_mode, cached_handler);<br><br>  <span class="hljs-built_in">MAYBE_RETURN_NULL</span>(<br>      Object::<span class="hljs-built_in">SetProperty</span>(&amp;it, value, <span class="hljs-built_in">language_mode</span>(), store_mode));<br>  <span class="hljs-keyword">return</span> value;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Object-SetProperty"><a href="#Object-SetProperty" class="headerlink" title="Object::SetProperty"></a>Object::SetProperty</h3><p>调用Object::SetProperty</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">Maybe&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">Object::SetProperty</span><span class="hljs-params">(LookupIterator* it, Handle&lt;Object&gt; value,</span></span><br><span class="hljs-params"><span class="hljs-function">                                LanguageMode language_mode,</span></span><br><span class="hljs-params"><span class="hljs-function">                                StoreFromKeyed store_mode)</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (it-&gt;<span class="hljs-built_in">IsFound</span>()) &#123;<br>    <span class="hljs-type">bool</span> found = <span class="hljs-literal">true</span>;<br>    Maybe&lt;<span class="hljs-type">bool</span>&gt; result =<br>        <span class="hljs-built_in">SetPropertyInternal</span>(it, value, language_mode, store_mode, &amp;found);<br>    <span class="hljs-keyword">if</span> (found) <span class="hljs-keyword">return</span> result;<br>  &#125;<br><br>  <span class="hljs-comment">// If the receiver is the JSGlobalObject, the store was contextual. In case</span><br>  <span class="hljs-comment">// the property did not exist yet on the global object itself, we have to</span><br>  <span class="hljs-comment">// throw a reference error in strict mode.  In sloppy mode, we continue.</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">is_strict</span>(language_mode) &amp;&amp; it-&gt;<span class="hljs-built_in">GetReceiver</span>()-&gt;<span class="hljs-built_in">IsJSGlobalObject</span>()) &#123;<br>    it-&gt;<span class="hljs-built_in">isolate</span>()-&gt;<span class="hljs-built_in">Throw</span>(*it-&gt;<span class="hljs-built_in">isolate</span>()-&gt;<span class="hljs-built_in">factory</span>()-&gt;<span class="hljs-built_in">NewReferenceError</span>(<br>        MessageTemplate::kNotDefined, it-&gt;<span class="hljs-built_in">name</span>()));<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Nothing</span>&lt;<span class="hljs-type">bool</span>&gt;();<br>  &#125;<br><br>  ShouldThrow should_throw =<br>      <span class="hljs-built_in">is_sloppy</span>(language_mode) ? kDontThrow : kThrowOnError;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">AddDataProperty</span>(it, value, NONE, should_throw, store_mode);<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="SetPropertyInternal"><a href="#SetPropertyInternal" class="headerlink" title="SetPropertyInternal"></a>SetPropertyInternal</h3><p>如果属性存在对象里则调用SetPropertyInternal</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">Maybe&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">Object::SetPropertyInternal</span><span class="hljs-params">(LookupIterator* it,</span></span><br><span class="hljs-params"><span class="hljs-function">                                        Handle&lt;Object&gt; value,</span></span><br><span class="hljs-params"><span class="hljs-function">                                        LanguageMode language_mode,</span></span><br><span class="hljs-params"><span class="hljs-function">                                        StoreFromKeyed store_mode,</span></span><br><span class="hljs-params"><span class="hljs-function">                                        <span class="hljs-type">bool</span>* found)</span> </span>&#123;<br>  it-&gt;<span class="hljs-built_in">UpdateProtector</span>();<br>  <span class="hljs-built_in">DCHECK</span>(it-&gt;<span class="hljs-built_in">IsFound</span>());<br>  ShouldThrow should_throw =<br>      <span class="hljs-built_in">is_sloppy</span>(language_mode) ? kDontThrow : kThrowOnError;<br><br>  <span class="hljs-comment">// Make sure that the top context does not change when doing callbacks or</span><br>  <span class="hljs-comment">// interceptor calls.</span><br>  <span class="hljs-function">AssertNoContextChange <span class="hljs-title">ncc</span><span class="hljs-params">(it-&gt;isolate())</span></span>;<br><br>  <span class="hljs-keyword">do</span> &#123;<br>    <span class="hljs-keyword">switch</span> (it-&gt;<span class="hljs-built_in">state</span>()) &#123;<br>      <span class="hljs-keyword">case</span> LookupIterator::NOT_FOUND:<br>        <span class="hljs-built_in">UNREACHABLE</span>();<br><br>      <span class="hljs-keyword">case</span> LookupIterator::ACCESS_CHECK:<br>        <span class="hljs-keyword">if</span> (it-&gt;<span class="hljs-built_in">HasAccess</span>()) <span class="hljs-keyword">break</span>;<br>        <span class="hljs-comment">// Check whether it makes sense to reuse the lookup iterator. Here it</span><br>        <span class="hljs-comment">// might still call into setters up the prototype chain.</span><br>        <span class="hljs-keyword">return</span> JSObject::<span class="hljs-built_in">SetPropertyWithFailedAccessCheck</span>(it, value,<br>                                                          should_throw);<br><br>      <span class="hljs-keyword">case</span> LookupIterator::JSPROXY:<br>        <span class="hljs-keyword">return</span> JSProxy::<span class="hljs-built_in">SetProperty</span>(it-&gt;<span class="hljs-built_in">GetHolder</span>&lt;JSProxy&gt;(), it-&gt;<span class="hljs-built_in">GetName</span>(),<br>                                    value, it-&gt;<span class="hljs-built_in">GetReceiver</span>(), language_mode);<br><br>      <span class="hljs-keyword">case</span> LookupIterator::INTERCEPTOR: &#123;<br>        <span class="hljs-keyword">if</span> (it-&gt;<span class="hljs-built_in">HolderIsReceiverOrHiddenPrototype</span>()) &#123;<br>          Maybe&lt;<span class="hljs-type">bool</span>&gt; result =<br>              JSObject::<span class="hljs-built_in">SetPropertyWithInterceptor</span>(it, should_throw, value);<br>          <span class="hljs-keyword">if</span> (result.<span class="hljs-built_in">IsNothing</span>() || result.<span class="hljs-built_in">FromJust</span>()) <span class="hljs-keyword">return</span> result;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>          Maybe&lt;PropertyAttributes&gt; maybe_attributes =<br>              JSObject::<span class="hljs-built_in">GetPropertyAttributesWithInterceptor</span>(it);<br>          <span class="hljs-keyword">if</span> (maybe_attributes.<span class="hljs-built_in">IsNothing</span>()) <span class="hljs-keyword">return</span> <span class="hljs-built_in">Nothing</span>&lt;<span class="hljs-type">bool</span>&gt;();<br>          <span class="hljs-keyword">if</span> ((maybe_attributes.<span class="hljs-built_in">FromJust</span>() &amp; READ_ONLY) != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">WriteToReadOnlyProperty</span>(it, value, should_throw);<br>          &#125;<br>          <span class="hljs-keyword">if</span> (maybe_attributes.<span class="hljs-built_in">FromJust</span>() == ABSENT) <span class="hljs-keyword">break</span>;<br>          *found = <span class="hljs-literal">false</span>;<br>          <span class="hljs-keyword">return</span> <span class="hljs-built_in">Nothing</span>&lt;<span class="hljs-type">bool</span>&gt;();<br>        &#125;<br>        <span class="hljs-keyword">break</span>;<br>      &#125;<br><br>      <span class="hljs-keyword">case</span> LookupIterator::ACCESSOR: &#123;<br>        <span class="hljs-keyword">if</span> (it-&gt;<span class="hljs-built_in">IsReadOnly</span>()) &#123;<br>          <span class="hljs-keyword">return</span> <span class="hljs-built_in">WriteToReadOnlyProperty</span>(it, value, should_throw);<br>        &#125;<br>        Handle&lt;Object&gt; accessors = it-&gt;<span class="hljs-built_in">GetAccessors</span>();<br>        <span class="hljs-keyword">if</span> (accessors-&gt;<span class="hljs-built_in">IsAccessorInfo</span>() &amp;&amp;<br>            !it-&gt;<span class="hljs-built_in">HolderIsReceiverOrHiddenPrototype</span>() &amp;&amp;<br>            AccessorInfo::<span class="hljs-built_in">cast</span>(*accessors)-&gt;<span class="hljs-built_in">is_special_data_property</span>()) &#123;<br>          *found = <span class="hljs-literal">false</span>;<br>          <span class="hljs-keyword">return</span> <span class="hljs-built_in">Nothing</span>&lt;<span class="hljs-type">bool</span>&gt;();<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">SetPropertyWithAccessor</span>(it, value, should_throw);<br>      &#125;<br>      <span class="hljs-keyword">case</span> LookupIterator::INTEGER_INDEXED_EXOTIC:<br>        <span class="hljs-comment">// TODO(verwaest): We should throw an exception if holder is receiver.</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Just</span>(<span class="hljs-literal">true</span>);<br><br>      <span class="hljs-keyword">case</span> LookupIterator::DATA:<br>        <span class="hljs-keyword">if</span> (it-&gt;<span class="hljs-built_in">IsReadOnly</span>()) &#123;<br>          <span class="hljs-keyword">return</span> <span class="hljs-built_in">WriteToReadOnlyProperty</span>(it, value, should_throw);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (it-&gt;<span class="hljs-built_in">HolderIsReceiverOrHiddenPrototype</span>()) &#123;<br>          <span class="hljs-keyword">return</span> <span class="hljs-built_in">SetDataProperty</span>(it, value);<br>        &#125;<br>      <span class="hljs-comment">// Fall through.</span><br>      <span class="hljs-keyword">case</span> LookupIterator::TRANSITION:<br>        *found = <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Nothing</span>&lt;<span class="hljs-type">bool</span>&gt;();<br>    &#125;<br>    it-&gt;<span class="hljs-built_in">Next</span>();<br>  &#125; <span class="hljs-keyword">while</span> (it-&gt;<span class="hljs-built_in">IsFound</span>());<br><br>  *found = <span class="hljs-literal">false</span>;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">Nothing</span>&lt;<span class="hljs-type">bool</span>&gt;();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Object-AddDataProperty"><a href="#Object-AddDataProperty" class="headerlink" title="Object::AddDataProperty"></a>Object::AddDataProperty</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">Maybe&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">Object::AddDataProperty</span><span class="hljs-params">(LookupIterator* it, Handle&lt;Object&gt; value,</span></span><br><span class="hljs-params"><span class="hljs-function">                                    PropertyAttributes attributes,</span></span><br><span class="hljs-params"><span class="hljs-function">                                    ShouldThrow should_throw,</span></span><br><span class="hljs-params"><span class="hljs-function">                                    StoreFromKeyed store_mode)</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (!it-&gt;<span class="hljs-built_in">GetReceiver</span>()-&gt;<span class="hljs-built_in">IsJSObject</span>()) &#123;<br>    <span class="hljs-keyword">if</span> (it-&gt;<span class="hljs-built_in">GetReceiver</span>()-&gt;<span class="hljs-built_in">IsJSProxy</span>() &amp;&amp; it-&gt;<span class="hljs-built_in">GetName</span>()-&gt;<span class="hljs-built_in">IsPrivate</span>()) &#123;<br>      <span class="hljs-built_in">RETURN_FAILURE</span>(it-&gt;<span class="hljs-built_in">isolate</span>(), should_throw,<br>                     <span class="hljs-built_in">NewTypeError</span>(MessageTemplate::kProxyPrivate));<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">CannotCreateProperty</span>(it-&gt;<span class="hljs-built_in">isolate</span>(), it-&gt;<span class="hljs-built_in">GetReceiver</span>(), it-&gt;<span class="hljs-built_in">GetName</span>(),<br>                                value, should_throw);<br>  &#125;<br><br>  <span class="hljs-built_in">DCHECK_NE</span>(LookupIterator::INTEGER_INDEXED_EXOTIC, it-&gt;<span class="hljs-built_in">state</span>());<br><br>  Handle&lt;JSObject&gt; receiver = it-&gt;<span class="hljs-built_in">GetStoreTarget</span>();<br><br>  <span class="hljs-comment">// If the receiver is a JSGlobalProxy, store on the prototype (JSGlobalObject)</span><br>  <span class="hljs-comment">// instead. If the prototype is Null, the proxy is detached.</span><br>  <span class="hljs-keyword">if</span> (receiver-&gt;<span class="hljs-built_in">IsJSGlobalProxy</span>()) <span class="hljs-keyword">return</span> <span class="hljs-built_in">Just</span>(<span class="hljs-literal">true</span>);<br><br>  Isolate* isolate = it-&gt;<span class="hljs-built_in">isolate</span>();<br><br>  <span class="hljs-keyword">if</span> (it-&gt;<span class="hljs-built_in">ExtendingNonExtensible</span>(receiver)) &#123;<br>    <span class="hljs-built_in">RETURN_FAILURE</span>(<br>        isolate, should_throw,<br>        <span class="hljs-built_in">NewTypeError</span>(MessageTemplate::kObjectNotExtensible, it-&gt;<span class="hljs-built_in">GetName</span>()));<br>  &#125;<br><br>  <span class="hljs-keyword">if</span> (it-&gt;<span class="hljs-built_in">IsElement</span>()) &#123;<br>    <span class="hljs-keyword">if</span> (receiver-&gt;<span class="hljs-built_in">IsJSArray</span>()) &#123;<br>      Handle&lt;JSArray&gt; array = Handle&lt;JSArray&gt;::<span class="hljs-built_in">cast</span>(receiver);<br>      <span class="hljs-keyword">if</span> (JSArray::<span class="hljs-built_in">WouldChangeReadOnlyLength</span>(array, it-&gt;<span class="hljs-built_in">index</span>())) &#123;<br>        <span class="hljs-built_in">RETURN_FAILURE</span>(array-&gt;<span class="hljs-built_in">GetIsolate</span>(), should_throw,<br>                       <span class="hljs-built_in">NewTypeError</span>(MessageTemplate::kStrictReadOnlyProperty,<br>                                    isolate-&gt;<span class="hljs-built_in">factory</span>()-&gt;<span class="hljs-built_in">length_string</span>(),<br>                                    Object::<span class="hljs-built_in">TypeOf</span>(isolate, array), array));<br>      &#125;<br><br>      <span class="hljs-keyword">if</span> (FLAG_trace_external_array_abuse &amp;&amp;<br>          array-&gt;<span class="hljs-built_in">HasFixedTypedArrayElements</span>()) &#123;<br>        <span class="hljs-built_in">CheckArrayAbuse</span>(array, <span class="hljs-string">&quot;typed elements write&quot;</span>, it-&gt;<span class="hljs-built_in">index</span>(), <span class="hljs-literal">true</span>);<br>      &#125;<br><br>      <span class="hljs-keyword">if</span> (FLAG_trace_js_array_abuse &amp;&amp; !array-&gt;<span class="hljs-built_in">HasFixedTypedArrayElements</span>()) &#123;<br>        <span class="hljs-built_in">CheckArrayAbuse</span>(array, <span class="hljs-string">&quot;elements write&quot;</span>, it-&gt;<span class="hljs-built_in">index</span>(), <span class="hljs-literal">false</span>);<br>      &#125;<br>    &#125;<br><br>    Maybe&lt;<span class="hljs-type">bool</span>&gt; result = JSObject::<span class="hljs-built_in">AddDataElement</span>(receiver, it-&gt;<span class="hljs-built_in">index</span>(), value,<br>                                                  attributes, should_throw);<br>    JSObject::<span class="hljs-built_in">ValidateElements</span>(*receiver);<br>    <span class="hljs-keyword">return</span> result;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    it-&gt;<span class="hljs-built_in">UpdateProtector</span>();<br>    <span class="hljs-comment">// Migrate to the most up-to-date map that will be able to store |value|</span><br>    <span class="hljs-comment">// under it-&gt;name() with |attributes|.</span><br>    it-&gt;<span class="hljs-built_in">PrepareTransitionToDataProperty</span>(receiver, value, attributes,<br>                                        store_mode);<br>    <span class="hljs-built_in">DCHECK_EQ</span>(LookupIterator::TRANSITION, it-&gt;<span class="hljs-built_in">state</span>());<br>    it-&gt;<span class="hljs-built_in">ApplyTransitionToDataProperty</span>(receiver);<br><br>    <span class="hljs-comment">// Write the property value.</span><br>    it-&gt;<span class="hljs-built_in">WriteDataValue</span>(value, <span class="hljs-literal">true</span>);<br><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> VERIFY_HEAP</span><br>    <span class="hljs-keyword">if</span> (FLAG_verify_heap) &#123;<br>      receiver-&gt;<span class="hljs-built_in">JSObjectVerify</span>();<br>    &#125;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>  &#125;<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">Just</span>(<span class="hljs-literal">true</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="最后调用"><a href="#最后调用" class="headerlink" title="最后调用"></a>最后调用</h3><p>LookupIterator::UpdateProtector-&gt;LookupIterator::PrepareTransitionToDataProperty-&gt;LookupIterator::WriteDataValue</p><p>同步知乎：<a href="https://zhuanlan.zhihu.com/p/80112470">https://zhuanlan.zhihu.com/p/80112470</a></p>]]></content>
    
    
    <categories>
      
      <category>V8</category>
      
    </categories>
    
    
    <tags>
      
      <tag>字节码</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>NG Block Layout</title>
    <link href="/2022/05/04/NG-Block-Layout/"/>
    <url>/2022/05/04/NG-Block-Layout/</url>
    
    <content type="html"><![CDATA[<p>本文讲述的是Block Layout算法（基于InFlow），BlockLayout算法本质上就是计算盒子模型的各个参数值。</p><p>排版函数入口是LayoutNGMixin&lt;Base&gt;::UpdateInFlowBlockLayout() ，然后调用到NGBlockNode的Layout函数。</p><p>NGBlockNode的输入和输出如下：</p><table><thead><tr><th align="center">输入</th><th align="center">输出</th></tr></thead><tbody><tr><td align="center">LayoutNGBlockFlow</td><td align="center">NGLayoutResult</td></tr></tbody></table><p>Block排版算法主要有以下阶段：</p><p>1.Create NGConstraintSpace 计算次节点的约束空间<br>2.Get Cached LayoutResult 是否已经有排版结果<br>3.CalculateInitialFragmentGeometry 计算Fragment几何信息<br>4.LayoutWithAlgorithm 根据不同的display类型调用不同的排版算法<br>5.Set Cached LayoutResult 设置排版结果<br>6.CopyFragmentDataToLayoutBox 设置排版信息到box</p><h3 id="第一阶段：Create-NGConstraintSpace-计算约束空间"><a href="#第一阶段：Create-NGConstraintSpace-计算约束空间" class="headerlink" title="第一阶段：Create NGConstraintSpace 计算约束空间"></a>第一阶段：Create NGConstraintSpace 计算约束空间</h3><p>计算约束空间的触发函数：NGConstraintSpace::CreateFromLayoutObject 和 NGBlockLayoutAlgorithm::CreateConstraintSpaceForChild</p><p>1.获取ContainingBlock计算可用的宽度<br>2.获取ContainingBlock计算可用的高度<br>3.通过 NGConstraintSpaceBuilder 生成NGConstraintSpace</p><figure class="highlight c++"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></div></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">NGConstraintSpace <span class="hljs-title">NGConstraintSpace::CreateFromLayoutObject</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-type">const</span> LayoutBlock&amp; block)</span> </span>&#123;<br>  <span class="hljs-comment">// We should only ever create a constraint space from legacy layout if the</span><br>  <span class="hljs-comment">// object is a new formatting context.</span><br>  <span class="hljs-built_in">DCHECK</span>(block.<span class="hljs-built_in">CreatesNewFormattingContext</span>());<br> <br>  <span class="hljs-type">const</span> LayoutBlock* cb = block.<span class="hljs-built_in">ContainingBlock</span>();<br>  LayoutUnit available_logical_width =<br>      LayoutBoxUtils::<span class="hljs-built_in">AvailableLogicalWidth</span>(block, cb); <span class="hljs-comment">// 计算可用宽度</span><br>  LayoutUnit available_logical_height =<br>      LayoutBoxUtils::<span class="hljs-built_in">AvailableLogicalHeight</span>(block, cb); <span class="hljs-comment">// 计算可用高度</span><br>  LogicalSize percentage_size = &#123;available_logical_width,<br>                                 available_logical_height&#125;;<br>  LogicalSize available_size = percentage_size;<br> <br>......<br> <br>  <span class="hljs-type">const</span> ComputedStyle&amp; style = block.<span class="hljs-built_in">StyleRef</span>();<br>  <span class="hljs-keyword">auto</span> writing_mode = style.<span class="hljs-built_in">GetWritingMode</span>();<br>  <span class="hljs-type">bool</span> parallel_containing_block = <span class="hljs-built_in">IsParallelWritingMode</span>(<br>      cb ? cb-&gt;<span class="hljs-built_in">StyleRef</span>().<span class="hljs-built_in">GetWritingMode</span>() : writing_mode, writing_mode);<br>  <span class="hljs-function">NGConstraintSpaceBuilder <span class="hljs-title">builder</span><span class="hljs-params">(writing_mode, writing_mode,</span></span><br><span class="hljs-params"><span class="hljs-function">                                   <span class="hljs-comment">/* is_new_fc */</span> <span class="hljs-literal">true</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">                                   !parallel_containing_block)</span></span>;<br>......<br> <br>  builder.<span class="hljs-built_in">SetAvailableSize</span>(available_size); <span class="hljs-comment">// 设置可用size</span><br>  builder.<span class="hljs-built_in">SetPercentageResolutionSize</span>(percentage_size);<br>  builder.<span class="hljs-built_in">SetIsFixedInlineSize</span>(fixed_inline);<br>  builder.<span class="hljs-built_in">SetIsFixedBlockSize</span>(fixed_block);<br>  builder.<span class="hljs-built_in">SetIsFixedBlockSizeIndefinite</span>(!fixed_block_is_definite);<br>  builder.<span class="hljs-built_in">SetIsShrinkToFit</span>(<br>      style.<span class="hljs-built_in">LogicalWidth</span>().<span class="hljs-built_in">IsAuto</span>() &amp;&amp;<br>      block.<span class="hljs-built_in">SizesLogicalWidthToFitContent</span>(style.<span class="hljs-built_in">LogicalWidth</span>()));<br>  builder.<span class="hljs-built_in">SetTextDirection</span>(style.<span class="hljs-built_in">Direction</span>());<br>  <span class="hljs-keyword">return</span> builder.<span class="hljs-built_in">ToConstraintSpace</span>(); <span class="hljs-comment">// 生成ConstraintSpace</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="第二阶段：Get-Cached-LayoutResult-是否已经有排版结果"><a href="#第二阶段：Get-Cached-LayoutResult-是否已经有排版结果" class="headerlink" title="第二阶段：Get Cached LayoutResult 是否已经有排版结果"></a>第二阶段：Get Cached LayoutResult 是否已经有排版结果</h3><p>通过CachedLayoutResult是否有排版结果，有结果则不需重新排版</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++">  NGLayoutCacheStatus cache_status;<br>  base::Optional&lt;NGFragmentGeometry&gt; fragment_geometry;<br>  scoped_refptr&lt;<span class="hljs-type">const</span> NGLayoutResult&gt; layout_result =<br>      box_-&gt;<span class="hljs-built_in">CachedLayoutResult</span>(constraint_space, break_token, early_break,<br>                               &amp;fragment_geometry, &amp;cache_status); <span class="hljs-comment">// 获取NGLayoutResult</span><br>  <span class="hljs-keyword">if</span> (cache_status == NGLayoutCacheStatus::kHit) &#123;  <span class="hljs-comment">// cache的状态判断</span><br>    <span class="hljs-built_in">DCHECK</span>(layout_result);<br> <br>......<br> <br>    <span class="hljs-keyword">if</span> (!box_-&gt;<span class="hljs-built_in">NeedsLayout</span>()) <span class="hljs-comment">// 是否需要排版，不需要则直接返回结果</span><br>      <span class="hljs-keyword">return</span> layout_result;<br>  &#125;<br></code></pre></td></tr></table></figure><h3 id="第三阶段：CalculateInitialFragmentGeometry-计算Box的盒子信息"><a href="#第三阶段：CalculateInitialFragmentGeometry-计算Box的盒子信息" class="headerlink" title="第三阶段：CalculateInitialFragmentGeometry 计算Box的盒子信息"></a>第三阶段：CalculateInitialFragmentGeometry 计算Box的盒子信息</h3><p>根据style和NGConstraintSpace计算出默认的盒子模型信息（宽度，高度，内边距，外边距等），触发函数是CalculateInitialFragmentGeometry</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">NGFragmentGeometry <span class="hljs-title">CalculateInitialFragmentGeometry</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-type">const</span> NGConstraintSpace&amp; constraint_space,</span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-type">const</span> NGBlockNode&amp; node)</span> </span>&#123;<br>  <span class="hljs-type">const</span> ComputedStyle&amp; style = node.<span class="hljs-built_in">Style</span>();<br> <br>  NGBoxStrut border = <span class="hljs-built_in">ComputeBorders</span>(constraint_space, node); <span class="hljs-comment">// 计算边框</span><br>  NGBoxStrut padding = <span class="hljs-built_in">ComputePadding</span>(constraint_space, style); <span class="hljs-comment">// 计算内边距</span><br>  NGBoxStrut scrollbar = <span class="hljs-built_in">ComputeScrollbars</span>(constraint_space, node); <span class="hljs-comment">// 计算滚动条区域</span><br>  NGBoxStrut border_padding = border + padding;<br>  NGBoxStrut border_scrollbar_padding = border_padding + scrollbar;<br> <br>......<br> <br>  LayoutUnit default_block_size = <span class="hljs-built_in">CalculateDefaultBlockSize</span>(<br>      constraint_space, node, border_scrollbar_padding); <span class="hljs-comment">// 计算默认的高度（注意这里用block表示就是高度）</span><br>  LayoutUnit inline_size =<br>      <span class="hljs-built_in">ComputeInlineSizeForFragment</span>(constraint_space, node, border_padding); <span class="hljs-comment">// 计算宽度</span><br> <br>  <span class="hljs-function">LogicalSize <span class="hljs-title">border_box_size</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">      inline_size,</span></span><br><span class="hljs-params"><span class="hljs-function">      ComputeBlockSizeForFragment(constraint_space, style, border_padding,</span></span><br><span class="hljs-params"><span class="hljs-function">                                  default_block_size, inline_size))</span></span>;<br> <br>  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">UNLIKELY</span>(border_box_size.inline_size &lt;<br>                   border_scrollbar_padding.<span class="hljs-built_in">InlineSum</span>() &amp;&amp;<br>               scrollbar.<span class="hljs-built_in">InlineSum</span>() &amp;&amp; !constraint_space.<span class="hljs-built_in">IsAnonymous</span>())) &#123;<br>    <span class="hljs-built_in">ClampScrollbarToContentBox</span>(<br>        &amp;scrollbar, border_box_size.inline_size - border_padding.<span class="hljs-built_in">InlineSum</span>());<br>  &#125;<br> <br>  <span class="hljs-keyword">return</span> &#123;border_box_size, border, scrollbar, padding&#125;; <span class="hljs-comment">// 返回计算的结果</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="第四阶段：LayoutWithAlgorithm-根据不同的display类型调用不同的排版算法"><a href="#第四阶段：LayoutWithAlgorithm-根据不同的display类型调用不同的排版算法" class="headerlink" title="第四阶段：LayoutWithAlgorithm 根据不同的display类型调用不同的排版算法"></a>第四阶段：LayoutWithAlgorithm 根据不同的display类型调用不同的排版算法</h3><p>根据display样式生成不同的LayoutAlgorithm，这里也是NG排版的精髓，方便后续新的标准实现不一样的算法。下表格就是现有display对应创建不同的算法。</p><table><thead><tr><th align="center">Display</th><th align="center">LayoutAlgorithm</th></tr></thead><tbody><tr><td align="center">Block</td><td align="center">NGBlockLayoutAlgorithm</td></tr><tr><td align="center">Fieldset</td><td align="center">NGFieldsetLayoutAlgorithm</td></tr><tr><td align="center">Flex</td><td align="center">NGFlexLayoutAlgorithm</td></tr><tr><td align="center">FlowThread</td><td align="center">NGColumnLayoutAlgorithm NGPageLayoutAlgorithm</td></tr><tr><td align="center">Grid</td><td align="center">NGGridLayoutAlgorithm</td></tr><tr><td align="center">Inline</td><td align="center">NGInlineLayoutAlgorithm</td></tr><tr><td align="center">MathML</td><td align="center">比较复杂，不同的元素生成不同的LayoutAlgorithm</td></tr><tr><td align="center">这个阶段会递归的调用子节点进行排版。可以看如下代码：</td><td align="center"></td></tr></tbody></table><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">inline</span> scoped_refptr&lt;<span class="hljs-type">const</span> NGLayoutResult&gt; <span class="hljs-title">NGBlockLayoutAlgorithm::Layout</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">    NGInlineChildLayoutContext* inline_child_layout_context)</span> </span>&#123;<br>......<br>  scoped_refptr&lt;<span class="hljs-type">const</span> NGInlineBreakToken&gt; previous_inline_break_token;<br> <br>  <span class="hljs-function">NGBlockChildIterator <span class="hljs-title">child_iterator</span><span class="hljs-params">(Node().FirstChild(), BreakToken())</span></span>;<br> <br>  <span class="hljs-comment">// If this layout is blocked by a display-lock, then we pretend this node has</span><br>  <span class="hljs-comment">// no children and that there are no break tokens. Due to this, we skip layout</span><br>  <span class="hljs-comment">// on these children.</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Node</span>().<span class="hljs-built_in">ChildLayoutBlockedByDisplayLock</span>())<br>    child_iterator = <span class="hljs-built_in">NGBlockChildIterator</span>(<span class="hljs-built_in">NGBlockNode</span>(<span class="hljs-literal">nullptr</span>), <span class="hljs-literal">nullptr</span>);<br> <br>  <span class="hljs-function">NGLayoutInputNode <span class="hljs-title">ruby_text_child</span><span class="hljs-params">(<span class="hljs-literal">nullptr</span>)</span></span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> entry = child_iterator.<span class="hljs-built_in">NextChild</span>();<br>       NGLayoutInputNode child = entry.node;<br>       entry = child_iterator.<span class="hljs-built_in">NextChild</span>(previous_inline_break_token.<span class="hljs-built_in">get</span>())) &#123;  <span class="hljs-comment">// 遍历子节点</span><br>    <span class="hljs-type">const</span> NGBreakToken* child_break_token = entry.token;<br>......<br>        status = <span class="hljs-built_in">HandleInflow</span>(<br>            child, child_break_token, &amp;previous_inflow_position,<br>            inline_child_layout_context, &amp;previous_inline_break_token); <span class="hljs-comment">// 处理子节点的排版，最终还是会调用到NGBlockNode.Layout</span><br>......<br>    &#125;<br>  &#125;<br> <br>......<br> <br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">FinishLayout</span>(&amp;previous_inflow_position, inline_child_layout_context);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="第五阶段：Set-Cached-LayoutResult-设置排版结果到LayoutBox上"><a href="#第五阶段：Set-Cached-LayoutResult-设置排版结果到LayoutBox上" class="headerlink" title="第五阶段：Set Cached LayoutResult 设置排版结果到LayoutBox上"></a>第五阶段：Set Cached LayoutResult 设置排版结果到LayoutBox上</h3><p>设置LayoutResult到LayoutBox</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">NGBlockNode::FinishLayout</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">    LayoutBlockFlow* block_flow,</span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-type">const</span> NGConstraintSpace&amp; constraint_space,</span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-type">const</span> NGBlockBreakToken* break_token,</span></span><br><span class="hljs-params"><span class="hljs-function">    scoped_refptr&lt;<span class="hljs-type">const</span> NGLayoutResult&gt; layout_result)</span> <span class="hljs-type">const</span> </span>&#123;<br>......<br> <br>  <span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; physical_fragment =<br>      <span class="hljs-built_in">To</span>&lt;NGPhysicalBoxFragment&gt;(layout_result-&gt;<span class="hljs-built_in">PhysicalFragment</span>());<br> <br>  <span class="hljs-keyword">if</span> (layout_result-&gt;<span class="hljs-built_in">IsSingleUse</span>())<br>    box_-&gt;<span class="hljs-built_in">AddLayoutResult</span>(layout_result, <span class="hljs-built_in">FragmentIndex</span>(break_token));<br>  <span class="hljs-keyword">else</span><br>    box_-&gt;<span class="hljs-built_in">SetCachedLayoutResult</span>(layout_result); <span class="hljs-comment">// 设置结果</span><br> <br>.....<br>  <span class="hljs-built_in">CopyFragmentDataToLayoutBox</span>(constraint_space, *layout_result, break_token); <span class="hljs-comment">// copy部分片段信息到LayoutBox</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="第六阶段：CopyFragmentDataToLayoutBox-设置排版信息到LayoutBox上"><a href="#第六阶段：CopyFragmentDataToLayoutBox-设置排版信息到LayoutBox上" class="headerlink" title="第六阶段：CopyFragmentDataToLayoutBox 设置排版信息到LayoutBox上"></a>第六阶段：CopyFragmentDataToLayoutBox 设置排版信息到LayoutBox上</h3><p>设置LayoutBox的信息：</p><p>1.设置box的宽高<br>2.设置整个内容高度（减去-边框和内边距）<br>3.设置外边距离大小</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">NGBlockNode::CopyFragmentDataToLayoutBox</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-type">const</span> NGConstraintSpace&amp; constraint_space,</span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-type">const</span> NGLayoutResult&amp; layout_result,</span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-type">const</span> NGBlockBreakToken* previous_break_token)</span> <span class="hljs-type">const</span> </span>&#123;<br>  <span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; physical_fragment =<br>      <span class="hljs-built_in">To</span>&lt;NGPhysicalBoxFragment&gt;(layout_result.<span class="hljs-built_in">PhysicalFragment</span>());<br> <br>  <span class="hljs-function">NGBoxFragment <span class="hljs-title">fragment</span><span class="hljs-params">(constraint_space.GetWritingMode(),</span></span><br><span class="hljs-params"><span class="hljs-function">                         constraint_space.Direction(), physical_fragment)</span></span>;<br>  LogicalSize fragment_logical_size = fragment.<span class="hljs-built_in">Size</span>();<br>  NGBoxStrut borders = fragment.<span class="hljs-built_in">Borders</span>(); <span class="hljs-comment">// 获取边框大小</span><br>  NGBoxStrut scrollbars = <span class="hljs-built_in">ComputeScrollbars</span>(constraint_space, *<span class="hljs-keyword">this</span>); <span class="hljs-comment">// 获取滚动区域大小</span><br>  NGBoxStrut padding = fragment.<span class="hljs-built_in">Padding</span>(); <span class="hljs-comment">// 获取内边距大小</span><br>  NGBoxStrut border_scrollbar_padding = borders + scrollbars + padding;<br>  <span class="hljs-type">bool</span> is_last_fragment = !physical_fragment.<span class="hljs-built_in">BreakToken</span>();<br> <br>......<br> <br>  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">LIKELY</span>(physical_fragment.<span class="hljs-built_in">IsFirstForNode</span>())) &#123;<br>    box_-&gt;<span class="hljs-built_in">SetSize</span>(<span class="hljs-built_in">LayoutSize</span>(physical_fragment.<span class="hljs-built_in">Size</span>().width,<br>                             physical_fragment.<span class="hljs-built_in">Size</span>().height)); <span class="hljs-comment">// 设置宽高，这样一个块的大小就已经确认了</span><br>......<br> <br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">LIKELY</span>(is_last_fragment &amp;&amp; !constraint_space.<span class="hljs-built_in">IsFixedBlockSize</span>())) &#123;<br>      box_-&gt;<span class="hljs-built_in">SetIntrinsicContentLogicalHeight</span>(<br>          layout_result.<span class="hljs-built_in">IntrinsicBlockSize</span>() -<br>          border_scrollbar_padding.<span class="hljs-built_in">BlockSum</span>());  <span class="hljs-comment">// 设置内容高度</span><br>    &#125;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>......<br>    box_-&gt;<span class="hljs-built_in">SetLogicalHeight</span>(logical_height);<br>  &#125;<br> <br>......<br> <br>  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">UNLIKELY</span>(box_-&gt;<span class="hljs-built_in">IsTableCell</span>())) &#123;<br>    <span class="hljs-comment">// Table-cell margins compute to zero.</span><br>    box_-&gt;<span class="hljs-built_in">SetMargin</span>(<span class="hljs-built_in">NGPhysicalBoxStrut</span>());<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    box_-&gt;<span class="hljs-built_in">SetMargin</span>(<span class="hljs-built_in">ComputePhysicalMargins</span>(constraint_space, <span class="hljs-built_in">Style</span>())); <span class="hljs-comment">// 设置外边距大小</span><br>  &#125;<br> <br>  <span class="hljs-keyword">auto</span>* block_flow = <span class="hljs-built_in">DynamicTo</span>&lt;LayoutBlockFlow&gt;(box_);<br>......<br>&#125;<br></code></pre></td></tr></table></figure><p>到此一个盒子模型的排版信息就计算出来了</p><p>同步知乎：<a href="https://zhuanlan.zhihu.com/p/370632812">https://zhuanlan.zhihu.com/p/370632812</a></p>]]></content>
    
    
    <categories>
      
      <category>Chromium</category>
      
    </categories>
    
    
    <tags>
      
      <tag>NG</tag>
      
      <tag>Layout</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>NG Inline Layout</title>
    <link href="/2022/05/04/NG-Inline-Layout/"/>
    <url>/2022/05/04/NG-Inline-Layout/</url>
    
    <content type="html"><![CDATA[<p>本文主要讲解NG Inline排版流程和算法</p><h2 id="一-树之间的转换关系"><a href="#一-树之间的转换关系" class="headerlink" title="一. 树之间的转换关系"></a>一. 树之间的转换关系</h2><p>首先我们看下从Dom Tree转换成Fragment Tree的对应关系，排版结果就是一颗Fragment Tree（片段树）<br><img src="/2022/05/04/NG-Inline-Layout/1.jpg"><br>上面对应关系可以看出：</p><p>1.LayoutNGBlockFlow (div) → NGBlockNode (div)<br>2.NGBlockNode的第一个子节点是 NGInlineNode （div）<br>3.Inline节点上有开闭节点的概念<br>4.每一行生成NGPhysicalLineBoxFragment（行片段）<br>5每一个文本片段生成一个NGPhysicalTextFragment （文本片段）</p><h2 id="二-排版算法阶段"><a href="#二-排版算法阶段" class="headerlink" title="二. 排版算法阶段"></a>二. 排版算法阶段</h2><p>Ng Inline排版分为四个阶段：</p><p>1.Pre-Layout 预处理排版阶段：主要是把节点下的所有文本组合起来和生成一系列的NGInlineItem列表<br>2.Line Breaking 分行，最终生成NGInlineItemResult<br>3.Line box construction 一行内容创建<br>4.Generate fragments生成 fragment的片段树</p><table><thead><tr><th align="center">阶段</th><th align="center">输入</th><th align="center">输出</th></tr></thead><tbody><tr><td align="center">Pre-layout</td><td align="center">LayoutObject</td><td align="center">NGInlineItem</td></tr><tr><td align="center">Line Breaking</td><td align="center">NGInlineItem</td><td align="center">NGInlineItemResult</td></tr><tr><td align="center">Line box construction</td><td align="center">NGInlineItemResult</td><td align="center">NGLogicalLineItem</td></tr><tr><td align="center">Generate fragments</td><td align="center">NGLogicalLineItem</td><td align="center">NGPhysicalFragment &#x2F; NGFragmentItem</td></tr></tbody></table><h3 id="1-Pre-Layout"><a href="#1-Pre-Layout" class="headerlink" title="1.Pre-Layout"></a>1.Pre-Layout</h3><p>这个主要是准备Inline布局的数据，触发函数是NGInlineNode::PrepareLayout()</p><figure class="highlight c++"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">NGInlineNode::PrepareLayout</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-comment">// Scan list of siblings collecting all in-flow non-atomic inlines. A single</span><br>  <span class="hljs-comment">// NGInlineNode represent a collection of adjacent non-atomic inlines.</span><br>  <span class="hljs-built_in">CollectInlines</span>();<br>  <span class="hljs-built_in">SegmentText</span>();<br>  <span class="hljs-built_in">ShapeText</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>CollectInlines：</p><p>深度遍历NGInline节点，收集所有文本节点和其他非文本节点，然后输入到NGInlineItemsBuilder类进行创建出一系列的NGInlineItem。类似如下的结构</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">NGInlineNode （<span class="hljs-keyword">div</span>）<br>  NGInlineItem (<span class="hljs-built_in">open</span> tag, strong)<br>  NGInlineItem (<span class="hljs-keyword">text</span>, “NG”)<br>  NGInlineItem (<span class="hljs-built_in">close</span> tag, strong)<br></code></pre></td></tr></table></figure><p>SegmentText：</p><p>分割文本排版，采用bidi文本排版算法</p><p>ShapeText：</p><p>对分割的文本进行整形</p><h3 id="2-Line-Breaking"><a href="#2-Line-Breaking" class="headerlink" title="2.Line Breaking"></a>2.Line Breaking</h3><p>NGLineBreaker 输入上步骤的NGInlineItem，然后会计算出多少行，以及为每一行创建一个NGInlineItemResult</p><h3 id="3-Line-Box-Construction"><a href="#3-Line-Box-Construction" class="headerlink" title="3.Line Box Construction"></a>3.Line Box Construction</h3><p>通过NGInlineLayoutAlgorithm::CreateLine()函数触发，上步骤生成的NGInlineItemResult通过处理会生成NGLogicalLineItem.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">NGInlineLayoutAlgorithm::CreateLine</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">    NGLineInfo* line_info,</span></span><br><span class="hljs-params"><span class="hljs-function">    NGExclusionSpace* exclusion_space,</span></span><br><span class="hljs-params"><span class="hljs-function">    RefPtr&lt;NGInlineBreakToken&gt; break_token)</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Node</span>().<span class="hljs-built_in">IsBidiEnabled</span>())<br>    <span class="hljs-built_in">BidiReorder</span>(&amp;line_info-&gt;<span class="hljs-built_in">Results</span>());<br> <br>  <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">PlaceItems</span>(line_info, *exclusion_space, break_token))<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br> <br>  <span class="hljs-comment">// If something has resolved our BFC offset we can place all of the</span><br>  <span class="hljs-comment">// unpositioned floats below the current line.</span><br>  <span class="hljs-keyword">if</span> (container_builder_.<span class="hljs-built_in">BfcOffset</span>()) &#123;<br>    NGBfcOffset origin_point =<br>        <span class="hljs-built_in">GetOriginPointForFloats</span>(<span class="hljs-built_in">ContainerBfcOffset</span>(), content_size_);<br>    <span class="hljs-built_in">PositionPendingFloats</span>(<span class="hljs-built_in">ConstraintSpace</span>(), origin_point.block_offset,<br>                          &amp;container_builder_, &amp;unpositioned_floats_,<br>                          exclusion_space);<br>  &#125;<br> <br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="4-Generate-Fragments"><a href="#4-Generate-Fragments" class="headerlink" title="4.Generate Fragments"></a>4.Generate Fragments</h3><p>所有的NGLogicalLineItems 被排序和定位后就会被转成fragment，转换方式如下：</p><p>NGLogicalLineItem 会产生一个NGFragmentItem, 然后添加到 NGFragmentItems中</p><p>到此NgInlineNode排版结束</p><p>同步知乎：<a href="https://zhuanlan.zhihu.com/p/370626837">https://zhuanlan.zhihu.com/p/370626837</a></p>]]></content>
    
    
    <categories>
      
      <category>Chromium</category>
      
    </categories>
    
    
    <tags>
      
      <tag>NG</tag>
      
      <tag>Layout</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>V8接口指南--创建快照SnapshotCreator</title>
    <link href="/2022/05/04/V8%E6%8E%A5%E5%8F%A3%E6%8C%87%E5%8D%97-%E5%88%9B%E5%BB%BA%E5%BF%AB%E7%85%A7SnapshotCreator/"/>
    <url>/2022/05/04/V8%E6%8E%A5%E5%8F%A3%E6%8C%87%E5%8D%97-%E5%88%9B%E5%BB%BA%E5%BF%AB%E7%85%A7SnapshotCreator/</url>
    
    <content type="html"><![CDATA[<p>如何创建自定义的快照？为了方便，v8提供SnapshotCreator类创建快照。</p><p>SnapshotCreator有两个构造函数，区别在于是否传isolate。</p><p>第一步：创建v8::SnapshotCreator snapshot_creator</p><p>第二步：获取隔离snapshot_creator.GetIsolate()</p><p>第三步：创建上下文v8::Context::New(isolate)</p><p>第四步：执行自己的js</p><p>第五步：设置默认的上下文到快照创建类中snapshot_creator.SetDefaultContext(context);</p><p>第六步：创建快照数据 snapshot_creator.CreateBlob(v8::SnapshotCreator::FunctionCodeHandling::kClear);</p><p>这样就生成了一个快照数据，返回的数据结构是StartupData，这个数据保存的就是数据和size。</p><p>创建快照的标准示例代码：（这个代码编译时候必须关闭snapchat功能的进行编译，不然执行的时候会报错，里面的原因就不细说了）</p><figure class="highlight c++"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></div></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">RunExtraCode</span><span class="hljs-params">(v8::Isolate* isolate, v8::Local&lt;v8::Context&gt; context,</span></span><br><span class="hljs-params"><span class="hljs-function">                  <span class="hljs-type">const</span> <span class="hljs-type">char</span>* utf8_source, <span class="hljs-type">const</span> <span class="hljs-type">char</span>* name)</span> </span>&#123;<br>  v8::<span class="hljs-function">Context::Scope <span class="hljs-title">context_scope</span><span class="hljs-params">(context)</span></span>;<br>  <span class="hljs-function">v8::TryCatch <span class="hljs-title">try_catch</span><span class="hljs-params">(isolate)</span></span>;<br>  v8::Local&lt;v8::String&gt; source_string;<br>  <span class="hljs-keyword">if</span> (!v8::String::<span class="hljs-built_in">NewFromUtf8</span>(isolate, utf8_source, v8::NewStringType::kNormal)<br>           .<span class="hljs-built_in">ToLocal</span>(&amp;source_string)) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  &#125;<br>  v8::Local&lt;v8::String&gt; resource_name =<br>      v8::String::<span class="hljs-built_in">NewFromUtf8</span>(isolate, name, v8::NewStringType::kNormal)<br>          .<span class="hljs-built_in">ToLocalChecked</span>();<br>  <span class="hljs-function">v8::ScriptOrigin <span class="hljs-title">origin</span><span class="hljs-params">(resource_name)</span></span>;<br>  v8::<span class="hljs-function">ScriptCompiler::Source <span class="hljs-title">source</span><span class="hljs-params">(source_string, origin)</span></span>;<br>  v8::Local&lt;v8::Script&gt; script;<br>  <span class="hljs-keyword">if</span> (!v8::ScriptCompiler::<span class="hljs-built_in">Compile</span>(context, &amp;source).<span class="hljs-built_in">ToLocal</span>(&amp;script))<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  <span class="hljs-keyword">if</span> (script-&gt;<span class="hljs-built_in">Run</span>(context).<span class="hljs-built_in">IsEmpty</span>()) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  <span class="hljs-built_in">CHECK</span>(!try_catch.<span class="hljs-built_in">HasCaught</span>());<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-function">v8::StartupData <span class="hljs-title">CreateSnapshotDataBlob</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* embedded_source = <span class="hljs-literal">nullptr</span>)</span> </span>&#123;<br>  v8::StartupData result = &#123;<span class="hljs-literal">nullptr</span>, <span class="hljs-number">0</span>&#125;;<br>  &#123;<br>    v8::SnapshotCreator snapshot_creator;<br>    v8::Isolate* isolate = snapshot_creator.<span class="hljs-built_in">GetIsolate</span>();<br>    &#123;<br>      <span class="hljs-function">v8::HandleScope <span class="hljs-title">scope</span><span class="hljs-params">(isolate)</span></span>;<br>      v8::Local&lt;v8::Context&gt; context = v8::Context::<span class="hljs-built_in">New</span>(isolate);<br>      <span class="hljs-keyword">if</span> (embedded_source != <span class="hljs-literal">nullptr</span> &amp;&amp;<br>          !<span class="hljs-built_in">RunExtraCode</span>(isolate, context, embedded_source, <span class="hljs-string">&quot;&lt;embedded&gt;&quot;</span>)) &#123;<br>        <span class="hljs-keyword">return</span> result;<br>      &#125;<br>      snapshot_creator.<span class="hljs-built_in">SetDefaultContext</span>(context);<br>    &#125;<br>    result = snapshot_creator.<span class="hljs-built_in">CreateBlob</span>(<br>        v8::SnapshotCreator::FunctionCodeHandling::kClear);<br>  &#125;<br>  <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果一个函数没有被调用，那么V8不会对它的定义部分进行解析，即preparser机制。如果该函数没有被解析，那么它就更不可能被编译，正好对应了另一个机制:lazy-compile。所以接下来如何生成预热的快照代码：（传入参数把上面生成的StartupData传入，预热代码的参数传入）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">v8::StartupData <span class="hljs-title">WarmUpSnapshotDataBlob</span><span class="hljs-params">(v8::StartupData cold_snapshot_blob,</span></span><br><span class="hljs-params"><span class="hljs-function">                                       <span class="hljs-type">const</span> <span class="hljs-type">char</span>* warmup_source)</span> </span>&#123;<br>  <span class="hljs-built_in">CHECK</span>(cold_snapshot_blob.raw_size &gt; <span class="hljs-number">0</span> &amp;&amp; cold_snapshot_blob.data != <span class="hljs-literal">nullptr</span>);<br>  <span class="hljs-built_in">CHECK_NOT_NULL</span>(warmup_source);<br>  <span class="hljs-comment">// Use following steps to create a warmed up snapshot blob from a cold one:</span><br>  <span class="hljs-comment">//  - Create a new isolate from the cold snapshot.</span><br>  <span class="hljs-comment">//  - Create a new context to run the warmup script. This will trigger</span><br>  <span class="hljs-comment">//    compilation of executed functions.</span><br>  <span class="hljs-comment">//  - Create a new context. This context will be unpolluted.</span><br>  <span class="hljs-comment">//  - Serialize the isolate and the second context into a new snapshot blob.</span><br>  v8::StartupData result = &#123;<span class="hljs-literal">nullptr</span>, <span class="hljs-number">0</span>&#125;;<br>  &#123;<br>    <span class="hljs-function">v8::SnapshotCreator <span class="hljs-title">snapshot_creator</span><span class="hljs-params">(<span class="hljs-literal">nullptr</span>, &amp;cold_snapshot_blob)</span></span>;<br>    v8::Isolate* isolate = snapshot_creator.<span class="hljs-built_in">GetIsolate</span>();<br>    &#123;<br>      <span class="hljs-function">v8::HandleScope <span class="hljs-title">scope</span><span class="hljs-params">(isolate)</span></span>;<br>      v8::Local&lt;v8::Context&gt; context = v8::Context::<span class="hljs-built_in">New</span>(isolate);<br>      <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">RunExtraCode</span>(isolate, context, warmup_source, <span class="hljs-string">&quot;&lt;warm-up&gt;&quot;</span>)) &#123;<br>        <span class="hljs-keyword">return</span> result;<br>      &#125;<br>    &#125;<br>    &#123;<br>      <span class="hljs-function">v8::HandleScope <span class="hljs-title">handle_scope</span><span class="hljs-params">(isolate)</span></span>;<br>      isolate-&gt;<span class="hljs-built_in">ContextDisposedNotification</span>(<span class="hljs-literal">false</span>);<br>      v8::Local&lt;v8::Context&gt; context = v8::Context::<span class="hljs-built_in">New</span>(isolate);<br>      snapshot_creator.<span class="hljs-built_in">SetDefaultContext</span>(context);<br>    &#125;<br>    result = snapshot_creator.<span class="hljs-built_in">CreateBlob</span>(<br>        v8::SnapshotCreator::FunctionCodeHandling::kKeep);<br>  &#125;<br>  <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><p>接下来我们看下整体使用方式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">MaybeLocal&lt;Value&gt; <span class="hljs-title">CompileRun</span><span class="hljs-params">(Isolate* isolate, <span class="hljs-type">const</span> <span class="hljs-type">char</span>* source)</span> </span>&#123;<br>  Local&lt;String&gt; source_string =<br>      String::<span class="hljs-built_in">NewFromUtf8</span>(isolate, source, NewStringType::kNormal)<br>          .<span class="hljs-built_in">ToLocalChecked</span>();<br>  Local&lt;Context&gt; context = isolate-&gt;<span class="hljs-built_in">GetCurrentContext</span>();<br>  Local&lt;Script&gt; script =<br>      Script::<span class="hljs-built_in">Compile</span>(context, source_string).<span class="hljs-built_in">ToLocalChecked</span>();<br>  <span class="hljs-keyword">return</span> script-&gt;<span class="hljs-built_in">Run</span>(context);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Test</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-type">const</span> <span class="hljs-type">char</span>* source =<br>      <span class="hljs-string">&quot;function f() &#123; return Math.abs(1); &#125;\n&quot;</span><br>      <span class="hljs-string">&quot;function g() &#123; return String.raw(1); &#125;\n&quot;</span><br>      <span class="hljs-string">&quot;Object.valueOf(1);&quot;</span><br>      <span class="hljs-string">&quot;var a = 5&quot;</span>;<br>  <span class="hljs-type">const</span> <span class="hljs-type">char</span>* warmup = <span class="hljs-string">&quot;a = f()&quot;</span>;<br><br>  v8::StartupData cold = <span class="hljs-built_in">CreateSnapshotDataBlob</span>(source); <span class="hljs-comment">// 生成快照数据</span><br>  v8::StartupData warm = <span class="hljs-built_in">WarmUpSnapshotDataBlob</span>(cold, warmup); <span class="hljs-comment">// 生成预热后的快照数据</span><br>  <span class="hljs-keyword">delete</span>[] cold.data;<br><br>  v8::Isolate::CreateParams params;<br>  params.snapshot_blob = &amp;warm; <span class="hljs-comment">// 传入预热后的快照数据，用于创建v8的上下文</span><br>  params.array_buffer_allocator = v8::ArrayBuffer::Allocator::<span class="hljs-built_in">NewDefaultAllocator</span>();<br>  v8::Isolate* isolate = v8::Isolate::<span class="hljs-built_in">New</span>(params);<br>  &#123;<br>    v8::<span class="hljs-function">Isolate::Scope <span class="hljs-title">i_scope</span><span class="hljs-params">(isolate)</span></span>;<br>    <span class="hljs-function">v8::HandleScope <span class="hljs-title">h_scope</span><span class="hljs-params">(isolate)</span></span>;<br>    v8::Local&lt;v8::Context&gt; context = v8::Context::<span class="hljs-built_in">New</span>(isolate);<br>    v8::<span class="hljs-function">Context::Scope <span class="hljs-title">c_scope</span><span class="hljs-params">(context)</span></span>;<br>    <span class="hljs-built_in">CHECK_EQ</span>(<span class="hljs-number">5</span>, <span class="hljs-built_in">CompileRun</span>(<span class="hljs-string">&quot;a&quot;</span>)-&gt;<span class="hljs-built_in">Int32Value</span>(context).<span class="hljs-built_in">FromJust</span>()); <span class="hljs-comment">// 检查变量a是否还是原来的值</span><br>  &#125;<br>  isolate-&gt;<span class="hljs-built_in">Dispose</span>();<br>  <span class="hljs-keyword">delete</span>[] warm.data;<br><br>  v8::V8::<span class="hljs-built_in">Dispose</span>();<br>  v8::V8::<span class="hljs-built_in">ShutdownPlatform</span>();<br>  g_platform.<span class="hljs-built_in">reset</span>();<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>同步知乎：<a href="https://zhuanlan.zhihu.com/p/235217474">https://zhuanlan.zhihu.com/p/235217474</a></p>]]></content>
    
    
    <categories>
      
      <category>V8</category>
      
    </categories>
    
    
    <tags>
      
      <tag>指南</tag>
      
      <tag>SnapshotCreator</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>V8 HandleScope原理解析（三）</title>
    <link href="/2022/05/04/V8-HandleScope%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90%EF%BC%88%E4%B8%89%EF%BC%89/"/>
    <url>/2022/05/04/V8-HandleScope%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90%EF%BC%88%E4%B8%89%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>本章主要讲解下HandleScope在虚构的时候做哪些事情？</p><p>1.删除该域的内存<br>2.变更next和limit的地址</p><p>首先我们从代码的角度上进行分析：</p><figure class="highlight c++"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><pre><code class="hljs C++">HandleScope::~<span class="hljs-built_in">HandleScope</span>() &#123;<br>  i::HandleScope::<span class="hljs-built_in">CloseScope</span>(isolate_, prev_next_, prev_limit_);<br>&#125;<br></code></pre></td></tr></table></figure><p>虚构函数是实际上是调用HandleScope::CloseScope函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">HandleScope::CloseScope</span><span class="hljs-params">(Isolate* isolate, Address* prev_next,</span></span><br><span class="hljs-params"><span class="hljs-function">                             Address* prev_limit)</span> </span>&#123;<br>  HandleScopeData* current = isolate-&gt;<span class="hljs-built_in">handle_scope_data</span>();<br><br>  std::<span class="hljs-built_in">swap</span>(current-&gt;next, prev_next); <span class="hljs-comment">// HandleScopeData的next和prev_next值进行互换</span><br>  current-&gt;level--;<br>  Address* limit = prev_next;<br>  <span class="hljs-keyword">if</span> (current-&gt;limit != prev_limit) &#123;<br>    current-&gt;limit = prev_limit;<br>    limit = prev_limit;<br>    <span class="hljs-built_in">DeleteExtensions</span>(isolate); <span class="hljs-comment">// 调用DeleteExtensions删除扩展的块的内存，指的是一整块的进行删除</span><br>  &#125;<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> ENABLE_HANDLE_ZAPPING</span><br>  <span class="hljs-built_in">ZapRange</span>(current-&gt;next, limit);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>  <span class="hljs-built_in">MSAN_ALLOCATED_UNINITIALIZED_MEMORY</span>(<br>      current-&gt;next,<br>      <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">size_t</span>&gt;(<span class="hljs-built_in">reinterpret_cast</span>&lt;Address&gt;(limit) -<br>                          <span class="hljs-built_in">reinterpret_cast</span>&lt;Address&gt;(current-&gt;next))); <span class="hljs-comment">// 重新初始化current-&gt;next 到 current-&gt;limit的之前内存 </span><br>&#125;<br></code></pre></td></tr></table></figure><p>HandleScope::CloseScope函数主要做的事情：</p><p>第一：HandleScopeData的next和prev_next值进行互换</p><p>第二：level值减1</p><p>第三：调用DeleteExtensions删除扩展的块的内存，指的是一整块的进行删除</p><p>第四：重新初始化current-&gt;next到当前块的current-&gt;limit的之前内存（本质上就是清空原来的数据，因为这个块是在使用着的，所以不能按第三步那样删除）</p><p>接下来我们看下DeleteExtensions的实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">HandleScopeImplementer::DeleteExtensions</span><span class="hljs-params">(internal::Address* prev_limit)</span> </span>&#123;<br>  <span class="hljs-keyword">while</span> (!blocks_.<span class="hljs-built_in">empty</span>()) &#123;<br>    internal::Address* block_start = blocks_.<span class="hljs-built_in">back</span>();<br>    internal::Address* block_limit = block_start + kHandleBlockSize;<br><br>    <span class="hljs-comment">// SealHandleScope may make the prev_limit to point inside the block.</span><br>    <span class="hljs-comment">// Cast possibly-unrelated pointers to plain Addres before comparing them</span><br>    <span class="hljs-comment">// to avoid undefined behavior.</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">reinterpret_cast</span>&lt;Address&gt;(block_start) &lt;=<br>            <span class="hljs-built_in">reinterpret_cast</span>&lt;Address&gt;(prev_limit) &amp;&amp;<br>        <span class="hljs-built_in">reinterpret_cast</span>&lt;Address&gt;(prev_limit) &lt;=<br>            <span class="hljs-built_in">reinterpret_cast</span>&lt;Address&gt;(block_limit)) &#123;<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> ENABLE_HANDLE_ZAPPING</span><br>      internal::HandleScope::<span class="hljs-built_in">ZapRange</span>(prev_limit, block_limit);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>      <span class="hljs-keyword">break</span>;<br>    &#125;<br><br>    blocks_.<span class="hljs-built_in">pop_back</span>();<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> ENABLE_HANDLE_ZAPPING</span><br>    internal::HandleScope::<span class="hljs-built_in">ZapRange</span>(block_start, block_limit);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>    <span class="hljs-keyword">if</span> (spare_ != <span class="hljs-literal">nullptr</span>) &#123;<br>      <span class="hljs-built_in">DeleteArray</span>(spare_);<br>    &#125;<br>    spare_ = block_start;<br>  &#125;<br>  <span class="hljs-built_in">DCHECK</span>((blocks_.<span class="hljs-built_in">empty</span>() &amp;&amp; prev_limit == <span class="hljs-literal">nullptr</span>) ||<br>         (!blocks_.<span class="hljs-built_in">empty</span>() &amp;&amp; prev_limit != <span class="hljs-literal">nullptr</span>));<br>&#125;<br></code></pre></td></tr></table></figure><p>DeleteExtensions本质上就是寻找到扩展的内存块进行删除。</p><p>会调用DeleteArray删除，代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">DeleteArray</span><span class="hljs-params">(T* array)</span> </span>&#123;<br>  <span class="hljs-keyword">delete</span>[] array;<br>&#125;<br></code></pre></td></tr></table></figure><p>看下MSAN_ALLOCATED_UNINITIALIZED_MEMORY这个宏:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// Marks a memory range as uninitialized, as if it was allocated here.</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MSAN_ALLOCATED_UNINITIALIZED_MEMORY(p, s) \</span><br><span class="hljs-meta">  __msan_allocated_memory(reinterpret_cast<span class="hljs-string">&lt;const void*&gt;</span>(p), (s))</span><br></code></pre></td></tr></table></figure><p>本质上就是调用__msan_allocated_memory清除内存。</p><p>接着上一章<a href="https://zhuanlan.zhihu.com/p/210983664%E7%9A%84%E4%BC%AA%E4%BB%A3%E7%A0%81%EF%BC%8Cscope_2%E6%9E%90%E6%9E%84%E5%90%8E%EF%BC%8C%E6%95%B4%E4%B8%AA%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%98%AF%E5%A6%82%E4%BD%95%E5%8F%98%E5%8C%96%EF%BC%8C%E5%A6%82%E4%B8%8B%E5%9B%BE%EF%BC%9A">https://zhuanlan.zhihu.com/p/210983664的伪代码，scope_2析构后，整个数据结构是如何变化，如下图：</a><br><img src="/2022/05/04/V8-HandleScope%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90%EF%BC%88%E4%B8%89%EF%BC%89/1.jpg"><br>可以看到handle_scope_data.next设置成了scope_2.prev_next_值。</p><p>handle_scope_data.limit 设置成了scope_2.prev_limit _值。</p><p>同步知乎：<a href="https://zhuanlan.zhihu.com/p/214142313">https://zhuanlan.zhihu.com/p/214142313</a></p>]]></content>
    
    
    <categories>
      
      <category>V8</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Isolate</tag>
      
      <tag>HandleScope</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>V8 HandleScope原理解析（二）</title>
    <link href="/2022/05/04/V8-HandleScope%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <url>/2022/05/04/V8-HandleScope%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>上章主要讲解到hanlde创建，这章讲解HandleScope。</p><p>首先我们看下HandleScope的简化代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">V8_EXPORT</span> HandleScope &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">HandleScope</span><span class="hljs-params">(Isolate* isolate)</span></span>;<br><br>  ~<span class="hljs-built_in">HandleScope</span>();<br><br>.......<br><br> <span class="hljs-keyword">private</span>:<br>........<br>  internal::Isolate* isolate_; <span class="hljs-comment">// 当前所属的隔离</span><br>  internal::Address* prev_next_; <span class="hljs-comment">// 前一个HandleScope的使用到的地址</span><br>  internal::Address* prev_limit_; <span class="hljs-comment">// 前一个HandleScope的内存块的最大地址</span><br>........<br>&#125;;<br></code></pre></td></tr></table></figure><p>HandleScope在使用的时候必须绑定一个Isolate，因为Isolate里管理内存相关信息。</p><p>HandleScope成员有：</p><p>isolate_：所绑定的隔离</p><p>prev_next_：表示前一个HandleScope对象的使用到的地址。</p><p>prev_limit_：表示前一个HandleScope对象内存块最大地址。</p><p>接下来看下一段伪代码，声明两个HandleScope对象，看看HandleScope各自的指针变化</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs C++">Isolate* isolate = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Isolate</span>()<br><br><span class="hljs-comment">// 第一步</span><br><span class="hljs-comment">// 声明scope_1</span><br>v8::HandleScope <span class="hljs-built_in">scope_1</span>(isolate)<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">* 创建2045个v8::Local&lt;v8::String&gt;对象</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-comment">// 第二步</span><br><span class="hljs-comment">// 声明scope_2</span><br>v8::HandleScope <span class="hljs-built_in">scope_2</span>(isolate)<br><br><span class="hljs-comment">// 第三步</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">* 继续创建1024个v8::Local&lt;v8::String&gt;对象</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p>接下来看如图内存的变化<br><img src="/2022/05/04/V8-HandleScope%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90%EF%BC%88%E4%BA%8C%EF%BC%89/1.jpg" alt="数据结构变化"><br>当声明一个HandleScope时候，会把上一个HandleScope使用到的内存地址信息赋值到当前的成员变量中，这个是为了方便后续恢复。我们代码角度看看是如何赋值的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs C++">HandleScope::<span class="hljs-built_in">HandleScope</span>(Isolate* isolate) &#123;<br>  <span class="hljs-built_in">Initialize</span>(isolate);<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">HandleScope::Initialize</span><span class="hljs-params">(Isolate* isolate)</span> </span>&#123;<br>  i::Isolate* internal_isolate = <span class="hljs-built_in">reinterpret_cast</span>&lt;i::Isolate*&gt;(isolate);<br>  <span class="hljs-comment">// We do not want to check the correct usage of the Locker class all over the</span><br>  <span class="hljs-comment">// place, so we do it only here: Without a HandleScope, an embedder can do</span><br>  <span class="hljs-comment">// almost nothing, so it is enough to check in this central place.</span><br>  <span class="hljs-comment">// We make an exception if the serializer is enabled, which means that the</span><br>  <span class="hljs-comment">// Isolate is exclusively used to create a snapshot.</span><br>  Utils::<span class="hljs-built_in">ApiCheck</span>(<br>      !v8::Locker::<span class="hljs-built_in">IsActive</span>() ||<br>          internal_isolate-&gt;<span class="hljs-built_in">thread_manager</span>()-&gt;<span class="hljs-built_in">IsLockedByCurrentThread</span>() ||<br>          internal_isolate-&gt;<span class="hljs-built_in">serializer_enabled</span>(),<br>      <span class="hljs-string">&quot;HandleScope::HandleScope&quot;</span>,<br>      <span class="hljs-string">&quot;Entering the V8 API without proper locking in place&quot;</span>);<br>  i::HandleScopeData* current = internal_isolate-&gt;<span class="hljs-built_in">handle_scope_data</span>(); <span class="hljs-comment">// 获取isolate里HandleScope内存管理信息</span><br>  isolate_ = internal_isolate;<br>  prev_next_ = current-&gt;next; <span class="hljs-comment">// 本质上就是把isolate内上一个handle的使用到的地址进行赋值</span><br>  prev_limit_ = current-&gt;limit;<span class="hljs-comment">// 本质上就是把isolate内当前内存块的最大地址进行赋值</span><br>  current-&gt;level++;<br>&#125;<br></code></pre></td></tr></table></figure><p>其实本质上就是涉及HandleScope，HandleScopeData，Isolate。只要搞懂这三者的关系则可以搞明白整个原理。<br><img src="/2022/05/04/V8-HandleScope%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90%EF%BC%88%E4%BA%8C%EF%BC%89/2.jpg"></p><p>同步知乎：<a href="https://zhuanlan.zhihu.com/p/210983664">https://zhuanlan.zhihu.com/p/210983664</a></p>]]></content>
    
    
    <categories>
      
      <category>V8</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Isolate</tag>
      
      <tag>HandleScope</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>V8 HandleScope原理解析（一）</title>
    <link href="/2022/05/04/V8-HandleScope%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <url>/2022/05/04/V8-HandleScope%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>一个函数中，可以有很多Handle，而HandleScope则相当于用来装Handle（Local）的容器，当HandleScope生命周期结束的时候，Handle也将会被释放。HandleScope是分配在栈上，不能通过直接New的方式进行创建。对于同一个作用域内可以有多个HandleScope，新的HandleScope将会覆盖上一个HandleScope，并对Local Handle进行管理。</p><p>接下来主要讲解的是Handle相关知识。</p><p>我们通过Handle New函数开始分析Handle的创建</p><figure class="highlight c++"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T1, <span class="hljs-keyword">typename</span>&gt;<br>Handle&lt;T&gt; Handle&lt;T&gt;::<span class="hljs-built_in">New</span>(T* object, Isolate* isolate) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">Handle</span>(<span class="hljs-built_in">reinterpret_cast</span>&lt;T**&gt;(<br>      HandleScope::<span class="hljs-built_in">CreateHandle</span>(isolate, <span class="hljs-built_in">reinterpret_cast</span>&lt;Address&gt;(object))));<br>&#125;<br></code></pre></td></tr></table></figure><p>由上代码可以知道Handle New会调用HandleScope::CreateHandle函数返回个地址：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">Address* <span class="hljs-title">HandleScope::CreateHandle</span><span class="hljs-params">(Isolate* isolate, Address value)</span> </span>&#123;<br>  <span class="hljs-built_in">DCHECK</span>(AllowHandleAllocation::<span class="hljs-built_in">IsAllowed</span>());<br>  HandleScopeData* data = isolate-&gt;<span class="hljs-built_in">handle_scope_data</span>();<br>  Address* result = data-&gt;next;<br>  <span class="hljs-keyword">if</span> (result == data-&gt;limit) &#123; <span class="hljs-comment">// 当可用的内存不足的时候，则扩展内存</span><br>    result = <span class="hljs-built_in">Extend</span>(isolate); <span class="hljs-comment">// 创建新的内存块，返回内存块的起始地址</span><br>  &#125;<br>  <span class="hljs-comment">// Update the current next field, set the value in the created handle,</span><br>  <span class="hljs-comment">// and return the result.</span><br>  <span class="hljs-built_in">DCHECK_LT</span>(<span class="hljs-built_in">reinterpret_cast</span>&lt;Address&gt;(result),<br>            <span class="hljs-built_in">reinterpret_cast</span>&lt;Address&gt;(data-&gt;limit));<br>  data-&gt;next = <span class="hljs-built_in">reinterpret_cast</span>&lt;Address*&gt;(<span class="hljs-built_in">reinterpret_cast</span>&lt;Address&gt;(result) +<br>                                          <span class="hljs-built_in">sizeof</span>(Address));<br>  *result = value; <span class="hljs-comment">// 保存值，到智力就是object对象的指针写入到一个内存地址中了</span><br>  <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><p>看下HandleScopeData，这是在isolate的成员，一个isolate只有一个，是一一对应的，是为了记录HandleScope的下一个可用的地址，和当前最大块地址等信息</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">HandleScopeData</span> <span class="hljs-keyword">final</span> &#123;<br>  Address* next; <span class="hljs-comment">// 下一个可用的地址</span><br>  Address* limit; <span class="hljs-comment">// 当前块的最大地址</span><br>  <span class="hljs-type">int</span> level; <span class="hljs-comment">// 当前的层级（每创建一个HandleScope就+1，虚构就-1）</span><br>  <span class="hljs-type">int</span> sealed_level;<br>  CanonicalHandleScope* canonical_scope;<br><br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Initialize</span><span class="hljs-params">()</span> </span>&#123;<br>    next = limit = <span class="hljs-literal">nullptr</span>;<br>    sealed_level = level = <span class="hljs-number">0</span>;<br>    canonical_scope = <span class="hljs-literal">nullptr</span>;<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>上面函数内注释可以看到如果当前无可用内存了，则会调用Extend进行扩展内存块，接下来看下的Extend函数实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">Address* <span class="hljs-title">HandleScope::Extend</span><span class="hljs-params">(Isolate* isolate)</span> </span>&#123;<br>  HandleScopeData* current = isolate-&gt;<span class="hljs-built_in">handle_scope_data</span>();<br><br>  Address* result = current-&gt;next;<br><br>  <span class="hljs-built_in">DCHECK</span>(result == current-&gt;limit);<br>  <span class="hljs-comment">// Make sure there&#x27;s at least one scope on the stack and that the</span><br>  <span class="hljs-comment">// top of the scope stack isn&#x27;t a barrier.</span><br>  <span class="hljs-keyword">if</span> (!Utils::<span class="hljs-built_in">ApiCheck</span>(current-&gt;level != current-&gt;sealed_level,<br>                       <span class="hljs-string">&quot;v8::HandleScope::CreateHandle()&quot;</span>,<br>                       <span class="hljs-string">&quot;Cannot create a handle without a HandleScope&quot;</span>)) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>  &#125;<br>  HandleScopeImplementer* impl = isolate-&gt;<span class="hljs-built_in">handle_scope_implementer</span>();<br>  <span class="hljs-comment">// If there&#x27;s more room in the last block, we use that. This is used</span><br>  <span class="hljs-comment">// for fast creation of scopes after scope barriers.</span><br>  <span class="hljs-keyword">if</span> (!impl-&gt;<span class="hljs-built_in">blocks</span>()-&gt;<span class="hljs-built_in">empty</span>()) &#123;<br>    Address* limit = &amp;impl-&gt;<span class="hljs-built_in">blocks</span>()-&gt;<span class="hljs-built_in">back</span>()[kHandleBlockSize];<br>    <span class="hljs-keyword">if</span> (current-&gt;limit != limit) &#123;<br>      current-&gt;limit = limit;<br>      <span class="hljs-built_in">DCHECK_LT</span>(limit - current-&gt;next, kHandleBlockSize);<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-comment">// If we still haven&#x27;t found a slot for the handle, we extend the</span><br>  <span class="hljs-comment">// current handle scope by allocating a new handle block.</span><br>  <span class="hljs-keyword">if</span> (result == current-&gt;limit) &#123; <span class="hljs-comment">// 如果可用使用内存地址 == 如果当前块的最大地址，则表明已经没有使用空间了，需要新创建个内存空间</span><br>    <span class="hljs-comment">// If there&#x27;s a spare block, use it for growing the current scope.</span><br>    result = impl-&gt;<span class="hljs-built_in">GetSpareOrNewBlock</span>(); <span class="hljs-comment">// 创建新的内存块 </span><br>    <span class="hljs-comment">// Add the extension to the global list of blocks, but count the</span><br>    <span class="hljs-comment">// extension as part of the current scope.</span><br>    impl-&gt;<span class="hljs-built_in">blocks</span>()-&gt;<span class="hljs-built_in">push_back</span>(result); <span class="hljs-comment">// 把新的内存块push到数组里</span><br>    current-&gt;limit = &amp;result[kHandleBlockSize]; <span class="hljs-comment">// 设置isolate的最大内存使用范围，起始就是新内存块的尾地址</span><br>  &#125;<br><br>  <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><p>kHandleBlockSize的数值定义如下：（真是数值就是1024 - 2 &#x3D; 1022）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">const</span> <span class="hljs-type">int</span> kHandleBlockSize = v8::internal::KB - <span class="hljs-number">2</span>;  <span class="hljs-comment">// fit in one page</span><br></code></pre></td></tr></table></figure><p>GetSpareOrNewBlock函数的实现，本质上就是用NewArray一个kHandleBlockSize（1022）大小的内存空间。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// If there&#x27;s a spare block, use it for growing the current scope.</span><br><span class="hljs-function">internal::Address* <span class="hljs-title">HandleScopeImplementer::GetSpareOrNewBlock</span><span class="hljs-params">()</span> </span>&#123;<br>  internal::Address* block =<br>      (spare_ != <span class="hljs-literal">nullptr</span>) ? spare_<br>                          : <span class="hljs-built_in">NewArray</span>&lt;internal::Address&gt;(kHandleBlockSize);<br>  spare_ = <span class="hljs-literal">nullptr</span>;<br>  <span class="hljs-keyword">return</span> block;<br>&#125;<br></code></pre></td></tr></table></figure><p>接下来有如下伪代码：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">/*第一次创建Local对象*/</span><br>v8::Local&lt;v8::<span class="hljs-type">String</span>&gt; source = v8::String::<span class="hljs-title function_ invoke__">NewFromUtf8</span>(isolate, <span class="hljs-string">&quot;test&quot;</span>).<span class="hljs-title function_ invoke__">ToLocalChecked</span>();<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">* 中间继续创建1024个v8::Local&lt;v8::String&gt;对象</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-comment">// 这个时候由于第一块的内存不够，则会新建个内存块</span><br></code></pre></td></tr></table></figure><p>HandleScopeData内的数据结构如下变化：（为了简单，用的都是假地址）<br><img src="/2022/05/04/V8-HandleScope%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89/1.jpg" alt="数据结构"></p><p>同步知乎：<a href="https://zhuanlan.zhihu.com/p/206730893">https://zhuanlan.zhihu.com/p/206730893</a></p>]]></content>
    
    
    <categories>
      
      <category>V8</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Isolate</tag>
      
      <tag>HandleScope</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>V8接口指南--Isolate多线程创建</title>
    <link href="/2022/05/04/V8%E6%8E%A5%E5%8F%A3%E6%8C%87%E5%8D%97-Isolate%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%88%9B%E5%BB%BA/"/>
    <url>/2022/05/04/V8%E6%8E%A5%E5%8F%A3%E6%8C%87%E5%8D%97-Isolate%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%88%9B%E5%BB%BA/</url>
    
    <content type="html"><![CDATA[<p>Isolate是否可以每个线程创建一个isolate呢？</p><p>答案：可以</p><p>每个线程创建一个对应的isolate实例。</p><p>实例代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></div></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;errno.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/stat.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;limits.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;include/libplatform/libplatform.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;include/libplatform/v8-tracing.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;src/api-inl.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;src/base/cpu.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;src/base/logging.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;src/objects-inl.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;src/objects.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;src/utils.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;src/v8.h&quot;</span></span><br><br><span class="hljs-keyword">namespace</span> demo &#123;<br><br>std::unique_ptr&lt;v8::Platform&gt; g_platform;<br><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> v8::Local&lt;v8::String&gt; <span class="hljs-title">v8_str</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* x)</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> v8::String::<span class="hljs-built_in">NewFromUtf8</span>(v8::Isolate::<span class="hljs-built_in">GetCurrent</span>(), x,<br>                                 v8::NewStringType::kNormal)<br>      .<span class="hljs-built_in">ToLocalChecked</span>();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> v8::Local&lt;v8::Script&gt; <span class="hljs-title">v8_compile</span><span class="hljs-params">(v8::Local&lt;v8::String&gt; x)</span> </span>&#123;<br>  v8::Local&lt;v8::Script&gt; result;<br>  <span class="hljs-keyword">if</span> (v8::Script::<span class="hljs-built_in">Compile</span>(v8::Isolate::<span class="hljs-built_in">GetCurrent</span>()-&gt;<span class="hljs-built_in">GetCurrentContext</span>(), x)<br>          .<span class="hljs-built_in">ToLocal</span>(&amp;result)) &#123;<br>    <span class="hljs-keyword">return</span> result;<br>  &#125;<br>  <span class="hljs-keyword">return</span> v8::<span class="hljs-built_in">Local</span>&lt;v8::Script&gt;();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> v8::Local&lt;v8::Value&gt; <span class="hljs-title">CompileRun</span><span class="hljs-params">(v8::Local&lt;v8::String&gt; source)</span> </span>&#123;<br>  v8::Local&lt;v8::Value&gt; result;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">v8_compile</span>(source)<br>          -&gt;<span class="hljs-built_in">Run</span>(v8::Isolate::<span class="hljs-built_in">GetCurrent</span>()-&gt;<span class="hljs-built_in">GetCurrentContext</span>())<br>          .<span class="hljs-built_in">ToLocal</span>(&amp;result)) &#123;<br>    <span class="hljs-keyword">return</span> result;<br>  &#125;<br>  <span class="hljs-keyword">return</span> v8::<span class="hljs-built_in">Local</span>&lt;v8::Value&gt;();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> v8::Local&lt;v8::Value&gt; <span class="hljs-title">CompileRun</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* source)</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">CompileRun</span>(<span class="hljs-built_in">v8_str</span>(source));<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">CalcFibonacci</span><span class="hljs-params">(<span class="hljs-type">int</span> limit)</span> </span>&#123;<br>  v8::Isolate::CreateParams create_params;<br>  create_params.array_buffer_allocator =<br>                        v8::ArrayBuffer::Allocator::<span class="hljs-built_in">NewDefaultAllocator</span>();<br>  v8::Isolate* isolate = v8::Isolate::<span class="hljs-built_in">New</span>(create_params);<br>  &#123;<br>    v8::<span class="hljs-function">Isolate::Scope <span class="hljs-title">isolate_scope</span><span class="hljs-params">(isolate)</span></span>;<br>    <span class="hljs-function">v8::HandleScope <span class="hljs-title">scope</span><span class="hljs-params">(isolate)</span></span>;<br><br>    v8::Local&lt;v8::Context&gt; context =<br>        v8::Context::<span class="hljs-built_in">New</span>(isolate);<br>    &#123;<br>      v8::<span class="hljs-function">Context::Scope <span class="hljs-title">context_scope</span><span class="hljs-params">(context)</span></span>;<br>    <br>      <span class="hljs-function">i::ScopedVector&lt;<span class="hljs-type">char</span>&gt; <span class="hljs-title">code</span><span class="hljs-params">(<span class="hljs-number">1024</span>)</span></span>;<br>      i::<span class="hljs-built_in">SNPrintF</span>(code, <span class="hljs-string">&quot;function fib(n) &#123;&quot;</span><br>                        <span class="hljs-string">&quot;  if (n &lt;= 2) return 1;&quot;</span><br>                        <span class="hljs-string">&quot;  return fib(n-1) + fib(n-2);&quot;</span><br>                        <span class="hljs-string">&quot;&#125;&quot;</span><br>                        <span class="hljs-string">&quot;fib(%d)&quot;</span>, limit);<br>      v8::Local&lt;v8::Value&gt; value = <span class="hljs-built_in">CompileRun</span>(code.<span class="hljs-built_in">start</span>());<br>      <span class="hljs-built_in">CHECK</span>(value-&gt;<span class="hljs-built_in">IsNumber</span>());<br>      std::cout&lt;&lt;<span class="hljs-string">&quot;tid:&quot;</span>&lt;&lt;std::this_thread::<span class="hljs-built_in">get_id</span>()&lt;&lt;<br>        <span class="hljs-string">&quot; result:&quot;</span>&lt;&lt;<span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">int</span>&gt;(value-&gt;<span class="hljs-built_in">NumberValue</span>(context).<span class="hljs-built_in">FromJust</span>())&lt;&lt;std::endl;<br>    &#125;<br>  &#125;<br>  isolate-&gt;<span class="hljs-built_in">Dispose</span>();<br>  <span class="hljs-keyword">delete</span> create_params.array_buffer_allocator;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Test</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-function">std::thread <span class="hljs-title">thread1</span><span class="hljs-params">(CalcFibonacci, <span class="hljs-number">21</span>)</span></span>;<br>  <span class="hljs-function">std::thread <span class="hljs-title">thread2</span><span class="hljs-params">(CalcFibonacci, <span class="hljs-number">12</span>)</span></span>;<br><br>  thread1.<span class="hljs-built_in">join</span>();<br>  thread2.<span class="hljs-built_in">join</span>();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>* argv[])</span> </span>&#123;<br>  <span class="hljs-comment">// new default platform. use v8::platform::CreateDefaultPlatform() in old version</span><br>  g_platform = v8::platform::<span class="hljs-built_in">NewDefaultPlatform</span>();<br><br>  <span class="hljs-comment">// init platform</span><br>  v8::V8::<span class="hljs-built_in">InitializePlatform</span>(g_platform.<span class="hljs-built_in">get</span>());<br>  v8::V8::<span class="hljs-built_in">Initialize</span>();<br><br>  <span class="hljs-comment">// set natives_blob / snapshot_blob file path.</span><br>  <span class="hljs-comment">// you can use InitializeExternalStartupData(const char* natives_blob, const char* snapshot_blob)</span><br>  v8::V8::<span class="hljs-built_in">InitializeExternalStartupData</span>(argv[<span class="hljs-number">0</span>]);<br><br>  <span class="hljs-built_in">Test</span>();<br><br>  v8::V8::<span class="hljs-built_in">Dispose</span>();<br>  v8::V8::<span class="hljs-built_in">ShutdownPlatform</span>();<br><br>  <span class="hljs-comment">// Delete the platform explicitly here to write the tracing output to the</span><br>  <span class="hljs-comment">// tracing file.</span><br>  g_platform.<span class="hljs-built_in">reset</span>();<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br>&#125;  <span class="hljs-comment">// namespace demo</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>* argv[])</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> demo::<span class="hljs-built_in">Main</span>(argc, argv);<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ruby">lyg<span class="hljs-variable">@lyg</span>-ThinkCentre-M8600t-<span class="hljs-variable constant_">N000</span><span class="hljs-symbol">:/win/code/v8-pc/v8</span><span class="hljs-variable">$ </span>./out.gn/x64.release/demo <br><span class="hljs-symbol">tid:</span><span class="hljs-number">139984336537344</span> <span class="hljs-symbol">result:</span><span class="hljs-number">144</span><br><span class="hljs-symbol">tid:</span><span class="hljs-number">139984344930048</span> <span class="hljs-symbol">result:</span><span class="hljs-number">10946</span><br></code></pre></td></tr></table></figure><p>同步知乎：<a href="https://zhuanlan.zhihu.com/p/194259040">https://zhuanlan.zhihu.com/p/194259040</a></p>]]></content>
    
    
    <categories>
      
      <category>V8</category>
      
    </categories>
    
    
    <tags>
      
      <tag>指南</tag>
      
      <tag>Isolate</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>V8接口指南--Isolate::Scope</title>
    <link href="/2022/05/04/V8%E6%8E%A5%E5%8F%A3%E6%8C%87%E5%8D%97-Isolate-Scope/"/>
    <url>/2022/05/04/V8%E6%8E%A5%E5%8F%A3%E6%8C%87%E5%8D%97-Isolate-Scope/</url>
    
    <content type="html"><![CDATA[<p>作用：</p><p>这是用于本地范围内操作Isolate的类</p><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Stack-allocated class which sets the isolate for all operations</span><br><span class="hljs-comment"> * executed within a local scope.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">V8_EXPORT</span> Scope &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">Scope</span><span class="hljs-params">(Isolate* isolate)</span> : isolate_(isolate) &#123;</span><br>    isolate-&gt;<span class="hljs-built_in">Enter</span>();<br>  &#125;<br><br>  ~<span class="hljs-built_in">Scope</span>() &#123; isolate_-&gt;<span class="hljs-built_in">Exit</span>(); &#125;<br><br>  <span class="hljs-comment">// Prevent copying of Scope objects.</span><br>  <span class="hljs-built_in">Scope</span>(<span class="hljs-type">const</span> Scope&amp;) = <span class="hljs-keyword">delete</span>;<br>  Scope&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Scope&amp;) = <span class="hljs-keyword">delete</span>;<br><br> <span class="hljs-keyword">private</span>:<br>  Isolate* <span class="hljs-type">const</span> isolate_;<br>&#125;;<br></code></pre></td></tr></table></figure><p>如上代码：</p><p>构造的时候传入isolate，执行isolate-&gt;Enter()</p><p>虚构的时候执行isolate-&gt;Exit()</p><p>本质上就是Enter&#x2F;Exit的操作。</p><p>一个线程中可以创建多个isolate，多个isolate是一个栈式管理的，Enter相当于入栈，Exit相当于出栈。获取当前处在哪个隔离则是GetCurrent函数。</p><p>Enter和Exit函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Sets this isolate as the entered one for the current thread.</span><br><span class="hljs-comment"> * Saves the previously entered one (if any), so that it can be</span><br><span class="hljs-comment"> * restored when exiting.  Re-entering an isolate is allowed.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Enter</span><span class="hljs-params">()</span></span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Exits this isolate by restoring the previously entered one in the</span><br><span class="hljs-comment"> * current thread.  The isolate may still stay the same, if it was</span><br><span class="hljs-comment"> * entered more than once.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * Requires: this == Isolate::GetCurrent().</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Exit</span><span class="hljs-params">()</span></span>;<br></code></pre></td></tr></table></figure><p>GetCurrent函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Returns the entered isolate for the current thread or NULL in</span><br><span class="hljs-comment"> * case there is no current isolate.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * This method must not be invoked before V8::Initialize() was invoked.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">static</span> Isolate* <span class="hljs-title">GetCurrent</span><span class="hljs-params">()</span></span>;<br></code></pre></td></tr></table></figure><p>实例代码：</p><p>创建两个隔离，对隔离进行如下操作</p><p>isolate1-&gt;Enter() ———- 执行后当前隔离是isolate1</p><p>isolate2-&gt;Enter() ———- 执行后当前隔离是isolate2</p><p>isolate2-&gt;Exit() ———- 执行后当前隔离是isolate1</p><p>isolate1-&gt;Exit() ———- 执行后当前隔离是null</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;errno.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/stat.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;include/libplatform/libplatform.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;include/libplatform/v8-tracing.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;src/api-inl.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;src/base/cpu.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;src/base/logging.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;src/objects-inl.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;src/objects.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;src/utils.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;src/v8.h&quot;</span></span><br><br><span class="hljs-keyword">namespace</span> demo &#123;<br><br>std::unique_ptr&lt;v8::Platform&gt; g_platform;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Test</span><span class="hljs-params">()</span> </span>&#123;<br>  v8::Isolate::CreateParams create_params1;<br>  create_params1.array_buffer_allocator =<br>        v8::ArrayBuffer::Allocator::<span class="hljs-built_in">NewDefaultAllocator</span>();<br>  v8::Isolate* isolate1 = v8::Isolate::<span class="hljs-built_in">New</span>(create_params1);<br><br>  v8::Isolate::CreateParams create_params2;<br>  create_params2.array_buffer_allocator =<br>        v8::ArrayBuffer::Allocator::<span class="hljs-built_in">NewDefaultAllocator</span>();<br>  v8::Isolate* isolate2 = v8::Isolate::<span class="hljs-built_in">New</span>(create_params2);  <br><br>  std::cout&lt;&lt;<span class="hljs-string">&quot;current isolate : &quot;</span>&lt;&lt;v8::Isolate::<span class="hljs-built_in">GetCurrent</span>()&lt;&lt;<span class="hljs-string">&quot;\n&quot;</span>;<br><br>  isolate1-&gt;<span class="hljs-built_in">Enter</span>();<br>  <br>  std::cout&lt;&lt;<span class="hljs-string">&quot;current isolate is isolate1 : &quot;</span>&lt;&lt;(v8::Isolate::<span class="hljs-built_in">GetCurrent</span>() == isolate1)&lt;&lt;<span class="hljs-string">&quot;\n&quot;</span>;<br><br>  isolate2-&gt;<span class="hljs-built_in">Enter</span>();<br>  <br>  std::cout&lt;&lt;<span class="hljs-string">&quot;current isolate is isolate2 : &quot;</span>&lt;&lt;(v8::Isolate::<span class="hljs-built_in">GetCurrent</span>() == isolate2)&lt;&lt;<span class="hljs-string">&quot;\n&quot;</span>;<br>  <br>  isolate2-&gt;<span class="hljs-built_in">Exit</span>();<br>  <br>  std::cout&lt;&lt;<span class="hljs-string">&quot;current isolate is isolate1 : &quot;</span>&lt;&lt;(v8::Isolate::<span class="hljs-built_in">GetCurrent</span>() == isolate1)&lt;&lt;<span class="hljs-string">&quot;\n&quot;</span>;<br>  <br>  isolate1-&gt;<span class="hljs-built_in">Exit</span>();<br><br>  std::cout&lt;&lt;<span class="hljs-string">&quot;current isolate : &quot;</span>&lt;&lt;v8::Isolate::<span class="hljs-built_in">GetCurrent</span>()&lt;&lt;<span class="hljs-string">&quot;\n&quot;</span>;<br><br>  isolate2-&gt;<span class="hljs-built_in">Dispose</span>();<br>  isolate1-&gt;<span class="hljs-built_in">Dispose</span>();<br><br>  <span class="hljs-keyword">delete</span> create_params2.array_buffer_allocator;<br>  <span class="hljs-keyword">delete</span> create_params1.array_buffer_allocator;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>* argv[])</span> </span>&#123;<br>  <span class="hljs-comment">// new default platform. use v8::platform::CreateDefaultPlatform() in old version</span><br>  g_platform = v8::platform::<span class="hljs-built_in">NewDefaultPlatform</span>();<br><br>  <span class="hljs-comment">// init platform</span><br>  v8::V8::<span class="hljs-built_in">InitializePlatform</span>(g_platform.<span class="hljs-built_in">get</span>());<br>  v8::V8::<span class="hljs-built_in">Initialize</span>();<br><br>  <span class="hljs-comment">// set natives_blob / snapshot_blob file path.</span><br>  <span class="hljs-comment">// you can use InitializeExternalStartupData(const char* natives_blob, const char* snapshot_blob)</span><br>  v8::V8::<span class="hljs-built_in">InitializeExternalStartupData</span>(argv[<span class="hljs-number">0</span>]);<br><br>  <span class="hljs-built_in">Test</span>();<br><br>  v8::V8::<span class="hljs-built_in">Dispose</span>();<br>  v8::V8::<span class="hljs-built_in">ShutdownPlatform</span>();<br><br>  <span class="hljs-comment">// Delete the platform explicitly here to write the tracing output to the</span><br>  <span class="hljs-comment">// tracing file.</span><br>  g_platform.<span class="hljs-built_in">reset</span>();<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br>&#125;  <span class="hljs-comment">// namespace demo</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>* argv[])</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> demo::<span class="hljs-built_in">Main</span>(argc, argv);<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs ruby">lyg<span class="hljs-variable">@lyg</span>-ThinkCentre-M8600t-<span class="hljs-variable constant_">N000</span><span class="hljs-symbol">:/win/code/v8-pc/v8</span><span class="hljs-variable">$ </span>./out.gn/x64.release/demo <br>current isolate : (<span class="hljs-literal">nil</span>)<br>current isolate is isolate1 : <span class="hljs-number">1</span><br>current isolate is isolate2 : <span class="hljs-number">1</span><br>current isolate is isolate1 : <span class="hljs-number">1</span><br>current isolate is isolate1 : (<span class="hljs-literal">nil</span>)<br></code></pre></td></tr></table></figure><p>同步知乎：<a href="https://zhuanlan.zhihu.com/p/194224181">https://zhuanlan.zhihu.com/p/194224181</a></p>]]></content>
    
    
    <categories>
      
      <category>V8</category>
      
    </categories>
    
    
    <tags>
      
      <tag>指南</tag>
      
      <tag>Scope</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>V8接口指南--ArrayBuffer::Allocator</title>
    <link href="/2022/05/04/V8%E6%8E%A5%E5%8F%A3%E6%8C%87%E5%8D%97-ArrayBuffer-Allocator/"/>
    <url>/2022/05/04/V8%E6%8E%A5%E5%8F%A3%E6%8C%87%E5%8D%97-ArrayBuffer-Allocator/</url>
    
    <content type="html"><![CDATA[<p>上章讲到isolate实例的创建，在创建的参数结构体中需要传入ArrayBuffer::Allocator* array_buffer_allocator。这个成员的作用是：用于ArrayBuffer的内存分配器。</p><p>我们知道js的对象的内存分配是从isolate里的heap中新生代&#x2F;老生代中分配的，对象的所属是js的堆内存中。但是js的ArrayBuffer分配内存，并不是从isolate里的heap中分配，而是直接由宿主自由控制分配和管理。</p><p>接下来下看下ArrayBuffer::Allocator的类代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></div></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">V8_EXPORT</span> Allocator &#123; <span class="hljs-comment">// NOLINT</span><br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Allocator</span>() = <span class="hljs-keyword">default</span>;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * Allocate |length| bytes. Return NULL if allocation is not successful.</span><br><span class="hljs-comment">   * Memory should be initialized to zeroes.</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span>* <span class="hljs-title">Allocate</span><span class="hljs-params">(<span class="hljs-type">size_t</span> length)</span> </span>= <span class="hljs-number">0</span>;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * Allocate |length| bytes. Return NULL if allocation is not successful.</span><br><span class="hljs-comment">   * Memory does not have to be initialized.</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span>* <span class="hljs-title">AllocateUninitialized</span><span class="hljs-params">(<span class="hljs-type">size_t</span> length)</span> </span>= <span class="hljs-number">0</span>;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * Free the memory block of size |length|, pointed to by |data|.</span><br><span class="hljs-comment">   * That memory is guaranteed to be previously allocated by |Allocate|.</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">Free</span><span class="hljs-params">(<span class="hljs-type">void</span>* data, <span class="hljs-type">size_t</span> length)</span> </span>= <span class="hljs-number">0</span>;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * ArrayBuffer allocation mode. kNormal is a malloc/free style allocation,</span><br><span class="hljs-comment">   * while kReservation is for larger allocations with the ability to set</span><br><span class="hljs-comment">   * access permissions.</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-keyword">enum class</span> <span class="hljs-title class_">AllocationMode</span> &#123; kNormal, kReservation &#125;;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * malloc/free based convenience allocator.</span><br><span class="hljs-comment">   *</span><br><span class="hljs-comment">   * Caller takes ownership, i.e. the returned object needs to be freed using</span><br><span class="hljs-comment">   * |delete allocator| once it is no longer in use.</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-function"><span class="hljs-type">static</span> Allocator* <span class="hljs-title">NewDefaultAllocator</span><span class="hljs-params">()</span></span>;<br>&#125;;<br></code></pre></td></tr></table></figure><p>如代码所示，下面是成员函数的解释：</p><p>Allocate 带初始化的分配内存函数，传入的参数length是需要分配内存的大小</p><p>AllocateUninitialized 不带初始化的分配内存函数，传入的参数length是需要分配内存的大小。<br>Free 释放内存函数，传入的参数是释放内存的指针data和对应的length大小</p><p>NewDefaultAllocator 创建默认的分配器，如果没有特殊需求，我们可以直接调用这个函数创建默认的ArrayBuffer内存分配器。如下示例代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++">v8::Isolate::CreateParams create_params;<br> create_params.array_buffer_allocator = v8::ArrayBuffer::Allocator::<span class="hljs-built_in">NewDefaultAllocator</span>();<br></code></pre></td></tr></table></figure><p>但是注意创建默认分配器，如果isolate释放后，代码中我们也需要delete分配器，代码如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">delete</span> create_params.array_buffer_allocator<br></code></pre></td></tr></table></figure><p>接下我们看下NewDefaultAllocator的分配器就是new ArrayBufferAllocator类：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ArrayBufferAllocator</span> : <span class="hljs-keyword">public</span> v8::ArrayBuffer::Allocator &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-type">void</span>* <span class="hljs-title">Allocate</span><span class="hljs-params">(<span class="hljs-type">size_t</span> length)</span> <span class="hljs-keyword">override</span> </span>&#123;<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> V8_OS_AIX &amp;&amp; _LINUX_SOURCE_COMPAT</span><br>    <span class="hljs-comment">// Work around for GCC bug on AIX</span><br>    <span class="hljs-comment">// See: https://gcc.gnu.org/bugzilla/show_bug.cgi?id=79839</span><br>    <span class="hljs-type">void</span>* data = __linux_calloc(length, <span class="hljs-number">1</span>);<br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>    <span class="hljs-type">void</span>* data = <span class="hljs-built_in">calloc</span>(length, <span class="hljs-number">1</span>);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>    <span class="hljs-comment">// v8::base::debug::StackTrace stack_trace;</span><br>    <span class="hljs-comment">// std::cout&lt;&lt;stack_trace.ToString();</span><br>    <span class="hljs-keyword">return</span> data;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-type">void</span>* <span class="hljs-title">AllocateUninitialized</span><span class="hljs-params">(<span class="hljs-type">size_t</span> length)</span> <span class="hljs-keyword">override</span> </span>&#123;<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> V8_OS_AIX &amp;&amp; _LINUX_SOURCE_COMPAT</span><br>    <span class="hljs-comment">// Work around for GCC bug on AIX</span><br>    <span class="hljs-comment">// See: https://gcc.gnu.org/bugzilla/show_bug.cgi?id=79839</span><br>    <span class="hljs-type">void</span>* data = __linux_malloc(length);<br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>    <span class="hljs-type">void</span>* data = <span class="hljs-built_in">malloc</span>(length);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>    <span class="hljs-keyword">return</span> data;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Free</span><span class="hljs-params">(<span class="hljs-type">void</span>* data, <span class="hljs-type">size_t</span>)</span> <span class="hljs-keyword">override</span> </span>&#123;<br>    <span class="hljs-built_in">free</span>(data);<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>我们可以看到ArrayBufferAllocator是v8::ArrayBuffer::Allocator的子类。ArrayBufferAllocator重写了父类的函数。</p><p>Allocate：调用calloc分配内存</p><p>AllocateUninitialized：调用malloc分配内存</p><p>Free：调用free分配内存</p><p>所以使用方可以模仿ArrayBufferAllocator来管控ArrayBuffer内存分配。</p><p>接下来写一个ArrayBuffer自定义一个分配器ArrayBufferAllocatorDemo。执行的js是：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs JS"><span class="hljs-keyword">var</span> buffer1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayBuffer</span>(<span class="hljs-number">8</span>); <span class="hljs-comment">// 分配8个大小的ArrayBuffer</span><br><span class="hljs-keyword">var</span> buffer2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayBuffer</span>(<span class="hljs-number">1024</span>); <span class="hljs-comment">// 分配1024个大小的ArrayBuffer</span><br></code></pre></td></tr></table></figure><p>然后我们看下ArrayBuffer的内存从哪里分配的。</p><p>完整的示例代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;errno.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/stat.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;include/libplatform/libplatform.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;include/libplatform/v8-tracing.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;src/api-inl.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;src/base/cpu.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;src/base/logging.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;src/objects-inl.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;src/objects.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;src/utils.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;src/v8.h&quot;</span></span><br><br><span class="hljs-keyword">namespace</span> demo &#123;<br><br>std::unique_ptr&lt;v8::Platform&gt; g_platform;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ArrayBufferAllocatorDemo</span> : <span class="hljs-keyword">public</span> v8::ArrayBuffer::Allocator &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-type">void</span>* <span class="hljs-title">Allocate</span><span class="hljs-params">(<span class="hljs-type">size_t</span> length)</span> <span class="hljs-keyword">override</span> </span>&#123;<br>    <span class="hljs-type">void</span>* data = <span class="hljs-built_in">calloc</span>(length, <span class="hljs-number">1</span>);<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;ArrayBuffer Allocate data: &quot;</span>&lt;&lt;data&lt;&lt;<span class="hljs-string">&quot; length:&quot;</span>&lt;&lt;length &lt;&lt;<span class="hljs-string">&quot;\n&quot;</span>;<br>    <span class="hljs-keyword">return</span> data;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-type">void</span>* <span class="hljs-title">AllocateUninitialized</span><span class="hljs-params">(<span class="hljs-type">size_t</span> length)</span> <span class="hljs-keyword">override</span> </span>&#123;<br>    <span class="hljs-type">void</span>* data = <span class="hljs-built_in">malloc</span>(length);<br>    <span class="hljs-keyword">return</span> data;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Free</span><span class="hljs-params">(<span class="hljs-type">void</span>* data, <span class="hljs-type">size_t</span> length)</span> <span class="hljs-keyword">override</span> </span>&#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;ArrayBuffer Free data: &quot;</span>&lt;&lt;data&lt;&lt;<span class="hljs-string">&quot; length:&quot;</span>&lt;&lt;length &lt;&lt;<span class="hljs-string">&quot;\n&quot;</span>;<br>    <span class="hljs-built_in">free</span>(data);<br>  &#125;<br>&#125;;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>* argv[])</span> </span>&#123;<br>  <span class="hljs-comment">// new default platform. use v8::platform::CreateDefaultPlatform() in old version</span><br>  g_platform = v8::platform::<span class="hljs-built_in">NewDefaultPlatform</span>();<br><br>  <span class="hljs-comment">// init platform</span><br>  v8::V8::<span class="hljs-built_in">InitializePlatform</span>(g_platform.<span class="hljs-built_in">get</span>());<br>  v8::V8::<span class="hljs-built_in">Initialize</span>();<br><br>  <span class="hljs-comment">// set natives_blob / snapshot_blob file path.</span><br>  <span class="hljs-comment">// you can use InitializeExternalStartupData(const char* natives_blob, const char* snapshot_blob)</span><br>  v8::V8::<span class="hljs-built_in">InitializeExternalStartupData</span>(argv[<span class="hljs-number">0</span>]);<br><br>  v8::Isolate::CreateParams create_params;<br>  create_params.array_buffer_allocator =<br>        <span class="hljs-keyword">new</span> <span class="hljs-built_in">ArrayBufferAllocatorDemo</span>();<br>  <br>  v8::Isolate* isolate = v8::Isolate::<span class="hljs-built_in">New</span>(create_params);<br>  &#123;<br>      <span class="hljs-function">v8::HandleScope <span class="hljs-title">scope</span><span class="hljs-params">(isolate)</span></span>;<br><br>      v8::Local&lt;v8::Context&gt; context = v8::Context::<span class="hljs-built_in">New</span>(isolate);<br>      v8::<span class="hljs-function">Context::Scope <span class="hljs-title">context_scope</span><span class="hljs-params">(context)</span></span>;<br>      v8::Local&lt;v8::String&gt; source =<br>      v8::String::<span class="hljs-built_in">NewFromUtf8</span>(isolate,<br>          <span class="hljs-string">&quot;var buffer1 = new ArrayBuffer(8);\n&quot;</span><br>          <span class="hljs-string">&quot;var buffer2 = new ArrayBuffer(1024);\n&quot;</span>,<br>          v8::NewStringType::kNormal)<br>          .<span class="hljs-built_in">ToLocalChecked</span>();<br><br>      v8::Local&lt;v8::Script&gt; script = v8::Script::<span class="hljs-built_in">Compile</span>(context, source).<span class="hljs-built_in">ToLocalChecked</span>();<br>      v8::Local&lt;v8::Value&gt; result = script-&gt;<span class="hljs-built_in">Run</span>(context).<span class="hljs-built_in">ToLocalChecked</span>();<br>      <span class="hljs-keyword">if</span> (result-&gt;<span class="hljs-built_in">IsNumber</span>()) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;js run result: &quot;</span>&lt;&lt;v8::Int32::<span class="hljs-built_in">Cast</span>(*result)-&gt;<span class="hljs-built_in">Value</span>() &lt;&lt;<span class="hljs-string">&quot;\n&quot;</span>;<br>      &#125;<br>  &#125;<br>  isolate-&gt;<span class="hljs-built_in">Dispose</span>();<br><br>  <span class="hljs-keyword">delete</span> create_params.array_buffer_allocator;<br><br>  v8::V8::<span class="hljs-built_in">Dispose</span>();<br>  v8::V8::<span class="hljs-built_in">ShutdownPlatform</span>();<br><br>  <span class="hljs-comment">// Delete the platform explicitly here to write the tracing output to the</span><br>  <span class="hljs-comment">// tracing file.</span><br>  g_platform.<span class="hljs-built_in">reset</span>();<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br>&#125;  <span class="hljs-comment">// namespace demo</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>* argv[])</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> demo::<span class="hljs-built_in">Main</span>(argc, argv);<br>&#125;<br></code></pre></td></tr></table></figure><p>输出的打印：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ruby">lyg<span class="hljs-variable">@lyg</span>-ThinkCentre-M8600t-<span class="hljs-variable constant_">N000</span><span class="hljs-symbol">:/win/code/v8-pc/v8</span><span class="hljs-variable">$ </span>./out.gn/x64.release/demo <br>ArrayBuffer Allocate <span class="hljs-symbol">data:</span> <span class="hljs-number">0x556414839460</span> <span class="hljs-symbol">length:</span><span class="hljs-number">8</span><br>ArrayBuffer Allocate <span class="hljs-symbol">data:</span> <span class="hljs-number">0x556414845d80</span> <span class="hljs-symbol">length:</span><span class="hljs-number">1024</span><br>ArrayBuffer Free <span class="hljs-symbol">data:</span> <span class="hljs-number">0x556414845d80</span> <span class="hljs-symbol">length:</span><span class="hljs-number">1024</span><br>ArrayBuffer Free <span class="hljs-symbol">data:</span> <span class="hljs-number">0x556414839460</span> <span class="hljs-symbol">length:</span><span class="hljs-number">8</span><br></code></pre></td></tr></table></figure><p>可以看到两个ArrayBuffer的的内存都是从我构建的分配器进行分配的。</p><p>同步知乎：<a href="https://zhuanlan.zhihu.com/p/187550111">https://zhuanlan.zhihu.com/p/187550111</a></p>]]></content>
    
    
    <categories>
      
      <category>V8</category>
      
    </categories>
    
    
    <tags>
      
      <tag>指南</tag>
      
      <tag>ArrayBuffer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>V8接口指南--Isolate::New</title>
    <link href="/2022/05/04/V8%E6%8E%A5%E5%8F%A3%E6%8C%87%E5%8D%97-Isolate-New/"/>
    <url>/2022/05/04/V8%E6%8E%A5%E5%8F%A3%E6%8C%87%E5%8D%97-Isolate-New/</url>
    
    <content type="html"><![CDATA[<h2 id="Isolate-New函数作用"><a href="#Isolate-New函数作用" class="headerlink" title="Isolate::New函数作用"></a>Isolate::New函数作用</h2><p>用于创建Isolate实例。</p><p>头文件：</p><figure class="highlight c++"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;src/v8.h&quot;</span></span><br></code></pre></td></tr></table></figure><h2 id="New函数申明"><a href="#New函数申明" class="headerlink" title="New函数申明"></a>New函数申明</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Creates a new isolate.  Does not change the currently entered</span><br><span class="hljs-comment"> * isolate.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * When an isolate is no longer used its resources should be freed</span><br><span class="hljs-comment"> * by calling Dispose().  Using the delete operator is not allowed.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * V8::Initialize() must have run prior to this.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">static</span> Isolate* <span class="hljs-title">New</span><span class="hljs-params">(<span class="hljs-type">const</span> CreateParams&amp; params)</span></span>;<br></code></pre></td></tr></table></figure><p>注意：</p><p>可以从注释上看，调用该函数只是new一个isolate实例，但是并没有改变当前的所处在isolate中。</p><p>如果不再使用isolate，则需要调用Dispose()进行释放。</p><p>参数：</p><p>params：创建隔离的参数结构体</p><p><strong>CreateParams的介绍：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">CreateParams</span> &#123;<br>  <span class="hljs-built_in">CreateParams</span>()<br>      : <span class="hljs-built_in">entry_hook</span>(<span class="hljs-literal">nullptr</span>),<br>        <span class="hljs-built_in">code_event_handler</span>(<span class="hljs-literal">nullptr</span>),<br>        <span class="hljs-built_in">snapshot_blob</span>(<span class="hljs-literal">nullptr</span>),<br>        <span class="hljs-built_in">counter_lookup_callback</span>(<span class="hljs-literal">nullptr</span>),<br>        <span class="hljs-built_in">create_histogram_callback</span>(<span class="hljs-literal">nullptr</span>),<br>        <span class="hljs-built_in">add_histogram_sample_callback</span>(<span class="hljs-literal">nullptr</span>),<br>        <span class="hljs-built_in">array_buffer_allocator</span>(<span class="hljs-literal">nullptr</span>),<br>        <span class="hljs-built_in">external_references</span>(<span class="hljs-literal">nullptr</span>),<br>        <span class="hljs-built_in">allow_atomics_wait</span>(<span class="hljs-literal">true</span>),<br>        <span class="hljs-built_in">only_terminate_in_safe_scope</span>(<span class="hljs-literal">false</span>) &#123;&#125;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * The optional entry_hook allows the host application to provide the</span><br><span class="hljs-comment">   * address of a function that&#x27;s invoked on entry to every V8-generated</span><br><span class="hljs-comment">   * function.  Note that entry_hook is invoked at the very start of each</span><br><span class="hljs-comment">   * generated function.</span><br><span class="hljs-comment">   * An entry_hook can only be provided in no-snapshot builds; in snapshot</span><br><span class="hljs-comment">   * builds it must be nullptr.</span><br><span class="hljs-comment">   * TODO(v8:8503): Remove entry_hook.</span><br><span class="hljs-comment">   */</span><br>  FunctionEntryHook entry_hook;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * Allows the host application to provide the address of a function that is</span><br><span class="hljs-comment">   * notified each time code is added, moved or removed.</span><br><span class="hljs-comment">   */</span><br>  JitCodeEventHandler code_event_handler;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * ResourceConstraints to use for the new Isolate.</span><br><span class="hljs-comment">   */</span><br>  ResourceConstraints constraints;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * Explicitly specify a startup snapshot blob. The embedder owns the blob.</span><br><span class="hljs-comment">   */</span><br>  StartupData* snapshot_blob;<br><br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * Enables the host application to provide a mechanism for recording</span><br><span class="hljs-comment">   * statistics counters.</span><br><span class="hljs-comment">   */</span><br>  CounterLookupCallback counter_lookup_callback;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * Enables the host application to provide a mechanism for recording</span><br><span class="hljs-comment">   * histograms. The CreateHistogram function returns a</span><br><span class="hljs-comment">   * histogram which will later be passed to the AddHistogramSample</span><br><span class="hljs-comment">   * function.</span><br><span class="hljs-comment">   */</span><br>  CreateHistogramCallback create_histogram_callback;<br>  AddHistogramSampleCallback add_histogram_sample_callback;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * The ArrayBuffer::Allocator to use for allocating and freeing the backing</span><br><span class="hljs-comment">   * store of ArrayBuffers.</span><br><span class="hljs-comment">   */</span><br>  ArrayBuffer::Allocator* array_buffer_allocator;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * Specifies an optional nullptr-terminated array of raw addresses in the</span><br><span class="hljs-comment">   * embedder that V8 can match against during serialization and use for</span><br><span class="hljs-comment">   * deserialization. This array and its content must stay valid for the</span><br><span class="hljs-comment">   * entire lifetime of the isolate.</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-type">const</span> <span class="hljs-type">intptr_t</span>* external_references;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * Whether calling Atomics.wait (a function that may block) is allowed in</span><br><span class="hljs-comment">   * this isolate. This can also be configured via SetAllowAtomicsWait.</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-type">bool</span> allow_atomics_wait;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * Termination is postponed when there is no active SafeForTerminationScope.</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-type">bool</span> only_terminate_in_safe_scope;<br>&#125;;<br></code></pre></td></tr></table></figure><p>成员介绍：</p><p>entry_hook： 已经弃用了，不用关注</p><p>code_event_handler：类型是JitCodeEventHandler函数回调，用于js里函数代码添加，删除的回调。用于接入方监听js代码变化。（一般不设置），使用方式可见实例代码。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Callback function passed to SetJitCodeEventHandler.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * \param event code add, move or removal event.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">void</span> <span class="hljs-params">(*JitCodeEventHandler)</span><span class="hljs-params">(<span class="hljs-type">const</span> JitCodeEvent* event)</span></span>;<br></code></pre></td></tr></table></figure><p>constraints：用于设置isolate的资源大小的。（一般默认值）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">V8_EXPORT</span> ResourceConstraints &#123;<br> <span class="hljs-keyword">public</span>:<br><br>......<br><br> <span class="hljs-keyword">private</span>:<br>  <span class="hljs-comment">// max_semi_space_size_ is in KB</span><br>  <span class="hljs-type">size_t</span> max_semi_space_size_in_kb_; <span class="hljs-comment">// </span><br><br>  <span class="hljs-comment">// The remaining limits are in MB</span><br>  <span class="hljs-type">size_t</span> max_old_space_size_; <span class="hljs-comment">// 最大的老生代内存大小</span><br>  <span class="hljs-type">size_t</span> max_executable_size_; <br>  <span class="hljs-type">uint32_t</span>* stack_limit_; <span class="hljs-comment">// js栈大小限制</span><br>  <span class="hljs-type">size_t</span> code_range_size_; <span class="hljs-comment">// 代码区内存大小</span><br>  <span class="hljs-type">size_t</span> max_zone_pool_size_;<br>&#125;;<br></code></pre></td></tr></table></figure><p>snapshot_blob：快照数据</p><p>array_buffer_allocator： 类型是ArrayBuffer::Allocator（下章节具体讲解这个类），ArrayBuffer的后端内存分配器，这个是必须设置的，可以设置个默认值。代码使用例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++">v8::Isolate::CreateParams create_params;<br>create_params.array_buffer_allocator = v8::ArrayBuffer::Allocator::<span class="hljs-built_in">NewDefaultAllocator</span>();<br></code></pre></td></tr></table></figure><p><strong>code_event_handler的代码使用实例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// Copyright 2012 the V8 project authors. All rights reserved.</span><br><span class="hljs-comment">// Use of this source code is governed by a BSD-style license that can be</span><br><span class="hljs-comment">// found in the LICENSE file.</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;errno.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/stat.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;include/libplatform/libplatform.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;include/libplatform/v8-tracing.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;src/api-inl.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;src/base/cpu.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;src/base/logging.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;src/objects-inl.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;src/objects.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;src/utils.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;src/v8.h&quot;</span></span><br><br><span class="hljs-keyword">namespace</span> demo &#123;<br><br>v8::Platform* g_default_platform;<br>std::unique_ptr&lt;v8::Platform&gt; g_platform;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">OnJitEvent</span><span class="hljs-params">(<span class="hljs-type">const</span> v8::JitCodeEvent* event)</span> </span>&#123;<br>  <span class="hljs-keyword">switch</span> (event-&gt;type) &#123;<br>    <span class="hljs-keyword">case</span> v8::JitCodeEvent::CODE_ADDED: &#123;<br>      <span class="hljs-built_in">CHECK_NOT_NULL</span>(event-&gt;code_start);<br>      <span class="hljs-built_in">CHECK_NE</span>(<span class="hljs-number">0</span>, <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">int</span>&gt;(event-&gt;code_len));<br>      <span class="hljs-built_in">CHECK_NOT_NULL</span>(event-&gt;name.str);<br>      std::cout&lt;&lt;<span class="hljs-string">&quot;CODE_ADDED js function: &quot;</span>&lt;&lt;event-&gt;name.str&lt;&lt;<span class="hljs-string">&quot;\n&quot;</span>;<br>      &#125;<br>      <span class="hljs-keyword">break</span>;<br><br>    <span class="hljs-keyword">case</span> v8::JitCodeEvent::CODE_MOVED:<br>      <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">default</span>:<br>      <span class="hljs-keyword">break</span>;<br>  &#125;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>* argv[])</span> </span>&#123;<br>  <span class="hljs-comment">// new default platform. use v8::platform::CreateDefaultPlatform() in old version</span><br>  g_platform = v8::platform::<span class="hljs-built_in">NewDefaultPlatform</span>();<br><br>  g_default_platform = g_platform.<span class="hljs-built_in">get</span>();<br><br>  <span class="hljs-comment">// init platform</span><br>  v8::V8::<span class="hljs-built_in">InitializePlatform</span>(g_platform.<span class="hljs-built_in">get</span>());<br>  v8::V8::<span class="hljs-built_in">Initialize</span>();<br><br>  <span class="hljs-comment">// set natives_blob / snapshot_blob file path.</span><br>  <span class="hljs-comment">// you can use InitializeExternalStartupData(const char* natives_blob, const char* snapshot_blob)</span><br>  v8::V8::<span class="hljs-built_in">InitializeExternalStartupData</span>(argv[<span class="hljs-number">0</span>]);<br><br>  v8::Isolate::CreateParams create_params;<br><br>  create_params.code_event_handler = OnJitEvent;<br>  create_params.array_buffer_allocator =<br>        v8::ArrayBuffer::Allocator::<span class="hljs-built_in">NewDefaultAllocator</span>();<br>  <br>  v8::Isolate* isolate = v8::Isolate::<span class="hljs-built_in">New</span>(create_params);<br>  &#123;<br>      <span class="hljs-function">v8::HandleScope <span class="hljs-title">scope</span><span class="hljs-params">(isolate)</span></span>;<br><br>      v8::Local&lt;v8::Context&gt; context = v8::Context::<span class="hljs-built_in">New</span>(isolate);<br>      v8::<span class="hljs-function">Context::Scope <span class="hljs-title">context_scope</span><span class="hljs-params">(context)</span></span>;<br>      v8::Local&lt;v8::String&gt; source =<br>      v8::String::<span class="hljs-built_in">NewFromUtf8</span>(isolate,<br>          <span class="hljs-string">&quot;function a(a, b)&#123;return a+b;&#125;\n&quot;</span><br>          <span class="hljs-string">&quot;function b(a, b)&#123;return a+b;&#125;\n&quot;</span><br>          <span class="hljs-string">&quot;function c(a, b)&#123;return a+b;&#125;\n&quot;</span><br>          <span class="hljs-string">&quot;a(1, 2)\n&quot;</span><br>          <span class="hljs-string">&quot;b(1, 2)\n&quot;</span><br>          <span class="hljs-string">&quot;c(1, 2)\n&quot;</span>,<br>          v8::NewStringType::kNormal)<br>          .<span class="hljs-built_in">ToLocalChecked</span>();<br><br>      v8::Local&lt;v8::Script&gt; script = v8::Script::<span class="hljs-built_in">Compile</span>(context, source).<span class="hljs-built_in">ToLocalChecked</span>();<br>      v8::Local&lt;v8::Value&gt; result = script-&gt;<span class="hljs-built_in">Run</span>(context).<span class="hljs-built_in">ToLocalChecked</span>();<br>      <span class="hljs-keyword">if</span> (result-&gt;<span class="hljs-built_in">IsNumber</span>()) &#123;<br>        std::cout &lt;&lt; v8::Int32::<span class="hljs-built_in">Cast</span>(*result)-&gt;<span class="hljs-built_in">Value</span>() &lt;&lt;<span class="hljs-string">&quot;\n&quot;</span>;<br>      &#125;<br>  &#125;<br>  isolate-&gt;<span class="hljs-built_in">Dispose</span>();<br><br>  v8::V8::<span class="hljs-built_in">Dispose</span>();<br>  v8::V8::<span class="hljs-built_in">ShutdownPlatform</span>();<br><br>  <span class="hljs-keyword">delete</span> create_params.array_buffer_allocator;<br><br>  <span class="hljs-comment">// Delete the platform explicitly here to write the tracing output to the</span><br>  <span class="hljs-comment">// tracing file.</span><br>  g_platform.<span class="hljs-built_in">reset</span>();<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br>&#125;  <span class="hljs-comment">// namespace demo</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>* argv[])</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> demo::<span class="hljs-built_in">Main</span>(argc, argv);<br>&#125;<br></code></pre></td></tr></table></figure><p>解释：</p><p>如代码，可以看到js是声明了3个函数，分别为a，b，c函数。通过create_params.code_event_handler &#x3D; OnJitEvent设置了jit代码执行处理。当执行js时候，会回调OnJitEvent函数。当js函数a，b，c调用时候，同时代码也产生了v8::JitCodeEvent::CODE_ADDED操作。</p><p>输出：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ruby">lyg<span class="hljs-variable">@lyg</span>-ThinkCentre-M8600t-<span class="hljs-variable constant_">N000</span><span class="hljs-symbol">:/win/code/v8-pc/v8</span><span class="hljs-variable">$ </span>out.gn/x64.release/demo <br><span class="hljs-variable constant_">CODE_ADDED</span> js <span class="hljs-symbol">function:</span> <span class="hljs-symbol">Script:</span>~ <span class="hljs-symbol">:</span><span class="hljs-number">1</span><br><span class="hljs-variable constant_">CODE_ADDED</span> js <span class="hljs-symbol">function:</span> <span class="hljs-symbol">LazyCompile:</span>~a <span class="hljs-symbol">:</span><span class="hljs-number">1</span><br><span class="hljs-variable constant_">CODE_ADDED</span> js <span class="hljs-symbol">function:</span> <span class="hljs-symbol">LazyCompile:</span>~b <span class="hljs-symbol">:</span><span class="hljs-number">2</span><br><span class="hljs-variable constant_">CODE_ADDED</span> js <span class="hljs-symbol">function:</span> <span class="hljs-symbol">LazyCompile:</span>~c <span class="hljs-symbol">:</span><span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p>打印解释：</p><p>LazyCompile:~a :1</p><p>延时编译：js函数名：js函数所在的行数</p><p>同步知乎：<a href="https://zhuanlan.zhihu.com/p/186219660">https://zhuanlan.zhihu.com/p/186219660</a></p>]]></content>
    
    
    <categories>
      
      <category>V8</category>
      
    </categories>
    
    
    <tags>
      
      <tag>指南</tag>
      
      <tag>Isolate</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>V8接口指南--StartupData</title>
    <link href="/2022/05/04/V8%E6%8E%A5%E5%8F%A3%E6%8C%87%E5%8D%97-StartupData/"/>
    <url>/2022/05/04/V8%E6%8E%A5%E5%8F%A3%E6%8C%87%E5%8D%97-StartupData/</url>
    
    <content type="html"><![CDATA[<h2 id="第一种方式"><a href="#第一种方式" class="headerlink" title="第一种方式"></a>第一种方式</h2><h3 id="InitializeExternalStartupData函数作用"><a href="#InitializeExternalStartupData函数作用" class="headerlink" title="InitializeExternalStartupData函数作用"></a>InitializeExternalStartupData函数作用</h3><p>用于设置启动快照数据路径接口，在v8启动的时候设置。V8在启动的时候会需要预先加载一些build-in函数。V8引入了快照加载功能用于加速这个过程, 目前依赖两种快照natives_blob.bin和snapshot_blob.bin。 所以InitializeExternalStartupData函数就是设置V8的保存快照的路径。</p><p>natives_blob.bin文件：存储了build-in函数解析执行后的内存布局快照。build-in可以在v8&#x2F;src&#x2F;objects.h中的FUNCTIONS_WITH_ID_LIST宏中查看。</p><p>snapshot_blob.bin: 存储了V8启动后的内存布局快照。</p><p>头文件：</p><figure class="highlight c++"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;src/v8.h&quot;</span></span><br></code></pre></td></tr></table></figure><p>使用条件：</p><p>函数使用是有条件的，v8库编译的时候必须是开启V8_USE_EXTERNAL_STARTUP_DATA宏，而且是必须调用，不调用会报错。如果编译v8是库关闭快照功能则不需要调用该函数。</p><h3 id="InitializeExternalStartupData函数申明"><a href="#InitializeExternalStartupData函数申明" class="headerlink" title="InitializeExternalStartupData函数申明"></a>InitializeExternalStartupData函数申明</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Initialize the external startup data. The embedder only needs to</span><br><span class="hljs-comment"> * invoke this method when external startup data was enabled in a build.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * If V8 was compiled with the startup data in an external file, then</span><br><span class="hljs-comment"> * V8 needs to be given those external files during startup. There are</span><br><span class="hljs-comment"> * three ways to do this:</span><br><span class="hljs-comment"> * - InitializeExternalStartupData(const char*)</span><br><span class="hljs-comment"> *   This will look in the given directory for files &quot;natives_blob.bin&quot;</span><br><span class="hljs-comment"> *   and &quot;snapshot_blob.bin&quot; - which is what the default build calls them.</span><br><span class="hljs-comment"> * - InitializeExternalStartupData(const char*, const char*)</span><br><span class="hljs-comment"> *   As above, but will directly use the two given file names.</span><br><span class="hljs-comment"> * - Call SetNativesDataBlob, SetNativesDataBlob.</span><br><span class="hljs-comment"> *   This will read the blobs from the given data structures and will</span><br><span class="hljs-comment"> *   not perform any file IO.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">InitializeExternalStartupData</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* directory_path)</span></span>;<br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">InitializeExternalStartupData</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* natives_blob,</span></span><br><span class="hljs-params"><span class="hljs-function">                                          <span class="hljs-type">const</span> <span class="hljs-type">char</span>* snapshot_blob)</span></span>;<br></code></pre></td></tr></table></figure><p>参数：</p><p>directory_path：snapshot_blob.bin和natives_blob.bin的文件路径</p><p>natives_blob： natives_blob.bin文件的路径</p><p>snapshot_blob：snapshot_blob.bin文件的路径</p><p>接口示例代码：</p><p>参照上一章示例代码<a href="https://zhuanlan.zhihu.com/p/166679160">https://zhuanlan.zhihu.com/p/166679160</a></p><h2 id="第二种方式"><a href="#第二种方式" class="headerlink" title="第二种方式"></a>第二种方式</h2><p><strong>SetSnapshotDataBlob&#x2F;SetNativesDataBlob：</strong></p><p>在声明函数的地方注意到，还有第三种方式设置启动数据，就是调用SetSnapshotDataBlob&#x2F;SetNativesDataBlob函数进行设置。</p><p><strong>SetSnapshotDataBlob&#x2F;SetNativesDataBlob函数作用：</strong></p><p>SetSnapshotDataBlob用于设置snapshot_blob数据函数</p><p>SetNativesDataBlob用于设置natives_blob数据函数</p><p><strong>SetSnapshotDataBlob&#x2F;SetNativesDataBlob函数申明：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Hand startup data to V8, in case the embedder has chosen to build</span><br><span class="hljs-comment"> * V8 with external startup data.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * Note:</span><br><span class="hljs-comment"> * - By default the startup data is linked into the V8 library, in which</span><br><span class="hljs-comment"> *   case this function is not meaningful.</span><br><span class="hljs-comment"> * - If this needs to be called, it needs to be called before V8</span><br><span class="hljs-comment"> *   tries to make use of its built-ins.</span><br><span class="hljs-comment"> * - To avoid unnecessary copies of data, V8 will point directly into the</span><br><span class="hljs-comment"> *   given data blob, so pretty please keep it around until V8 exit.</span><br><span class="hljs-comment"> * - Compression of the startup blob might be useful, but needs to</span><br><span class="hljs-comment"> *   handled entirely on the embedders&#x27; side.</span><br><span class="hljs-comment"> * - The call will abort if the data is invalid.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">SetNativesDataBlob</span><span class="hljs-params">(StartupData* startup_blob)</span></span>;<br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">SetSnapshotDataBlob</span><span class="hljs-params">(StartupData* startup_blob)</span></span>;<br></code></pre></td></tr></table></figure><p>参数：</p><p>startup_blob：类型是StartupData，用于传递blob数据类。StartupData代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">V8_EXPORT</span> StartupData &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-type">const</span> <span class="hljs-type">char</span>* data; <span class="hljs-comment">// 数据指针</span><br>  <span class="hljs-type">int</span> raw_size; <span class="hljs-comment">// 数据大小</span><br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>chromium上使用接口的片段代码：</strong></p><p>chromium上设置SetSnapshotDataBlob&#x2F;SetNativesDataBlob片段代码，本质上就是把快照的文件分别读到g_mapped_natives和g_mapped_snapshot的数据结构中，然后再通过传递v8的StartupData类，最终调用函数设置：（<a href="http://v8_initializer.cc)/">http://v8_initializer.cc）</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">if</span> defined(V8_USE_EXTERNAL_STARTUP_DATA)</span><br>  v8::StartupData natives;<br>  natives.data = <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">const</span> <span class="hljs-type">char</span>*&gt;(g_mapped_natives-&gt;<span class="hljs-built_in">data</span>());<br>  natives.raw_size = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">int</span>&gt;(g_mapped_natives-&gt;<span class="hljs-built_in">length</span>());<br>  v8::V8::<span class="hljs-built_in">SetNativesDataBlob</span>(&amp;natives);<br><br>  <span class="hljs-keyword">if</span> (g_mapped_snapshot) &#123;<br>    v8::StartupData snapshot;<br>    snapshot.data = <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">const</span> <span class="hljs-type">char</span>*&gt;(g_mapped_snapshot-&gt;<span class="hljs-built_in">data</span>());<br>    snapshot.raw_size = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">int</span>&gt;(g_mapped_snapshot-&gt;<span class="hljs-built_in">length</span>());<br>    v8::V8::<span class="hljs-built_in">SetSnapshotDataBlob</span>(&amp;snapshot);<br>  &#125;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span>  <span class="hljs-comment">// V8_USE_EXTERNAL_STARTUP_DATA</span></span><br></code></pre></td></tr></table></figure><p>同步知乎：<a href="https://zhuanlan.zhihu.com/p/168769292">https://zhuanlan.zhihu.com/p/168769292</a></p>]]></content>
    
    
    <categories>
      
      <category>V8</category>
      
    </categories>
    
    
    <tags>
      
      <tag>指南</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>V8接口指南--NewDefaultPlatform</title>
    <link href="/2022/05/04/V8%E6%8E%A5%E5%8F%A3%E6%8C%87%E5%8D%97-NewDefaultPlatform/"/>
    <url>/2022/05/04/V8%E6%8E%A5%E5%8F%A3%E6%8C%87%E5%8D%97-NewDefaultPlatform/</url>
    
    <content type="html"><![CDATA[<h2 id="NewDefaultPlatform作用"><a href="#NewDefaultPlatform作用" class="headerlink" title="NewDefaultPlatform作用"></a>NewDefaultPlatform作用</h2><p>NewDefaultPlatform 用于创建默认平台相关的函数，保存线程，内存分配，任务处理等操作。本章主要讲解这个接口使用，DefaultPlatform的原理和内部实现，后面有空再讲哈。</p><p>头文件：</p><figure class="highlight c++"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;include/libplatform/libplatform.h&quot;</span></span><br></code></pre></td></tr></table></figure><h2 id="NewDefaultPlatform函数"><a href="#NewDefaultPlatform函数" class="headerlink" title="NewDefaultPlatform函数"></a>NewDefaultPlatform函数</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Returns a new instance of the default v8::Platform implementation.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * The caller will take ownership of the returned pointer. |thread_pool_size|</span><br><span class="hljs-comment"> * is the number of worker threads to allocate for background jobs. If a value</span><br><span class="hljs-comment"> * of zero is passed, a suitable default based on the current number of</span><br><span class="hljs-comment"> * processors online will be chosen.</span><br><span class="hljs-comment"> * If |idle_task_support| is enabled then the platform will accept idle</span><br><span class="hljs-comment"> * tasks (IdleTasksEnabled will return true) and will rely on the embedder</span><br><span class="hljs-comment"> * calling v8::platform::RunIdleTasks to process the idle tasks.</span><br><span class="hljs-comment"> * If |tracing_controller| is nullptr, the default platform will create a</span><br><span class="hljs-comment"> * v8::platform::TracingController instance and use it.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function">V8_PLATFORM_EXPORT std::unique_ptr&lt;v8::Platform&gt; <span class="hljs-title">NewDefaultPlatform</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-type">int</span> thread_pool_size = <span class="hljs-number">0</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">    IdleTaskSupport idle_task_support = IdleTaskSupport::kDisabled,</span></span><br><span class="hljs-params"><span class="hljs-function">    InProcessStackDumping in_process_stack_dumping =</span></span><br><span class="hljs-params"><span class="hljs-function">        InProcessStackDumping::kDisabled,</span></span><br><span class="hljs-params"><span class="hljs-function">    std::unique_ptr&lt;v8::TracingController&gt; tracing_controller = &#123;&#125;)</span></span>;<br></code></pre></td></tr></table></figure><p>早期的函数申明CreateDefaultPlatform（目前已经弃用），直接调用也没问题，编译时候会产生警告，打印出Use NewDefaultPlatform instead：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">V8_PLATFORM_EXPORT <span class="hljs-title">V8_DEPRECATE_SOON</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-string">&quot;Use NewDefaultPlatform instead&quot;</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">    v8::Platform* CreateDefaultPlatform(</span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-type">int</span> thread_pool_size = <span class="hljs-number">0</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">        IdleTaskSupport idle_task_support = IdleTaskSupport::kDisabled,</span></span><br><span class="hljs-params"><span class="hljs-function">        InProcessStackDumping in_process_stack_dumping =</span></span><br><span class="hljs-params"><span class="hljs-function">            InProcessStackDumping::kDisabled,</span></span><br><span class="hljs-params"><span class="hljs-function">        v8::TracingController* tracing_controller = <span class="hljs-literal">nullptr</span>))</span></span>;<br></code></pre></td></tr></table></figure><h2 id="参数解释"><a href="#参数解释" class="headerlink" title="参数解释"></a>参数解释</h2><p>thread_pool_size： 线程池个数，默认传参可以是0，但是并不代表线程池个数为0，如果传入的参数是0，则是按照cpu的核数-1进行创建，例如cpu是8核，则线程数是7个。最大线程数是8，具体原理可以看如下代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">const</span> <span class="hljs-type">int</span> DefaultPlatform::kMaxThreadPoolSize = <span class="hljs-number">8</span>;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">DefaultPlatform::SetThreadPoolSize</span><span class="hljs-params">(<span class="hljs-type">int</span> thread_pool_size)</span> </span>&#123;<br>  <span class="hljs-function">base::MutexGuard <span class="hljs-title">guard</span><span class="hljs-params">(&amp;lock_)</span></span>;<br>  <span class="hljs-built_in">DCHECK_GE</span>(thread_pool_size, <span class="hljs-number">0</span>);<br>  <span class="hljs-keyword">if</span> (thread_pool_size &lt; <span class="hljs-number">1</span>) &#123;<br>    thread_pool_size = base::SysInfo::<span class="hljs-built_in">NumberOfProcessors</span>() - <span class="hljs-number">1</span>;<br>  &#125;<br>  thread_pool_size_ =<br>      std::<span class="hljs-built_in">max</span>(std::<span class="hljs-built_in">min</span>(thread_pool_size, kMaxThreadPoolSize), <span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>idle_task_support：是否支持空闲任务，这个作用主要是统计用于cpu空闲状态的，参数默认是关闭的。参数输入值：开启（kEnabled）&#x2F; 关闭（kDisabled），类型代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">enum class</span> <span class="hljs-title class_">IdleTaskSupport</span> &#123; kDisabled, kEnabled &#125;;<br></code></pre></td></tr></table></figure><p>in_process_stack_dumping：是否开启堆栈转储于控制台输出。默认是关闭的。在调试中可以开启。参数的输入值：开启（kEnabled）或者关闭（kDisabled）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">enum class</span> <span class="hljs-title class_">InProcessStackDumping</span> &#123; kDisabled, kEnabled &#125;;<br></code></pre></td></tr></table></figure><p>为了表明差别，我在代码中写入一个崩溃，传入参数为kEnabled，的结果如下：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs ruby">lyg<span class="hljs-variable">@lyg</span>-ThinkCentre-M8600t-<span class="hljs-variable constant_">N000</span><span class="hljs-symbol">:/win/code/v8-pc/v8/out</span>.gn/x64.release<span class="hljs-variable">$ </span>./demo <br>Received signal <span class="hljs-number">11</span> <span class="hljs-variable constant_">SEGV_MAPERR</span> <span class="hljs-number">000000000027</span><br><br>==== C stack trace ===============================<br><br> [<span class="hljs-number">0x5590c6206ef4</span>]<br> [<span class="hljs-number">0x7f95c8e8e390</span>]<br> [<span class="hljs-number">0x5590c5ae5635</span>]<br> [<span class="hljs-number">0x5590c5a3b70b</span>]<br> [<span class="hljs-number">0x5590c5a3bc37</span>]<br> [<span class="hljs-number">0x5590c5a3bd54</span>]<br> [<span class="hljs-number">0x5590c5a313e8</span>]<br> [<span class="hljs-number">0x5590c5a31699</span>]<br> [<span class="hljs-number">0x7f95c83ac830</span>]<br> [<span class="hljs-number">0x5590c5a3102a</span>]<br>[<span class="hljs-keyword">end</span> of stack trace]<br>Segmentation fault (core dumped)<br></code></pre></td></tr></table></figure><p>传入参数为kDisabled，的结果如下：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ruby">lyg<span class="hljs-variable">@lyg</span>-ThinkCentre-M8600t-<span class="hljs-variable constant_">N000</span><span class="hljs-symbol">:/win/code/v8-pc/v8/out</span>.gn/x64.release<span class="hljs-variable">$ </span>./demo <br>Segmentation fault (core dumped)<br></code></pre></td></tr></table></figure><p>对比开启和关闭，结果很明显开启后控制台可以打印出崩溃的堆栈，关闭后智能打印出段错误。</p><p>tracing_controller：抓v8 trace控制类，默认值为nullptr。这个会花一个章节讲讲解下，想快速了解如何使用，可以看示例代码。</p><h2 id="接口使用示例代码"><a href="#接口使用示例代码" class="headerlink" title="接口使用示例代码"></a>接口使用示例代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;errno.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/stat.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;include/libplatform/libplatform.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;include/libplatform/v8-tracing.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;src/api-inl.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;src/base/cpu.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;src/base/logging.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;src/objects-inl.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;src/objects.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;src/utils.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;src/v8.h&quot;</span></span><br><br><span class="hljs-keyword">namespace</span> demo &#123;<br><br>v8::Platform* g_default_platform;<br>std::unique_ptr&lt;v8::Platform&gt; g_platform;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>* argv[])</span> </span>&#123;<br>  std::ofstream trace_file;<br>  v8::platform::InProcessStackDumping in_process_stack_dumping = <span class="hljs-comment">// v8::platform::InProcessStackDumping::kDisabled;</span><br>                                                                 v8::platform::InProcessStackDumping::kEnabled;<br><br>  <span class="hljs-comment">//create v8 trace</span><br>  std::unique_ptr&lt;v8::platform::tracing::TracingController&gt; tracing =<br>      v8::base::<span class="hljs-built_in">make_unique</span>&lt;v8::platform::tracing::TracingController&gt;();<br>  trace_file.<span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;v8_trace.json&quot;</span>);<br>  v8::platform::tracing::TraceBuffer* trace_buffer =<br>      v8::platform::tracing::TraceBuffer::<span class="hljs-built_in">CreateTraceBufferRingBuffer</span>(<br>          v8::platform::tracing::TraceBuffer::kRingBufferChunks,<br>          v8::platform::tracing::TraceWriter::<span class="hljs-built_in">CreateJSONTraceWriter</span>(trace_file));<br>  tracing-&gt;<span class="hljs-built_in">Initialize</span>(trace_buffer);<br><br>  v8::platform::tracing::TracingController* tracing_controller = tracing.<span class="hljs-built_in">get</span>();<br><br>  <span class="hljs-comment">// new default platform. use v8::platform::CreateDefaultPlatform() in old version</span><br>  g_platform = v8::platform::<span class="hljs-built_in">NewDefaultPlatform</span>(<br>      <span class="hljs-number">0</span>, v8::platform::IdleTaskSupport::kEnabled,<br>      in_process_stack_dumping, std::<span class="hljs-built_in">move</span>(tracing));<br><br>  g_default_platform = g_platform.<span class="hljs-built_in">get</span>();<br><br>  <span class="hljs-comment">// init platform</span><br>  v8::V8::<span class="hljs-built_in">InitializePlatform</span>(g_platform.<span class="hljs-built_in">get</span>());<br>  v8::V8::<span class="hljs-built_in">Initialize</span>();<br><br>  <span class="hljs-comment">// set natives_blob / snapshot_blob file path.</span><br>  <span class="hljs-comment">// you can use InitializeExternalStartupData(const char* natives_blob, const char* snapshot_blob)</span><br>  v8::V8::<span class="hljs-built_in">InitializeExternalStartupData</span>(argv[<span class="hljs-number">0</span>]);<br><br>  v8::Isolate::CreateParams create_params;<br>  create_params.array_buffer_allocator =<br>        v8::ArrayBuffer::Allocator::<span class="hljs-built_in">NewDefaultAllocator</span>();<br>  v8::Isolate* isolate = v8::Isolate::<span class="hljs-built_in">New</span>(create_params);<br>  &#123;<br>      <span class="hljs-function">v8::HandleScope <span class="hljs-title">scope</span><span class="hljs-params">(isolate)</span></span>;<br><br>      <span class="hljs-comment">// start v8 trace</span><br>      v8::platform::tracing::TraceConfig* trace_config;<br>      trace_config =<br>            v8::platform::tracing::TraceConfig::<span class="hljs-built_in">CreateDefaultTraceConfig</span>();<br>      tracing_controller-&gt;<span class="hljs-built_in">StartTracing</span>(trace_config);<br><br>      v8::Local&lt;v8::Context&gt; context = v8::Context::<span class="hljs-built_in">New</span>(isolate);<br>      v8::<span class="hljs-function">Context::Scope <span class="hljs-title">context_scope</span><span class="hljs-params">(context)</span></span>;<br>      v8::Local&lt;v8::String&gt; source =<br>      v8::String::<span class="hljs-built_in">NewFromUtf8</span>(isolate,<br>          <span class="hljs-string">&quot;function add(a, b)&#123;return a+b;&#125; add(1,1);&quot;</span>,<br>          v8::NewStringType::kNormal)<br>          .<span class="hljs-built_in">ToLocalChecked</span>();<br><br>      v8::Local&lt;v8::Script&gt; script = v8::Script::<span class="hljs-built_in">Compile</span>(context, source).<span class="hljs-built_in">ToLocalChecked</span>();<br>      v8::Local&lt;v8::Value&gt; result = script-&gt;<span class="hljs-built_in">Run</span>(context).<span class="hljs-built_in">ToLocalChecked</span>();<br>      <span class="hljs-keyword">if</span> (result-&gt;<span class="hljs-built_in">IsNumber</span>()) &#123;<br>        std::cout &lt;&lt; v8::Int32::<span class="hljs-built_in">Cast</span>(*result)-&gt;<span class="hljs-built_in">Value</span>() &lt;&lt;<span class="hljs-string">&quot;\n&quot;</span>;<br>      &#125;<br>  &#125;<br>  isolate-&gt;<span class="hljs-built_in">Dispose</span>();<br><br>  v8::V8::<span class="hljs-built_in">Dispose</span>();<br>  v8::V8::<span class="hljs-built_in">ShutdownPlatform</span>();<br><br>  <span class="hljs-comment">// Delete the platform explicitly here to write the tracing output to the</span><br>  <span class="hljs-comment">// tracing file.</span><br>  g_platform.<span class="hljs-built_in">reset</span>();<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br>&#125;  <span class="hljs-comment">// namespace demo</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>* argv[])</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> demo::<span class="hljs-built_in">Main</span>(argc, argv);<br>&#125;<br></code></pre></td></tr></table></figure><p>最终执行结果打印输出为2：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ruby">lyg<span class="hljs-variable">@lyg</span>-ThinkCentre-M8600t-<span class="hljs-variable constant_">N000</span><span class="hljs-symbol">:/win/code/v8-pc/v8/out</span>.gn/x64.release<span class="hljs-variable">$ </span>./demo <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>同时也生成了v8_trace.json文件，这个是记录v8引擎执行时间片段的，可以用浏览器打开</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ruby">lyg<span class="hljs-variable">@lyg</span>-ThinkCentre-M8600t-<span class="hljs-variable constant_">N000</span><span class="hljs-symbol">:/win/code/v8-pc/v8/out</span>.gn/x64.release<span class="hljs-variable">$ </span>ls v8_trace.json<br>v8_trace.json<br></code></pre></td></tr></table></figure><p>trace打开如图：<br><img src="/2022/05/04/V8%E6%8E%A5%E5%8F%A3%E6%8C%87%E5%8D%97-NewDefaultPlatform/t.jpg"></p><p>同步知乎：<a href="https://zhuanlan.zhihu.com/p/166679160">https://zhuanlan.zhihu.com/p/166679160</a></p>]]></content>
    
    
    <categories>
      
      <category>V8</category>
      
    </categories>
    
    
    <tags>
      
      <tag>指南</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript 引擎 V8 执行流程概述</title>
    <link href="/2022/05/04/JavaScript-%E5%BC%95%E6%93%8E-V8-%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E6%A6%82%E8%BF%B0/"/>
    <url>/2022/05/04/JavaScript-%E5%BC%95%E6%93%8E-V8-%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E6%A6%82%E8%BF%B0/</url>
    
    <content type="html"><![CDATA[<p>本文主要讲解的是V8的技术，是V8的入门篇，主要目的是了解V8的内部机制，希望对前端，快应用，浏览器，以及nodejs同学有些帮助。这里不涉及到如何编写优秀的前端，只是对JS内部引擎技术的讲解。</p><h2 id="一-V8来源"><a href="#一-V8来源" class="headerlink" title="一.V8来源"></a>一.V8来源</h2><p><img src="/2022/05/04/JavaScript-%E5%BC%95%E6%93%8E-V8-%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E6%A6%82%E8%BF%B0/v8.jpg"><br>V8的名字来源于汽车的“V型8缸发动机”（V8发动机）。V8发动机主要是美国发展起来，因为马力十足而广为人知。V8引擎的命名是Google向用户展示它是一款强力并且高速的JavaScript引擎。</p><p>V8未诞生之前，早期主流的JavaScript引擎是JavaScriptCore引擎。JavaScriptCore是主要服务于Webkit浏览器内核，他们都是由苹果公司开发并开源出来。据说Google是不满意JavaScriptCore和Webkit的开发速度和运行速度，Google另起炉灶开发全新的JavaScript引擎和浏览器内核引擎，所以诞生了V8和Chromium两大引擎，到现在已经是最受欢迎的浏览器相关软件。</p><h2 id="二-V8的服务对象"><a href="#二-V8的服务对象" class="headerlink" title="二.V8的服务对象"></a>二.V8的服务对象</h2><p>V8是依托Chrome发展起来的，后面确不局限于浏览器内核。发展至今V8应用于很多场景，例如流行的nodejs，weex，快应用，早期的RN。</p><h2 id="三-V8的早期架构"><a href="#三-V8的早期架构" class="headerlink" title="三.V8的早期架构"></a>三.V8的早期架构</h2><p>V8引擎的诞生带着使命而来，就是要在速度和内存回收上进行革命的。JavaScriptCore的架构是采用生成字节码的方式，然后执行字节码。Google觉得JavaScriptCore这套架构不行，生成字节码会浪费时间，不如直接生成机器码快。所以V8在前期的架构设计上是非常激进的，采用了直接编译成机器码的方式。后期的实践证明Google的这套架构速度是有改善，但是同时也造成了内存消耗问题。可以看下V8的初期流程图：<br><img src="/2022/05/04/JavaScript-%E5%BC%95%E6%93%8E-V8-%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E6%A6%82%E8%BF%B0/liucheng.jpg"><br>早期的V8有Full-Codegen和Crankshaft两个编译器。V8 首先用 Full-Codegen把所有的代码都编译一次，生成对应的机器码。JS在执行的过程中，V8内置的Profiler筛选出热点函数并且记录参数的反馈类型，然后交给 Crankshaft 来进行优化。所以Full-Codegen本质上是生成的是未优化的机器码，而Crankshaft生成的是优化过的机器码。</p><h2 id="四-V8早期架构的缺陷"><a href="#四-V8早期架构的缺陷" class="headerlink" title="四.V8早期架构的缺陷"></a>四.V8早期架构的缺陷</h2><p>随着版本的引进，网页的复杂化，V8也渐渐的暴露出了自己架构上的缺陷：</p><p>Full-Codegen编译直接生成机器码，导致内存占用大<br>Full-Codegen编译直接生成机器码，导致编译时间长，导致启动速度慢<br>Crankshaft 无法优化try，catch和finally等关键字划分的代码块<br>Crankshaft新加语法支持，需要为此编写适配不同的Cpu架构代码</p><h2 id="五-V8的现有架构"><a href="#五-V8的现有架构" class="headerlink" title="五.V8的现有架构"></a>五.V8的现有架构</h2><p>为了解决上述缺点，V8采用JavaScriptCore的架构，生成字节码。这里是不是感觉Google又绕回来了。V8采用生成字节码的方式，整体流程如下图：<br><img src="/2022/05/04/JavaScript-%E5%BC%95%E6%93%8E-V8-%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E6%A6%82%E8%BF%B0/l-2.jpg"><br>Ignition是V8的解释器，背后的原始动机是减少移动设备上的内存消耗。在Ignition之前，V8的Full-codegen基线编译器生成的代码通常占据Chrome整体JavaScript堆的近三分之一。这为Web应用程序的实际数据留下了更少的空间。</p><p>Ignition的字节码可以直接用TurboFan生成优化的机器代码，而不必像Crankshaft那样从源代码重新编译。Ignition的字节码在V8中提供了更清晰且更不容易出错的基线执行模型，简化了去优化机制，这是V8 自适应优化的关键特性。最后，由于生成字节码比生成Full-codegen的基线编译代码更快，因此激活Ignition通常会改善脚本启动时间，从而改善网页加载。</p><p>TurboFan是V8的优化编译器，TurboFan项目最初于2013年底启动，旨在解决Crankshaft的缺点。Crankshaft只能优化JavaScript语言的子集。例如，它不是设计用于使用结构化异常处理优化JavaScript代码，即由JavaScript的try，catch和finally关键字划分的代码块。很难在Crankshaft中添加对新语言功能的支持，因为这些功能几乎总是需要为九个支持的平台编写特定于体系结构的代码。<br><strong>采用新架构后的优势</strong><br>不同架构下V8的内存对比，如图：<br><img src="/2022/05/04/JavaScript-%E5%BC%95%E6%93%8E-V8-%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E6%A6%82%E8%BF%B0/y.jpg"><br><strong>结论：</strong>可以明显看出Ignition+TurboFan架构比Full-codegen+Crankshaft架构内存降低一半多。</p><p>不同架构网页速度提升对比，如图：<br><img src="/2022/05/04/JavaScript-%E5%BC%95%E6%93%8E-V8-%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E6%A6%82%E8%BF%B0/y-2.jpg"><br><strong>结论：</strong>可以明显看出Ignition+TurboFan架构比Full-codegen+Crankshaft架构70%网页速度是有提升的。</p><p>接下来我们大致的讲解下现有架构的每个流程：</p><h2 id="六-V8的词法分析和语法分析"><a href="#六-V8的词法分析和语法分析" class="headerlink" title="六.V8的词法分析和语法分析"></a>六.V8的词法分析和语法分析</h2><p>学过编译原理的同学可以知道，JS文件只是一个源码，机器是无法执行的，词法分析就是把源码的字符串分割出来，生成一系列的token，如下图可知不同的字符串对应不同的token类型。<br><img src="/2022/05/04/JavaScript-%E5%BC%95%E6%93%8E-V8-%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E6%A6%82%E8%BF%B0/3.jpg"><br>词法分析完后，接下来的阶段就是进行语法分析。语法分析语法分析的输入就是词法分析的输出，输出是AST抽象语法树。当程序出现语法错误的时候，V8在语法分析阶段抛出异常。<br><img src="/2022/05/04/JavaScript-%E5%BC%95%E6%93%8E-V8-%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E6%A6%82%E8%BF%B0/4.jpg"></p><h2 id="七-V8-AST抽象语法树"><a href="#七-V8-AST抽象语法树" class="headerlink" title="七.V8 AST抽象语法树"></a>七.V8 AST抽象语法树</h2><p>下图是一个add函数的抽象语法树数据结构<br><img src="/2022/05/04/JavaScript-%E5%BC%95%E6%93%8E-V8-%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E6%A6%82%E8%BF%B0/5.jpg"><br>V8 Parse阶段后，接下来就是根据抽象语法树生成字节码。如下图可以看出add函数生成对应的字节码：<br><img src="/2022/05/04/JavaScript-%E5%BC%95%E6%93%8E-V8-%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E6%A6%82%E8%BF%B0/6.jpg"><br>BytecodeGenerator类的作用是根据抽象语法树生成对应的字节码，不同的node会对应一个字节码生成函数，函数开头为Visit****。如下图+号对应的函数字节码生成：<br><img src="/2022/05/04/JavaScript-%E5%BC%95%E6%93%8E-V8-%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E6%A6%82%E8%BF%B0/7.jpg"></p><figure class="highlight c++"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">BytecodeGenerator::VisitArithmeticExpression</span><span class="hljs-params">(BinaryOperation* expr)</span> </span>&#123;<br>  FeedbackSlot slot = <span class="hljs-built_in">feedback_spec</span>()-&gt;<span class="hljs-built_in">AddBinaryOpICSlot</span>();<br>  Expression* subexpr;<br>  Smi* literal;<br>  <br>  <span class="hljs-keyword">if</span> (expr-&gt;<span class="hljs-built_in">IsSmiLiteralOperation</span>(&amp;subexpr, &amp;literal)) &#123;<br>    <span class="hljs-built_in">VisitForAccumulatorValue</span>(subexpr);<br>    <span class="hljs-built_in">builder</span>()-&gt;<span class="hljs-built_in">SetExpressionPosition</span>(expr);<br>    <span class="hljs-built_in">builder</span>()-&gt;<span class="hljs-built_in">BinaryOperationSmiLiteral</span>(expr-&gt;<span class="hljs-built_in">op</span>(), literal,<br>                                         <span class="hljs-built_in">feedback_index</span>(slot));<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    Register lhs = <span class="hljs-built_in">VisitForRegisterValue</span>(expr-&gt;<span class="hljs-built_in">left</span>());<br>    <span class="hljs-built_in">VisitForAccumulatorValue</span>(expr-&gt;<span class="hljs-built_in">right</span>());<br>    <span class="hljs-built_in">builder</span>()-&gt;<span class="hljs-built_in">SetExpressionPosition</span>(expr);  <span class="hljs-comment">//  保存源码位置 用于调试</span><br>    <span class="hljs-built_in">builder</span>()-&gt;<span class="hljs-built_in">BinaryOperation</span>(expr-&gt;<span class="hljs-built_in">op</span>(), lhs, <span class="hljs-built_in">feedback_index</span>(slot)); <span class="hljs-comment">//  生成Add字节码</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述可知有个源码位置记录，然后下图可知源码和字节码位置的对应关系：<br><img src="/2022/05/04/JavaScript-%E5%BC%95%E6%93%8E-V8-%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E6%A6%82%E8%BF%B0/8.jpg"><br>生成字节码，那字节码如何执行的呢？接下来讲解下：</p><h2 id="八-字节码"><a href="#八-字节码" class="headerlink" title="八.字节码"></a>八.字节码</h2><p>首先说下V8字节码：<br>1.每个字节码指定其输入和输出作为寄存器操作数<br>2.Ignition 使用registers寄存器 r0，r1，r2… 和累加器寄存器（accumulator register）<br>3.registers寄存器：函数参数和局部变量保存在用户可见的寄存器中<br>4.累加器：是非用户可见寄存器，用于保存中间结果<br>如下图ADD字节码：<br><img src="/2022/05/04/JavaScript-%E5%BC%95%E6%93%8E-V8-%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E6%A6%82%E8%BF%B0/9.jpg"><br><strong>字节码执行</strong><br>下面一系列图表示每个字节码执行时，对应寄存器和累加器的变化，add函数传入10,20的参数，最终累加器返回的结果是50。<br><img src="/2022/05/04/JavaScript-%E5%BC%95%E6%93%8E-V8-%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E6%A6%82%E8%BF%B0/10.jpg"><br><img src="/2022/05/04/JavaScript-%E5%BC%95%E6%93%8E-V8-%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E6%A6%82%E8%BF%B0/11.jpg"><br><img src="/2022/05/04/JavaScript-%E5%BC%95%E6%93%8E-V8-%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E6%A6%82%E8%BF%B0/12.jpg"><br><img src="/2022/05/04/JavaScript-%E5%BC%95%E6%93%8E-V8-%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E6%A6%82%E8%BF%B0/13.jpg"><br><img src="/2022/05/04/JavaScript-%E5%BC%95%E6%93%8E-V8-%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E6%A6%82%E8%BF%B0/14.jpg"><br><img src="/2022/05/04/JavaScript-%E5%BC%95%E6%93%8E-V8-%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E6%A6%82%E8%BF%B0/15.jpg"><br><img src="/2022/05/04/JavaScript-%E5%BC%95%E6%93%8E-V8-%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E6%A6%82%E8%BF%B0/16.jpg"><br><img src="/2022/05/04/JavaScript-%E5%BC%95%E6%93%8E-V8-%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E6%A6%82%E8%BF%B0/17.jpg"><br>每个字节码对应一个处理函数，字节码处理程序保存的地址在dispatch_table_中。执行字节码时会调用到对应的字节码处理程序进行执行。Interpreter类成员dispatch_table_保存了每个字节码的处理程序地址。<br><img src="/2022/05/04/JavaScript-%E5%BC%95%E6%93%8E-V8-%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E6%A6%82%E8%BF%B0/18.jpg"><br><img src="/2022/05/04/JavaScript-%E5%BC%95%E6%93%8E-V8-%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E6%A6%82%E8%BF%B0/19.jpg"><br>例如ADD字节码对应的处理函数是（当执行ADD字节码时候，会调用InterpreterBinaryOpAssembler类）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-built_in">IGNITION_HANDLER</span>(Add, InterpreterBinaryOpAssembler) &#123;<br>   <span class="hljs-built_in">BinaryOpWithFeedback</span>(&amp;BinaryOpAssembler::Generate_AddWithFeedback);<br>&#125;<br>  <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">BinaryOpWithFeedback</span><span class="hljs-params">(BinaryOpGenerator generator)</span> </span>&#123;<br>    Node* reg_index = <span class="hljs-built_in">BytecodeOperandReg</span>(<span class="hljs-number">0</span>);<br>    Node* lhs = <span class="hljs-built_in">LoadRegister</span>(reg_index);<br>    Node* rhs = <span class="hljs-built_in">GetAccumulator</span>();<br>    Node* context = <span class="hljs-built_in">GetContext</span>();<br>    Node* slot_index = <span class="hljs-built_in">BytecodeOperandIdx</span>(<span class="hljs-number">1</span>);<br>    Node* feedback_vector = <span class="hljs-built_in">LoadFeedbackVector</span>();<br>    <span class="hljs-function">BinaryOpAssembler <span class="hljs-title">binop_asm</span><span class="hljs-params">(state())</span></span>;<br>    Node* result = (binop_asm.*generator)(context, lhs, rhs, slot_index,                            <br>feedback_vector, <span class="hljs-literal">false</span>);<br>    <span class="hljs-built_in">SetAccumulator</span>(result);  <span class="hljs-comment">// 将ADD计算的结果设置到累加器中</span><br>    <span class="hljs-built_in">Dispatch</span>(); <span class="hljs-comment">// 处理下一条字节码</span><br></code></pre></td></tr></table></figure><p>其实到此JS代码就已经执行完成了。在执行过程中，发现有热点函数，V8会启用Turbofan进行优化编译，直接生成机器码。所以接下来讲解下Turbofan优化编译器：<br>##九.Turbofan<br>Turbofan是根据字节码和热点函数反馈类型生成优化后的机器码，Turbofan很多优化过程，基本和编译原理的后端优化差不多，采用的sea-of-node。<br><img src="/2022/05/04/JavaScript-%E5%BC%95%E6%93%8E-V8-%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E6%A6%82%E8%BF%B0/20.jpg"><br>add函数优化：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs JS"><span class="hljs-keyword">function</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">x, y</span>) &#123;<br>  <span class="hljs-keyword">return</span> x+y;<br>&#125;<br><span class="hljs-title function_">add</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);<br>%<span class="hljs-title class_">OptimizeFunctionOnNextCall</span>(add);<br><span class="hljs-title function_">add</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);<br></code></pre></td></tr></table></figure><p>V8是有函数可以直接调用指定优化哪个函数，执行%OptimizeFunctionOnNextCall主动调用Turbofan优化add函数，根据上次调用的参数反馈优化add函数，很明显这次的反馈是整型数，所以turbofan会根据参数是整型数进行优化直接生成机器码，下次函数调用直接调用优化好的机器码。（注意执行V8需要加上 –allow-natives-syntax，OptimizeFunctionOnNextCall为内置函数，只有加上 –allow-natives-syntax，JS才能调用内置函数 ，否则执行会报错）。</p><p>JS的add函数生成对应的机器码如下：<br><img src="/2022/05/04/JavaScript-%E5%BC%95%E6%93%8E-V8-%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E6%A6%82%E8%BF%B0/21.jpg"><br>这里会涉及small interger小整数概念，可以查看这篇文章<a href="https://zhuanlan.zhihu.com/p/82854566">https://zhuanlan.zhihu.com/p/82854566</a></p><p>如果把add函数的传入参数改成字符</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs JS"><span class="hljs-keyword">function</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">x, y</span>) &#123;<br>  <span class="hljs-keyword">return</span> x+y;<br>&#125;<br><span class="hljs-title function_">add</span>(<span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-string">&#x27;2&#x27;</span>);<br>%<span class="hljs-title class_">OptimizeFunctionOnNextCall</span>(add);<br><span class="hljs-title function_">add</span>(<span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-string">&#x27;2&#x27;</span>);<br></code></pre></td></tr></table></figure><p>优化后的add函数生成对应的机器码如下：<br><img src="/2022/05/04/JavaScript-%E5%BC%95%E6%93%8E-V8-%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E6%A6%82%E8%BF%B0/22.jpg"><br>对比上面两图，add函数传入不同的参数，经过优化生成不同的机器码。</p><p>如果传入的是整型，则本质上是直接调用add汇编指令</p><p>如果传入的是字符串，则本质上是调用V8的内置Add函数</p><p>到此V8的整体执行流程就结束了。文章中可能存在理解不正确的地方敬请指出。</p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://v8.dev/docs">https://v8.dev/docs</a><br><a href="https://docs.google.com/presentation/d/1HgDDXBYqCJNasBKBDf9szap1j4q4wnSHhOYpaNy5mHU/edit#slide=id.g17d335048f_1_1105">https://docs.google.com/presentation/d/1HgDDXBYqCJNasBKBDf9szap1j4q4wnSHhOYpaNy5mHU/edit#slide=id.g17d335048f_1_1105</a><br><a href="https://docs.google.com/presentation/d/1Z9iIHojKDrXvZ27gRX51UxHD-bKf1QcPzSijntpMJBM/edit#slide=id.p">https://docs.google.com/presentation/d/1Z9iIHojKDrXvZ27gRX51UxHD-bKf1QcPzSijntpMJBM/edit#slide=id.p</a><br><a href="https://zhuanlan.zhihu.com/p/82854566">https://zhuanlan.zhihu.com/p/82854566</a></p><p>同步知乎：<a href="https://zhuanlan.zhihu.com/p/111386872">https://zhuanlan.zhihu.com/p/111386872</a></p>]]></content>
    
    
    <categories>
      
      <category>V8</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Ignition</tag>
      
      <tag>TurboFan</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>V8 浮点数（float/double）</title>
    <link href="/2022/05/04/V8-%E6%B5%AE%E7%82%B9%E6%95%B0%EF%BC%88float-double%EF%BC%89/"/>
    <url>/2022/05/04/V8-%E6%B5%AE%E7%82%B9%E6%95%B0%EF%BC%88float-double%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>上章说到v8的小整数表示方式，这章讲解下超出小整数是如何表示的。</p><p>V8里有个类是HeapNumber，我们可以看下这个类的英文注释</p><figure class="highlight 1c"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><pre><code class="hljs 1c"><span class="hljs-comment">// The HeapNumber class describes heap allocated numbers that cannot be</span><br><span class="hljs-comment">// represented in a Smi (small integer)</span><br></code></pre></td></tr></table></figure><p>意思就是不能用smi表示的数，都分配在HeapNumber里表示，所以非smi的数是分配在堆里面的。</p><h2 id="HeapNumber的内存结构（64位架构）"><a href="#HeapNumber的内存结构（64位架构）" class="headerlink" title="HeapNumber的内存结构（64位架构）"></a>HeapNumber的内存结构（64位架构）</h2><p><img src="/2022/05/04/V8-%E6%B5%AE%E7%82%B9%E6%95%B0%EF%BC%88float-double%EF%BC%89/%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84.jpg" alt="内存结构"><br>由图可知HeapNumber的size大小是16字节，前8字节是保存map的地址，后8字节是真实的数值（float&#x2F;double）。</p><p>例如：有个HeapNumber 指针是0x244de278df30（注意这里的指针是通过地址-1得来的）。<br><img src="/2022/05/04/V8-%E6%B5%AE%E7%82%B9%E6%95%B0%EF%BC%88float-double%EF%BC%89/1.jpg"></p><h2 id="HeapNumber的源码分析"><a href="#HeapNumber的源码分析" class="headerlink" title="HeapNumber的源码分析"></a>HeapNumber的源码分析</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">HeapNumber</span>: <span class="hljs-keyword">public</span> HeapObject &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-comment">// [value]: number value.</span><br>  <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">double</span> <span class="hljs-title">value</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>  <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">set_value</span><span class="hljs-params">(<span class="hljs-type">double</span> value)</span></span>;<br><br>  <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">uint64_t</span> <span class="hljs-title">value_as_bits</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>  <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">set_value_as_bits</span><span class="hljs-params">(<span class="hljs-type">uint64_t</span> bits)</span></span>;<br><br>  <span class="hljs-built_in">DECL_CAST</span>(HeapNumber)<br><br>  <span class="hljs-function">V8_EXPORT_PRIVATE <span class="hljs-type">void</span> <span class="hljs-title">HeapNumberPrint</span><span class="hljs-params">(std::ostream&amp; os)</span></span>;  <span class="hljs-comment">// NOLINT</span><br>  <span class="hljs-built_in">DECL_VERIFIER</span>(HeapNumber)<br><br>  <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">get_exponent</span><span class="hljs-params">()</span></span>;<br>  <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">get_sign</span><span class="hljs-params">()</span></span>;<br><br>  <span class="hljs-comment">// Layout description.</span><br>  <span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">int</span> kValueOffset = HeapObject::kHeaderSize; <span class="hljs-comment">// 值的偏移，是8</span><br>  <span class="hljs-comment">// IEEE doubles are two 32 bit words.  The first is just mantissa, the second</span><br>  <span class="hljs-comment">// is a mixture of sign, exponent and mantissa. The offsets of two 32 bit</span><br>  <span class="hljs-comment">// words within double numbers are endian dependent and they are set</span><br>  <span class="hljs-comment">// accordingly.</span><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> defined(V8_TARGET_LITTLE_ENDIAN)</span><br>  <span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">int</span> kMantissaOffset = kValueOffset;<br>  <span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">int</span> kExponentOffset = kValueOffset + <span class="hljs-number">4</span>;<br><span class="hljs-meta">#<span class="hljs-keyword">elif</span> defined(V8_TARGET_BIG_ENDIAN)</span><br>  <span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">int</span> kMantissaOffset = kValueOffset + <span class="hljs-number">4</span>;<br>  <span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">int</span> kExponentOffset = kValueOffset;<br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">error</span> Unknown byte ordering</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>  <span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">int</span> kSize = kValueOffset + kDoubleSize; <span class="hljs-comment">// 对象的大小， 其实就是值的偏移+ double类型的大小</span><br>  <span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">uint32_t</span> kSignMask = <span class="hljs-number">0x80000000</span>u;<br>  <span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">uint32_t</span> kExponentMask = <span class="hljs-number">0x7ff00000</span>u;<br>  <span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">uint32_t</span> kMantissaMask = <span class="hljs-number">0xfffff</span>u;<br>  <span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">int</span> kMantissaBits = <span class="hljs-number">52</span>;<br>  <span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">int</span> kExponentBits = <span class="hljs-number">11</span>;<br>  <span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">int</span> kExponentBias = <span class="hljs-number">1023</span>;<br>  <span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">int</span> kExponentShift = <span class="hljs-number">20</span>;<br>  <span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">int</span> kInfinityOrNanExponent =<br>      (kExponentMask &gt;&gt; kExponentShift) - kExponentBias;<br>  <span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">int</span> kMantissaBitsInTopWord = <span class="hljs-number">20</span>;<br>  <span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">int</span> kNonMantissaBitsInTopWord = <span class="hljs-number">12</span>;<br><br> <span class="hljs-keyword">private</span>:<br>  <span class="hljs-built_in">DISALLOW_IMPLICIT_CONSTRUCTORS</span>(HeapNumber);<br>&#125;;<br></code></pre></td></tr></table></figure><p>staticconstint kValueOffset &#x3D; HeapObject::kHeaderSize; 这个kValueOffset 表示了真正数字在内存结构的偏移，值是8。设置和获取浮点数字是都是通过这个偏移进行设置的。</p><p>接下来分析下值value的函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">HeapNumber::value</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">READ_DOUBLE_FIELD</span>(<span class="hljs-keyword">this</span>, kValueOffset); <span class="hljs-comment">// 由上可知kValueOffset的值是8</span><br>&#125;<br></code></pre></td></tr></table></figure><p>READ_DOUBLE_FIELD 是个宏，代码如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> READ_DOUBLE_FIELD(p, offset) \</span><br><span class="hljs-meta">  ReadDoubleValue(FIELD_ADDR_CONST(p, offset))</span><br></code></pre></td></tr></table></figure><p>通过偏移获取对应的地址位置，其实就是 （首地址）+8</p><p>ReadDoubleValue的实现</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">double</span> <span class="hljs-title">ReadDoubleValue</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">void</span>* p)</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">ReadUnalignedValue</span>&lt;<span class="hljs-type">double</span>&gt;(p);<br>&#125;<br><br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> V&gt;<br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> V <span class="hljs-title">ReadUnalignedValue</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">void</span>* p)</span> </span>&#123;<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> !(V8_TARGET_ARCH_MIPS || V8_TARGET_ARCH_MIPS64 || V8_TARGET_ARCH_ARM)</span><br>  <span class="hljs-keyword">return</span> *<span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">const</span> V*&gt;(p);<br><span class="hljs-meta">#<span class="hljs-keyword">else</span>   <span class="hljs-comment">// V8_TARGET_ARCH_MIPS || V8_TARGET_ARCH_MIPS64 || V8_TARGET_ARCH_ARM</span></span><br>  V r;<br>  <span class="hljs-built_in">memmove</span>(&amp;r, p, <span class="hljs-built_in">sizeof</span>(V));<br>  <span class="hljs-keyword">return</span> r;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span>  <span class="hljs-comment">// V8_TARGET_ARCH_MIPS || V8_TARGET_ARCH_MIPS64 || V8_TARGET_ARCH_ARM</span></span><br>&#125;<br></code></pre></td></tr></table></figure><p>上面代码表示：地将p的存值拷贝到变量r里面，则实现了获取浮点数。（x64架构的是强制转换）</p><p>同理，设置浮点型值也是一样的道理。</p><p>同步知乎：<a href="https://zhuanlan.zhihu.com/p/82914271">https://zhuanlan.zhihu.com/p/82914271</a></p>]]></content>
    
    
    <categories>
      
      <category>V8</category>
      
    </categories>
    
    
    <tags>
      
      <tag>float</tag>
      
      <tag>double</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>V8 小整数（smi）和指针</title>
    <link href="/2022/05/04/V8-%E5%B0%8F%E6%95%B4%E6%95%B0%EF%BC%88smi%EF%BC%89%E5%92%8C%E6%8C%87%E9%92%88/"/>
    <url>/2022/05/04/V8-%E5%B0%8F%E6%95%B4%E6%95%B0%EF%BC%88smi%EF%BC%89%E5%92%8C%E6%8C%87%E9%92%88/</url>
    
    <content type="html"><![CDATA[<p>本文是基于64位cpu进行讲解的</p><h2 id="小整数（smi）"><a href="#小整数（smi）" class="headerlink" title="小整数（smi）"></a>小整数（smi）</h2><p><img src="/2022/05/04/V8-%E5%B0%8F%E6%95%B4%E6%95%B0%EF%BC%88smi%EF%BC%89%E5%92%8C%E6%8C%87%E9%92%88/smi.png"><br>如图可知v8的地址低1位是0时，表示的是一个小整数，然后对应的高32位是具体的整数值。</p><p>例如：<br><img src="/2022/05/04/V8-%E5%B0%8F%E6%95%B4%E6%95%B0%EF%BC%88smi%EF%BC%89%E5%92%8C%E6%8C%87%E9%92%88/sim-2.jpg"></p><h2 id="小整数（smi）转换成整数（int）"><a href="#小整数（smi）转换成整数（int）" class="headerlink" title="小整数（smi）转换成整数（int）"></a>小整数（smi）转换成整数（int）</h2><figure class="highlight c++"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">V8_INLINE <span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title">SmiToInt</span><span class="hljs-params">(<span class="hljs-type">const</span> internal::Object* value)</span> </span>&#123;<br>   <span class="hljs-type">int</span> shift_bits = kSmiTagSize + kSmiShiftSize;<br>   <span class="hljs-comment">// Shift down and throw away top 32 bits.</span><br>   <span class="hljs-keyword">return</span> <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">intptr_t</span>&gt;(value) &gt;&gt; shift_bits);<br> &#125;<br></code></pre></td></tr></table></figure><p>注释：kSmiTagSize &#x3D; 1 kSmiShiftSize &#x3D; 31</p><p><strong>原理：将value转换成int，然后右移32位</strong></p><h2 id="整数（int）转换成小整数（smi）"><a href="#整数（int）转换成小整数（smi）" class="headerlink" title="整数（int）转换成小整数（smi）"></a>整数（int）转换成小整数（smi）</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-type">int</span> kSmiShiftSize&gt;</span><br><span class="hljs-function">V8_INLINE internal::Object* <span class="hljs-title">IntToSmi</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span> </span>&#123;<br>  <span class="hljs-type">int</span> smi_shift_bits = kSmiTagSize + kSmiShiftSize;<br>  <span class="hljs-type">uintptr_t</span> tagged_value =<br>      (<span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uintptr_t</span>&gt;(value) &lt;&lt; smi_shift_bits) | kSmiTag;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">reinterpret_cast</span>&lt;internal::Object*&gt;(tagged_value);<br>&#125;<br></code></pre></td></tr></table></figure><p>注释：kSmiTagSize &#x3D; 1 kSmiShiftSize &#x3D; 31</p><p><strong>原理：将value转换成指针，然后左移32位，再转换成Object指针</strong></p><h2 id="V8能表示的最大和最小数"><a href="#V8能表示的最大和最小数" class="headerlink" title="V8能表示的最大和最小数"></a>V8能表示的最大和最小数</h2><p>Smi在 64 位平台上的范围是 -2³¹ 到 2³¹-1（2³¹≈2*10⁹）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">static</span> <span class="hljs-keyword">constexpr</span> Smi* <span class="hljs-type">const</span> kZero = <span class="hljs-literal">nullptr</span>;<br><span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">int</span> kMinValue =<br>    (<span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>&gt;(<span class="hljs-number">-1</span>)) &lt;&lt; (kSmiValueSize - <span class="hljs-number">1</span>);<br><span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">int</span> kMaxValue = -(kMinValue + <span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure><h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><p><img src="/2022/05/04/V8-%E5%B0%8F%E6%95%B4%E6%95%B0%EF%BC%88smi%EF%BC%89%E5%92%8C%E6%8C%87%E9%92%88/f.png"><br>如图可知v8地址低1位值为1时，表示的是个指针对象。</p><p>例如：<br><img src="/2022/05/04/V8-%E5%B0%8F%E6%95%B4%E6%95%B0%EF%BC%88smi%EF%BC%89%E5%92%8C%E6%8C%87%E9%92%88/f-2.jpg"></p><h2 id="地址转换成指针"><a href="#地址转换成指针" class="headerlink" title="地址转换成指针"></a>地址转换成指针</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// Converts an address to a HeapObject pointer.</span><br>  <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> HeapObject* <span class="hljs-title">FromAddress</span><span class="hljs-params">(Address address)</span> </span>&#123;<br>    <span class="hljs-built_in">DCHECK_TAG_ALIGNED</span>(address);<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">reinterpret_cast</span>&lt;HeapObject*&gt;(address + kHeapObjectTag);<br>  &#125;<br></code></pre></td></tr></table></figure><p>注释：kHeapObjectTag &#x3D; 1</p><p><strong>原理：address 加 1，然后强制转换成HeapObject对象</strong></p><h2 id="指针转换成地址"><a href="#指针转换成地址" class="headerlink" title="指针转换成地址"></a>指针转换成地址</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// Returns the address of this HeapObject.</span><br>  <span class="hljs-function"><span class="hljs-keyword">inline</span> Address <span class="hljs-title">address</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">reinterpret_cast</span>&lt;Address&gt;(<span class="hljs-built_in">const_cast</span>&lt;HeapObject*&gt;(<span class="hljs-keyword">this</span>)) -<br>           kHeapObjectTag;<br>  &#125;<br></code></pre></td></tr></table></figure><p>注释：kHeapObjectTag &#x3D; 1</p><p><strong>原理：强制转换成HeapObject对象，再转换成地址， 然后减 1</strong></p><p>同步知乎：<a href="https://zhuanlan.zhihu.com/p/82854566">https://zhuanlan.zhihu.com/p/82854566</a></p>]]></content>
    
    
    <categories>
      
      <category>V8</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Smi</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>V8 Complie详解</title>
    <link href="/2022/05/04/V8-Complie%E8%AF%A6%E8%A7%A3/"/>
    <url>/2022/05/04/V8-Complie%E8%AF%A6%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<p>v8在执行js代码时候，并不是一开始就把所有的js代码进行解析编译，而是把编译js分为Toplevel和非Toplevel两个阶段。</p><p>为什么V8会这样做？ 这样可以加快js启动速度，在启动的时候省去了未执行的函数的编译时间<br><img src="/2022/05/04/V8-Complie%E8%AF%A6%E8%A7%A3/Toplevel.jpg" alt="Toplevel"><br><img src="/2022/05/04/V8-Complie%E8%AF%A6%E8%A7%A3/%E9%9D%9EToplevel.jpg" alt="非Toplevel"><br>如上两图橙色表示就是top level代码，而黄色表示的就是非 top level代码。如此可知add和sub函数都是懒编译生成的，只有在函数真正被调用执行时才会进行编译。</p><h2 id="1-Toplevel编译"><a href="#1-Toplevel编译" class="headerlink" title="1.Toplevel编译"></a>1.Toplevel编译</h2><p>直接解析编译成字节码，调用的编译函数是ComplieToplevel<br><img src="/2022/05/04/V8-Complie%E8%AF%A6%E8%A7%A3/ComplieToplevel%E6%97%B6%E5%BA%8F%E5%9B%BE.jpg" alt="ComplieToplevel时序图"></p><h2 id="2-非Toplevel编译"><a href="#2-非Toplevel编译" class="headerlink" title="2.非Toplevel编译"></a>2.非Toplevel编译</h2><p>只进行语法检查，不会解析成抽象语法树，更不会被编译。只有在函数真正调用的时候才会进行编译。也叫懒编译，调用的编译函数是ComplieLazy<br><img src="/2022/05/04/V8-Complie%E8%AF%A6%E8%A7%A3/ComplieLazy%E6%97%B6%E5%BA%8F.jpg" alt="ComplieLazy时序"></p><h2 id="3-整体时序图"><a href="#3-整体时序图" class="headerlink" title="3.整体时序图"></a>3.整体时序图</h2><p><img src="/2022/05/04/V8-Complie%E8%AF%A6%E8%A7%A3/Complie%E5%BA%8F%E5%9B%BE.jpg" alt="Complie序图"></p><h2 id="4-数据结构"><a href="#4-数据结构" class="headerlink" title="4.数据结构"></a>4.数据结构</h2><p><img src="/2022/05/04/V8-Complie%E8%AF%A6%E8%A7%A3/%E7%BC%96%E8%AF%91%E9%98%B6%E6%AE%B5%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.jpg" alt="编译阶段的数据结构"><br><strong>CompilationJob：</strong>每次编译都会生成一个对应的CompilationJob，CompilationJob包含了ParseInfo和CompilationInfo。CompilationJob是个基类，因为v8有未优化编译和优化编译，未优化编译对应的子类是InterpreterCompilationJob，优化编译对应的子类是PipelineCompilationJob。</p><p>CompilationJob类：</p><figure class="highlight c++"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></div></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// A base class for compilation jobs intended to run concurrent to the main</span><br><span class="hljs-comment">// thread. The job is split into three phases which are called in sequence on</span><br><span class="hljs-comment">// different threads and with different limitations:</span><br><span class="hljs-comment">//  1) PrepareJob:   Runs on main thread. No major limitations.</span><br><span class="hljs-comment">//  2) ExecuteJob:   Runs concurrently. No heap allocation or handle derefs.</span><br><span class="hljs-comment">//  3) FinalizeJob:  Runs on main thread. No dependency changes.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// Each of the three phases can either fail or succeed. The current state of</span><br><span class="hljs-comment">// the job can be checked using &#123;state()&#125;.</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">V8_EXPORT_PRIVATE</span> CompilationJob &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-keyword">enum</span> <span class="hljs-title class_">Status</span> &#123; SUCCEEDED, FAILED &#125;; <span class="hljs-comment">// 编译结果是成功还是失败</span><br>  <span class="hljs-keyword">enum class</span> <span class="hljs-title class_">State</span> &#123; <span class="hljs-comment">// 编译状态</span><br>    kReadyToPrepare,  <span class="hljs-comment">//准备阶段</span><br>    kReadyToExecute,  <span class="hljs-comment">//执行编译阶段</span><br>    kReadyToFinalize,  <span class="hljs-comment">// 编译完成，字节码和数据替换阶段</span><br>    kSucceeded,<br>    kFailed,<br>  &#125;;<br>  <span class="hljs-built_in">CompilationJob</span>(<span class="hljs-type">uintptr_t</span> stack_limit, ParseInfo* parse_info,<br>                 CompilationInfo* compilation_info, <span class="hljs-type">const</span> <span class="hljs-type">char</span>* compiler_name,<br>                 State initial_state = State::kReadyToPrepare);<br>  <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">CompilationJob</span>() &#123;&#125;<br><br>...................<br><br> <span class="hljs-keyword">protected</span>:<br>  <span class="hljs-comment">// Overridden by the actual implementation.</span><br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> Status <span class="hljs-title">PrepareJobImpl</span><span class="hljs-params">(Isolate* isolate)</span> </span>= <span class="hljs-number">0</span>; <span class="hljs-comment">// 子类实现</span><br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> Status <span class="hljs-title">ExecuteJobImpl</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> Status <span class="hljs-title">FinalizeJobImpl</span><span class="hljs-params">(Isolate* isolate)</span> </span>= <span class="hljs-number">0</span>;<br><br> <span class="hljs-keyword">private</span>:<br>  <span class="hljs-comment">// TODO(6409): Remove parse_info once Fullcode and AstGraphBuilder are gone.</span><br>  ParseInfo* parse_info_; <span class="hljs-comment">// 解析信息</span><br>  CompilationInfo* compilation_info_; <span class="hljs-comment">//编译信息</span><br>  base::TimeDelta time_taken_to_prepare_;<br>  base::TimeDelta time_taken_to_execute_;<br>  base::TimeDelta time_taken_to_finalize_;<br>  <span class="hljs-type">const</span> <span class="hljs-type">char</span>* compiler_name_;<br>..................<br>&#125;;<br></code></pre></td></tr></table></figure><p>job生成函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">std::unique_ptr&lt;CompilationJob&gt; <span class="hljs-title">PrepareAndExecuteUnoptimizedCompileJob</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">    ParseInfo* parse_info, FunctionLiteral* literal,</span></span><br><span class="hljs-params"><span class="hljs-function">    AccountingAllocator* allocator)</span> </span>&#123;<br>..........<br>  <span class="hljs-function">std::unique_ptr&lt;CompilationJob&gt; <span class="hljs-title">job</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">      interpreter::Interpreter::NewCompilationJob(parse_info, literal,</span></span><br><span class="hljs-params"><span class="hljs-function">                                                  allocator))</span></span>; <span class="hljs-comment">// 对应生成一个CompilationJob</span><br><br>  <span class="hljs-keyword">if</span> (job-&gt;<span class="hljs-built_in">ExecuteJob</span>() == CompilationJob::SUCCEEDED) &#123;<br>    <span class="hljs-keyword">return</span> job;<br>  &#125;<br>  <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">unique_ptr</span>&lt;CompilationJob&gt;();  <span class="hljs-comment">// Compilation failed, return null.</span><br>&#125;<br></code></pre></td></tr></table></figure><p>InterpreterCompilationJob（普通的编译job）生成函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C+++">CompilationJob* Interpreter::NewCompilationJob(ParseInfo* parse_info,<br>                                               FunctionLiteral* literal,<br>                                               AccountingAllocator* allocator) &#123;<br>  return new InterpreterCompilationJob(parse_info, literal, allocator);<br>&#125;<br></code></pre></td></tr></table></figure><p>PipelineCompilationJob（优化编译的job）生成函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">CompilationJob* <span class="hljs-title">Pipeline::NewCompilationJob</span><span class="hljs-params">(Handle&lt;JSFunction&gt; function,</span></span><br><span class="hljs-params"><span class="hljs-function">                                            <span class="hljs-type">bool</span> has_script)</span> </span>&#123;<br>  Handle&lt;SharedFunctionInfo&gt; shared = <span class="hljs-built_in">handle</span>(function-&gt;<span class="hljs-built_in">shared</span>());<br>  ParseInfo* parse_info;<br>  <span class="hljs-keyword">if</span> (!has_script) &#123;<br>    parse_info = ParseInfo::<span class="hljs-built_in">AllocateWithoutScript</span>(shared);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    parse_info = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ParseInfo</span>(shared);<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">PipelineCompilationJob</span>(parse_info, shared, function);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>ParseInfo：</strong>主要是包含了词法解析后的生成的FunctionLiteral（抽象语法树的函数顶点，基类是ast）</p><p><strong>CompilationInfo：</strong>主要是包含了对应的js函数的Code（这里指的是一个函数地址）和字节码。</p><p><strong>SharedFunctionInfo：</strong>每个js函数对应一个SharedFunctionInfo。保存着对应函数的字节码和Code（这里指的是一个函数地址，这里主要用来执行，或者懒编译的），判断这个js函数是否被编译，就是根据这个Code地址是否是Generate_CompileLazy来判断的，如下函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">SharedFunctionInfo::is_compiled</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>  Builtins* builtins = <span class="hljs-built_in">GetIsolate</span>()-&gt;<span class="hljs-built_in">builtins</span>();<br>  <span class="hljs-built_in">DCHECK</span>(<span class="hljs-built_in">code</span>() != builtins-&gt;<span class="hljs-built_in">builtin</span>(Builtins::kCheckOptimizationMarker));<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">code</span>() != builtins-&gt;<span class="hljs-built_in">builtin</span>(Builtins::kCompileLazy); <span class="hljs-comment">// 获取CompileLazy内置函数地址，其实就是Generate_CompileLazy</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="5-懒编译触发"><a href="#5-懒编译触发" class="headerlink" title="5.懒编译触发"></a>5.懒编译触发</h2><p><img src="/2022/05/04/V8-Complie%E8%AF%A6%E8%A7%A3/liucheng.jpg"><br>如图可知，js通过toplevel编译后生成对应的两个函数的SharedFunctionInfo。js在执行add和sub函数时候，是在调用Code地址，因为此时函数未编译，所以Code保存的是Generate_CompileLazy地址，所以会调用到Generate_CompileLazy函数（懒编译函数）。懒编译结束后，SharedFunctionInfo结构里的Code变成Generate_InterpreterEntryTrampoline，并且对应的字节码已经生成，最终函数调用的是Generate_InterpreterEntryTrampoline地址，所以到此才是真正执行程序。</p><p>在new SharedFunctionInfo时候Code的的值就是Generate_CompileLazy</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">Handle&lt;SharedFunctionInfo&gt; <span class="hljs-title">Factory::NewSharedFunctionInfoForLiteral</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">    FunctionLiteral* literal, Handle&lt;Script&gt; script)</span> </span>&#123;<br>  Handle&lt;Code&gt; code = <span class="hljs-built_in">BUILTIN_CODE</span>(<span class="hljs-built_in">isolate</span>(), CompileLazy); <span class="hljs-comment">// 获取Generate_CompileLazy的代码地址</span><br>  <span class="hljs-function">Handle&lt;ScopeInfo&gt; <span class="hljs-title">scope_info</span><span class="hljs-params">(ScopeInfo::Empty(isolate()))</span></span>;<br>  Handle&lt;SharedFunctionInfo&gt; result =<br>      <span class="hljs-built_in">NewSharedFunctionInfo</span>(literal-&gt;<span class="hljs-built_in">name</span>(), literal-&gt;<span class="hljs-built_in">kind</span>(), code, scope_info);<br>  SharedFunctionInfo::<span class="hljs-built_in">InitFromFunctionLiteral</span>(result, literal);<br>  SharedFunctionInfo::<span class="hljs-built_in">SetScript</span>(result, script, <span class="hljs-literal">false</span>);<br>  <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><p>设置Code为Generate_InterpreterEntryTrampoline的函数（即就是函数编译任务结束后）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">InterpreterCompilationJob::Status <span class="hljs-title">InterpreterCompilationJob::FinalizeJobImpl</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">    Isolate* isolate)</span> </span>&#123;<br>........<br>  <span class="hljs-built_in">compilation_info</span>()-&gt;<span class="hljs-built_in">SetBytecodeArray</span>(bytecodes); <span class="hljs-comment">// 设置字节码到CompilationInfo里</span><br>  <span class="hljs-built_in">compilation_info</span>()-&gt;<span class="hljs-built_in">SetCode</span>(<br>      <span class="hljs-built_in">BUILTIN_CODE</span>(isolate, InterpreterEntryTrampoline)); <span class="hljs-comment">// 设置Code为Generate_InterpreterEntryTrampoline</span><br><br>  <span class="hljs-keyword">return</span> SUCCEEDED;<br>&#125;<br></code></pre></td></tr></table></figure><p>同步知乎：<a href="https://zhuanlan.zhihu.com/p/82329212">https://zhuanlan.zhihu.com/p/82329212</a></p>]]></content>
    
    
    <categories>
      
      <category>V8</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Complie</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>V8 内置函数用CodeStubAssembler写法介绍</title>
    <link href="/2022/05/04/V8-%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0%E7%94%A8CodeStubAssembler%E5%86%99%E6%B3%95%E4%BB%8B%E7%BB%8D/"/>
    <url>/2022/05/04/V8-%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0%E7%94%A8CodeStubAssembler%E5%86%99%E6%B3%95%E4%BB%8B%E7%BB%8D/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文主要翻译用V8 内置函数用CodeStubAssembler写法介绍，翻译的不好多多指教，原英文链接<a href="https://v8.dev/docs/csa-builtins">https://v8.dev/docs/csa-builtins</a></p><h2 id="Builtins"><a href="#Builtins" class="headerlink" title="Builtins"></a>Builtins</h2><p>在V8中，builtins可以看作是VM在运行时可执行的代码块。常见的例子是实现内置对象（如RegExp或Promise）的功能，内置函数也可用于提供其他内部功能（例如作为IC的一部分）</p><p>V8的builtins可以使用多种不同的方法实现（每种方法都有不同的权衡），如以下4种方式：</p><p>1.Platform-dependent assembly language:很高效，但需要手动适配到所有平台，并且难以维护。</p><p>2.C++:风格与runtime functions非常相似，可以访问V8强大的运行时功能，但通常不适合性能敏感区域</p><p>3.JavaScript:简洁易读的代码，访问快速内在函数，但频繁使用慢速运行时调用，受到类型污染的不可预测的性能，以及（复杂的和非显而易见的）JS语义的问题。</p><p>4.CodeStubAssembler:提供高效的低级功能，非常接近汇编语言，同时保持platform-independent和可读性。（这个也是本章详细讲解的）</p><p>V8的CodeStubAssembler是一个定制的，与平台无关的汇编程序，它提供低级原语作为汇编的精简抽象，但也提供了一个扩展的高级功能库。</p><figure class="highlight c++"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// Low-level:</span><br><span class="hljs-comment">// Loads the pointer-sized data at addr into value.</span><br>Node* addr = <span class="hljs-comment">/* ... */</span>;<br>Node* value = <span class="hljs-built_in">Load</span>(MachineType::<span class="hljs-built_in">IntPtr</span>(), addr);<br><br><span class="hljs-comment">// And high-level:</span><br><span class="hljs-comment">// Performs the JS operation ToString(object).</span><br><span class="hljs-comment">// ToString semantics are specified at https://tc39.github.io/ecma262/#sec-tostring.</span><br>Node* object = <span class="hljs-comment">/* ... */</span>;<br>Node* string = <span class="hljs-built_in">ToString</span>(context, object);<br></code></pre></td></tr></table></figure><p>CSA内置运行部分TurboFan编译管道（包括块调度和寄存器分配，特别是不通过优化传递），然后发出最终的可执行代码。</p><h2 id="Writing-a-CodeStubAssembler-builtin"><a href="#Writing-a-CodeStubAssembler-builtin" class="headerlink" title="Writing a CodeStubAssembler builtin"></a>Writing a CodeStubAssembler builtin</h2><p>在本节中，我们将编写一个简单的CSA内置函数，它接受一个参数，并返回它是否等于数字42。内置函数通过将它放在Math对象上而暴露给JS：</p><p>这个案例展示了以下技术：</p><p>1.使用JavaScript链接创建内置的CSA，可以像JS函数一样调用。</p><p>2.使用CSA实现简单逻辑：Smi和堆数处理，条件和对TFS内置的调用。</p><p>3.使用CSA变量。</p><p>4.存放在Math对象上的CSA。</p><h2 id="Declaring-MathIs42"><a href="#Declaring-MathIs42" class="headerlink" title="Declaring MathIs42"></a>Declaring MathIs42</h2><p>Builtins在src&#x2F;builtins&#x2F;builtins-definitions.h中的BUILTIN_LIST_BASE宏中声明。要使用JS linkage和一个名为X的参数创建新的CSA内置：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> BUILTIN_LIST_BASE(CPP, API, TFJ, TFC, TFS, TFH, ASM, DBG)              \</span><br><span class="hljs-meta">  <span class="hljs-comment">// […snip…]</span></span><br>  <span class="hljs-built_in">TFJ</span>(MathIs42, <span class="hljs-number">1</span>, kX)                                                         \<br>  <span class="hljs-comment">// […snip…]</span><br></code></pre></td></tr></table></figure><p>请注意，BUILTIN_LIST_BASE采用几个不同的宏来表示不同的内置类型。 CSA内置的具体类型分为：</p><p>TFJ: JavaScript linkage.</p><p>TFS: Stub linkage.</p><p>TFC: Stub linkage builtin requiring a custom interface descriptor (e.g. if arguments are untagged or need to be passed in specific registers).</p><p>TFH: Specialized stub linkage builtin used for IC handlers.</p><h2 id="Defining-MathIs42"><a href="#Defining-MathIs42" class="headerlink" title="Defining MathIs42"></a>Defining MathIs42</h2><p>内置定义位于src&#x2F;builtins&#x2F;builtins-*-gen.cc文件中，根据不同的类型分为不同的文件。由于我们编写的是一个内置的Math，我们将把我们的定义放入src&#x2F;builtins&#x2F;builtins-math-gen.cc.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// TF_BUILTIN is a convenience macro that creates a new subclass of the given</span><br><span class="hljs-comment">// assembler behind the scenes.</span><br><span class="hljs-built_in">TF_BUILTIN</span>(MathIs42, MathBuiltinsAssembler) &#123;<br>  <span class="hljs-comment">// Load the current function context (an implicit argument for every stub)</span><br>  <span class="hljs-comment">// and the X argument. Note that we can refer to parameters by the names</span><br>  <span class="hljs-comment">// defined in the builtin declaration.</span><br>  Node* <span class="hljs-type">const</span> context = <span class="hljs-built_in">Parameter</span>(Descriptor::kContext);<br>  Node* <span class="hljs-type">const</span> x = <span class="hljs-built_in">Parameter</span>(Descriptor::kX);<br><br>  <span class="hljs-comment">// At this point, x can be basically anything - a Smi, a HeapNumber,</span><br>  <span class="hljs-comment">// undefined, or any other arbitrary JS object. Let’s call the ToNumber</span><br>  <span class="hljs-comment">// builtin to convert x to a number we can use.</span><br>  <span class="hljs-comment">// CallBuiltin can be used to conveniently call any CSA builtin.</span><br>  Node* <span class="hljs-type">const</span> number = <span class="hljs-built_in">CallBuiltin</span>(Builtins::kToNumber, context, x);<br><br>  <span class="hljs-comment">// Create a CSA variable to store the resulting value. The type of the</span><br>  <span class="hljs-comment">// variable is kTagged since we will only be storing tagged pointers in it.</span><br>  <span class="hljs-built_in">VARIABLE</span>(var_result, MachineRepresentation::kTagged);<br><br>  <span class="hljs-comment">// We need to define a couple of labels which will be used as jump targets.</span><br>  <span class="hljs-function">Label <span class="hljs-title">if_issmi</span><span class="hljs-params">(<span class="hljs-keyword">this</span>)</span>, <span class="hljs-title">if_isheapnumber</span><span class="hljs-params">(<span class="hljs-keyword">this</span>)</span>, <span class="hljs-title">out</span><span class="hljs-params">(<span class="hljs-keyword">this</span>)</span></span>;<br><br>  <span class="hljs-comment">// ToNumber always returns a number. We need to distinguish between Smis</span><br>  <span class="hljs-comment">// and heap numbers - here, we check whether number is a Smi and conditionally</span><br>  <span class="hljs-comment">// jump to the corresponding labels.</span><br>  <span class="hljs-built_in">Branch</span>(<span class="hljs-built_in">TaggedIsSmi</span>(number), &amp;if_issmi, &amp;if_isheapnumber);<br><br>  <span class="hljs-comment">// Binding a label begins generating code for it.</span><br>  <span class="hljs-built_in">BIND</span>(&amp;if_issmi);<br>  &#123;<br>    <span class="hljs-comment">// SelectBooleanConstant returns the JS true/false values depending on</span><br>    <span class="hljs-comment">// whether the passed condition is true/false. The result is bound to our</span><br>    <span class="hljs-comment">// var_result variable, and we then unconditionally jump to the out label.</span><br>    var_result.<span class="hljs-built_in">Bind</span>(<span class="hljs-built_in">SelectBooleanConstant</span>(<span class="hljs-built_in">SmiEqual</span>(number, <span class="hljs-built_in">SmiConstant</span>(<span class="hljs-number">42</span>))));<br>    <span class="hljs-built_in">Goto</span>(&amp;out);<br>  &#125;<br><br>  <span class="hljs-built_in">BIND</span>(&amp;if_isheapnumber);<br>  &#123;<br>    <span class="hljs-comment">// ToNumber can only return either a Smi or a heap number. Just to make sure</span><br>    <span class="hljs-comment">// we add an assertion here that verifies number is actually a heap number.</span><br>    <span class="hljs-built_in">CSA_ASSERT</span>(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">IsHeapNumber</span>(number));<br>    <span class="hljs-comment">// Heap numbers wrap a floating point value. We need to explicitly extract</span><br>    <span class="hljs-comment">// this value, perform a floating point comparison, and again bind</span><br>    <span class="hljs-comment">// var_result based on the outcome.</span><br>    Node* <span class="hljs-type">const</span> value = <span class="hljs-built_in">LoadHeapNumberValue</span>(number);<br>    Node* <span class="hljs-type">const</span> is_42 = <span class="hljs-built_in">Float64Equal</span>(value, <span class="hljs-built_in">Float64Constant</span>(<span class="hljs-number">42</span>));<br>    var_result.<span class="hljs-built_in">Bind</span>(<span class="hljs-built_in">SelectBooleanConstant</span>(is_42));<br>    <span class="hljs-built_in">Goto</span>(&amp;out);<br>  &#125;<br><br>  <span class="hljs-built_in">BIND</span>(&amp;out);<br>  &#123;<br>    Node* <span class="hljs-type">const</span> result = var_result.<span class="hljs-built_in">value</span>();<br>    <span class="hljs-built_in">CSA_ASSERT</span>(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">IsBoolean</span>(result));<br>    <span class="hljs-built_in">Return</span>(result);<br>  &#125;<br>&#125;<br>Attaching Math.Is42<br>Builtin objects such as Math are set up mostly in src/bootstrapper.<span class="hljs-built_in">cc</span> (with some setup occurring in .js files). Attaching our <span class="hljs-keyword">new</span> builtin is simple:<br><br><span class="hljs-comment">// Existing code to set up Math, included here for clarity.</span><br>Handle&lt;JSObject&gt; math = factory-&gt;<span class="hljs-built_in">NewJSObject</span>(cons, TENURED);<br>JSObject::<span class="hljs-built_in">AddProperty</span>(global, name, math, DONT_ENUM);<br><span class="hljs-comment">// […snip…]</span><br><span class="hljs-built_in">SimpleInstallFunction</span>(math, <span class="hljs-string">&quot;is42&quot;</span>, Builtins::kMathIs42, <span class="hljs-number">1</span>, <span class="hljs-literal">true</span>);<br></code></pre></td></tr></table></figure><p>现在已经实现了is42，可以从JS调用它：</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">$ out/debug/d8<br>d8&gt; <span class="hljs-built_in">Math</span>.is42(<span class="hljs-number">42</span>);<br><span class="hljs-literal">true</span><br>d8&gt; <span class="hljs-built_in">Math</span>.is42(<span class="hljs-string">&#x27;42.0&#x27;</span>);<br><span class="hljs-literal">true</span><br>d8&gt; <span class="hljs-built_in">Math</span>.is42(<span class="hljs-literal">true</span>);<br><span class="hljs-literal">false</span><br>d8&gt; <span class="hljs-built_in">Math</span>.is42(&#123; valueOf: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-number">42</span> &#125;);<br><span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><h2 id="Defining-and-calling-a-builtin-with-stub-linkage"><a href="#Defining-and-calling-a-builtin-with-stub-linkage" class="headerlink" title="Defining and calling a builtin with stub linkage"></a>Defining and calling a builtin with stub linkage</h2><p>CSA builtins也可以使用Stub linkage创建（而不是像上面在MathIs42中使用的JavaScript linkage）。这些内置函数可用于将常用代码提取到可由多个调用者使用的单独代码对象中，而代码仅生成一次。让我们将处理堆数的代码提取到一个名为MathIsHeapNumber42的单独内置函数中，并从MathIs42中调用它。</p><p>定义和使用TFS存根很容易。声明在src&#x2F;builtins&#x2F;builtins-definitions.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> BUILTIN_LIST_BASE(CPP, API, TFJ, TFC, TFS, TFH, ASM, DBG)              \</span><br><span class="hljs-meta">  <span class="hljs-comment">// […snip…]</span></span><br>  <span class="hljs-built_in">TFS</span>(MathIsHeapNumber42, kX)                                                  \<br>  <span class="hljs-built_in">TFJ</span>(MathIs42, <span class="hljs-number">1</span>, kX)                                                         \<br>  <span class="hljs-comment">// […snip…] </span><br></code></pre></td></tr></table></figure><p>请注意，目前，BUILTIN_LIST_BASE中的顺序很重要。由于MathIs42调用MathIsHeapNumber42，前者需要在后者之后列出。</p><p>定义很简单，在src&#x2F;builtins&#x2F;builtins-math-gen.cc:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// Defining a TFS builtin works exactly the same way as TFJ builtins.</span><br><span class="hljs-built_in">TF_BUILTIN</span>(MathIsHeapNumber42, MathBuiltinsAssembler) &#123;<br>  Node* <span class="hljs-type">const</span> x = <span class="hljs-built_in">Parameter</span>(Descriptor::kX);<br>  <span class="hljs-built_in">CSA_ASSERT</span>(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">IsHeapNumber</span>(x));<br>  Node* <span class="hljs-type">const</span> value = <span class="hljs-built_in">LoadHeapNumberValue</span>(x);<br>  Node* <span class="hljs-type">const</span> is_42 = <span class="hljs-built_in">Float64Equal</span>(value, <span class="hljs-built_in">Float64Constant</span>(<span class="hljs-number">42</span>));<br>  <span class="hljs-built_in">Return</span>(<span class="hljs-built_in">SelectBooleanConstant</span>(is_42));<br>&#125;<br></code></pre></td></tr></table></figure><p>最后，让MathIs42调用MathIsHeapNumber42的内置</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-built_in">TF_BUILTIN</span>(MathIs42, MathBuiltinsAssembler) &#123;<br>  <span class="hljs-comment">// […snip…]</span><br>  <span class="hljs-built_in">BIND</span>(&amp;if_isheapnumber);<br>  &#123;<br>    <span class="hljs-comment">// Instead of handling heap numbers inline, we now call into our new TFS stub.</span><br>    var_result.<span class="hljs-built_in">Bind</span>(<span class="hljs-built_in">CallBuiltin</span>(Builtins::kMathIsHeapNumber42, context, number));<br>    <span class="hljs-built_in">Goto</span>(&amp;out);<br>  &#125;<br>  <span class="hljs-comment">// […snip…]</span><br>&#125;<br></code></pre></td></tr></table></figure><p>为什么要关心TFS内置？为什么不将代码保持内联（或者提取到辅助方法中以获得更好的可读性）？</p><p>一个重要的原因是代码空间：内置函数在编译时生成并包含在V8快照中，因此无条件地占用每个创建的隔离中的（重要）空间。将大量常用代码提取到TFS内置可以快速节省10到100个KB的空间。</p><h2 id="Testing-stub-linkage-builtins"><a href="#Testing-stub-linkage-builtins" class="headerlink" title="Testing stub-linkage builtins"></a>Testing stub-linkage builtins</h2><p>即使我们的新内置函数使用非标准（至少非C ++）调用，也可以为它编写测试用例。可以将以下代码添加到test&#x2F;cctest&#x2F;compiler&#x2F;test-run-stubs.cc以测试所有平台上的内置函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-built_in">TEST</span>(MathIsHeapNumber42) &#123;<br>  HandleAndZoneScope scope;<br>  Isolate* isolate = scope.<span class="hljs-built_in">main_isolate</span>();<br>  Heap* heap = isolate-&gt;<span class="hljs-built_in">heap</span>();<br>  Zone* zone = scope.<span class="hljs-built_in">main_zone</span>();<br><br>  <span class="hljs-function">StubTester <span class="hljs-title">tester</span><span class="hljs-params">(isolate, zone, Builtins::kMathIs42)</span></span>;<br>  Handle&lt;Object&gt; result1 = tester.<span class="hljs-built_in">Call</span>(<span class="hljs-built_in">Handle</span>&lt;Smi&gt;(Smi::<span class="hljs-built_in">FromInt</span>(<span class="hljs-number">0</span>), isolate));<br>  <span class="hljs-built_in">CHECK</span>(result1-&gt;<span class="hljs-built_in">BooleanValue</span>());<br>&#125;<br></code></pre></td></tr></table></figure><p>同步知乎：<a href="https://zhuanlan.zhihu.com/p/54465194">https://zhuanlan.zhihu.com/p/54465194</a></p>]]></content>
    
    
    <categories>
      
      <category>V8</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CodeStubAssembler</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>V8 bindings 设计isolate，context，world，frame之间的关系（翻译）</title>
    <link href="/2022/05/04/V8-bindings-%E8%AE%BE%E8%AE%A1isolate%EF%BC%8Ccontext%EF%BC%8Cworld%EF%BC%8Cframe%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB%EF%BC%88%E7%BF%BB%E8%AF%91%EF%BC%89/"/>
    <url>/2022/05/04/V8-bindings-%E8%AE%BE%E8%AE%A1isolate%EF%BC%8Ccontext%EF%BC%8Cworld%EF%BC%8Cframe%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB%EF%BC%88%E7%BF%BB%E8%AF%91%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近看了下V8 binding相关的技术文档，主要是学习下chrome如何使用V8的isolate和context，所以就看了下英文文档，顺便翻译一下。英文文档链接<a href="https://chromium.googlesource.com/chromium/src/+/master/third_party/blink/renderer/bindings/core/v8/V8BindingDesign.md">https://chromium.googlesource.com/chromium/src/+/master/third_party/blink/renderer/bindings/core/v8/V8BindingDesign.md</a><br>这篇文章主要讲解V8 binding层的架构的几个关键概念，除了DOM wrappers的生命管理周期</p><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><p>1.isolate （隔离）<br>2.Context （上下文）<br>3.Entered context and current context（ 输入上下文和当前上下文）<br>4.World<br>5.A relationship between isolates, contexts, worlds and frames<br>6.DOM wrappers and worlds<br>7.DOM wrappers and contexts</p><h2 id="isolate-（隔离）"><a href="#isolate-（隔离）" class="headerlink" title="isolate （隔离）"></a>isolate （隔离）</h2><p>在V8中一个isolate是V8的一份实例。在blink中isolate和线程是1:1的关系。主线程与一个isolate相关联，一个工作线程与一个隔离相关联，但是也有个例外compositor worker是多个共享一个isolate</p><h2 id="Context-上下文"><a href="#Context-上下文" class="headerlink" title="Context 上下文"></a>Context 上下文</h2><p>Context是V8中全局变量范围的概念。简单的说，一个Window对象对应于一个Context。例如&lt;iframe&gt;和parent frame的有不同的Window对象，所以不同的frame具有不同的Context。由于每个Context创建了自己的全局变量和作用域，因此&lt;iframe&gt;的全局变量和原型链与parent frame的全局变量和原型链是隔离的<br>例子：</p><figure class="highlight html"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><pre><code class="hljs html">// main.html<br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">iframe</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;iframe.html&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">iframe</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">var</span> foo = <span class="hljs-number">1234</span>;</span><br><span class="language-javascript"><span class="hljs-title class_">String</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">substr</span> =</span><br><span class="language-javascript">    <span class="hljs-keyword">function</span> (<span class="hljs-params">position, length</span>) &#123; <span class="hljs-comment">// Hijacks String.prototype.substr</span></span><br><span class="language-javascript">        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(length);</span><br><span class="language-javascript">        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hijacked&quot;</span>;</span><br><span class="language-javascript">    &#125;;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br><br>// iframe.html<br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(foo);  <span class="hljs-comment">// undefined</span></span><br><span class="language-javascript"><span class="hljs-keyword">var</span> bar = <span class="hljs-string">&quot;aaaa&quot;</span>.<span class="hljs-title function_">substr</span>(<span class="hljs-number">0</span>, <span class="hljs-number">2</span>);  <span class="hljs-comment">// Nothing is logged.</span></span><br><span class="language-javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(bar);  <span class="hljs-comment">// &quot;aa&quot;</span></span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>总之，每个frame都有一个Window对象。每个Window对象都有一个Context。每个Context都有自己的全局变量范围和原型链。</p><h2 id="Entered-context-and-current-context"><a href="#Entered-context-and-current-context" class="headerlink" title="Entered context and current context"></a>Entered context and current context</h2><p>isolate和Context之间的关系是比较有趣的。一个isolate会在多个frame中执行JavaScripts，每个frame都有自己的context。这个意思就是一个isolate下的Context是会变化的。换句话说，isolate和Context之间的关系是1：N</p><p>这里我们有一个Entered context和current context的概念。要了解差异，您需要了解两种运行时堆栈：</p><p>第一个堆栈是JavaScript函数堆栈。该堆栈由V8管理。当一个函数调用另一个函数时，被调用函数入堆栈。当该函数返回时，该函数从堆栈出栈，然后返回到现在位于堆栈顶部的调用函数。每个函数都有一个相关的Context，我们将当前正在运行的函数的上下文（即，堆栈顶部的函数的上下文）称为current context</p><p>看以下例子：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs html">// main.html<br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">iframe</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;iframe.html&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">iframe</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">var</span> iframe = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&quot;iframe&quot;</span>);</span><br><span class="language-javascript">iframe.<span class="hljs-property">onload</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">    iframe.<span class="hljs-property">contentWindow</span>.<span class="hljs-title function_">func</span>();</span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br><br>// iframe.html<br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">func</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">  ...;</span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>在上面的示例中，在运行func()时，current context指的是&lt;iframe&gt;的context。</p><p>第二个堆栈以更粗糙的粒度运行。该堆栈由V8绑定（而不是V8）管理。当V8绑定调用JavaScript时，V8绑定进入context并将context推送到堆栈。 JavaScript开始在context中运行。当JavaScript完成并且控件返回到V8绑定时，V8绑定会从堆栈中弹出上下文。鉴于V8绑定和V8之间的控制可以嵌套（即，V8绑定调用JavaScript，调用V8绑定，调用另一个JavaScript等），这些context形成堆栈。推送和弹出是由任何V8 API完成的，它采用上下文参数或显式调用v8 :: Context :: Enter()和v8 :: Context :: Exit()。我们将最近输入的context称为Entered context。</p><p>在上面的示例中，在运行func()时，Entered context是main frame的context（而不是&lt;iframe&gt;的context）。</p><p>Entered context是实现HTML规范的条目设置对象的概念。当前上下文是实现HTML规范的现任设置对象的概念。</p><p>总之，Entered context是从中开始当前JavaScript执行的context。current context是当前正在运行的JavaScript函数的context。</p><p>还有另一个称为调试器上下文的特殊上下文。如果调试器处于活动状态，则可以将调试器上下文插入到上下文堆栈中</p><h2 id="World"><a href="#World" class="headerlink" title="World"></a>World</h2><p>World是在Chrome扩展的内容脚本中沙盒DOM wrappers的概念. 这里三种World类型：</p><p>1.main world</p><p>2.isolated world</p><p>3.worker world</p><p>main world用于执行网页的JavaScript脚本</p><p>isolated world用于执行Chrome扩展程序的内容脚本</p><p>主线程的isolate有1个main world和N个isolated worlds</p><p>work thread只有1 worker world ，但是没有isolated world</p><p>下图有助于理解他们之间的关系<br><img src="/2022/05/04/V8-bindings-%E8%AE%BE%E8%AE%A1isolate%EF%BC%8Ccontext%EF%BC%8Cworld%EF%BC%8Cframe%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB%EF%BC%88%E7%BF%BB%E8%AF%91%EF%BC%89/world%E5%85%B3%E7%B3%BB%E5%9B%BE.jpg" alt="world关系图"><br>一个isolate中的所有Worlds共享底层C ++ DOM对象，但每个World都有自己的DOM wrappers 。这样一个隔离区中的世界可以在相同的C ++ DOM对象上运行，而无需在World中共享任何DOM wrapper</p><p>每个World都有自己的上下文。这意味着每个World都有自己的全局变量范围和原型链</p><p>作为沙盒的结果，一个isolate中的World不能共享任何DOM wrappers 或上下文，但可以共享底层C ++ DOM对象。没有共享DOM wrappers 或上下文这一事实意味着World之间不会共享任何JavaScript对象。这样我们就可以保证Chrome扩展在共享底层C ++ DOM对象时不共享任何JavaScript对象的安全模型。此沙箱允许Chrome扩展在共享DOM结构上运行不受信任的JavaScripts。</p><p>（注意： isolated world是V8绑定的概念，而isolate和上下文是V8的概念.V8不知道isolated worlds 是什么。）</p><p>总之，主线程的isolate由1个main world和N 个isolated worlds组成。worker thread的isolate 由1个 worker world 和 0 isolated world组成。一个隔离中的所有World共享底层的C ++ DOM对象，但每个World都有自己的DOM wrappers。每个World都有自己的上下文，因此有自己的全局变量范围和原型链。</p><h2 id="isolates-contexts-worlds-and-frames-之间的关系"><a href="#isolates-contexts-worlds-and-frames-之间的关系" class="headerlink" title="isolates, contexts, worlds and frames 之间的关系"></a>isolates, contexts, worlds and frames 之间的关系</h2><p>总结一下isolates，contexts，worlds 和frames之间的关系：</p><p><strong>DOM端的要求，一个HTML页面具有N个frame。每个frame都有自己的context</strong></p><p><strong>JavaScript端的要求，一个isolate具有M个world。每个world都有context</strong><br>结果，当我们执行涉及N Frame 和M个world的主线程时，存在N * M个上下文。换句话说，为每对（frame，world）创建一个上下文。下图有助于理解这种关系：<br><img src="/2022/05/04/V8-bindings-%E8%AE%BE%E8%AE%A1isolate%EF%BC%8Ccontext%EF%BC%8Cworld%EF%BC%8Cframe%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB%EF%BC%88%E7%BF%BB%E8%AF%91%EF%BC%89/frame-Context-world.jpg" alt="frame，Context，world之间的关系"><br>主线程一次只能有一个current context，但主线程在其生命周期内可以有N * M个上下文。例如，当主线程使用World Y中的JavaScript在frame X上操作时，当前上下文被设置为（X，Y）对的上下文。主线程的当前上下文在其生命周期中发生变化。</p><p>另一方面，work thread 有0 frame 和1 World。因此，工作线程只有1个context。工作线程的current context永远不会改变。</p><h2 id="DOM-wrappers-and-contexts"><a href="#DOM-wrappers-and-contexts" class="headerlink" title="DOM wrappers and contexts"></a>DOM wrappers and contexts</h2><p>出于兼容性原因，只要底层C ++ DOM对象处于活动状态，我们就需要确保将相同的DOM wrapper 返回给JavaScript。我们不应该为同一个C ++ DOM对象返回不同的DOM包装器。</p><p>以下是代码例子</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs html">var div = document.createElement(&quot;div&quot;);<br>div.foo = 1234;  // expando<br>var p = document.createElement(&quot;p&quot;);<br>p.appendChild(div);<br>div = null;<br>gc();<br>console.log(p.firstChild.foo);  // This should be 1234, not undefined<br></code></pre></td></tr></table></figure><p>要实现只要底层C ++ DOM对象处于活动状态，同一DOM wrapper 返回到JavaScript的语义，我们需要从C ++ DOM对象到DOM包装器的映射。另外，我们需要在每个world中沙箱DOM wrapper 。为了满足这些要求，我们让每个world都拥有一个DOM wrapper 存储，它存储从C ++ DOM对象到该世界中DOM wrapper 的映射。</p><p>因此，我们在一个隔离中有多个DOM wrapper 存储。main World 的映射用ScriptWrappable编写。如果ScriptWrappable :: main_world_wrapper_具有非空值，则它是main World 的C ++ DOM对象的DOM wrapper 。其他world的映射是在DOMWrapperMap中编写的。</p><h2 id="DOM-wrappers-and-contexts-1"><a href="#DOM-wrappers-and-contexts-1" class="headerlink" title="DOM wrappers and contexts"></a>DOM wrappers and contexts</h2><p>创建新的DOM wrapper 时，需要选择创建DOM wrapper 的正确上下文。如果在错误的上下文中创建新的DOM包装器，最终会将JavaScript对象泄漏到其他上下文，这很可能会导致安全问题。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs html">// main.html<br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">iframe</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;iframe.html&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">iframe</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">var</span> iframe = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&quot;iframe&quot;</span>);</span><br><span class="language-javascript">iframe;  <span class="hljs-comment">// The wrapper of the iframe should be created in the context of the main frame.</span></span><br><span class="language-javascript">iframe.<span class="hljs-property">contentDocument</span>;  <span class="hljs-comment">// The wrapper of the document should be created in the context of the iframe.</span></span><br><span class="language-javascript">iframe.<span class="hljs-property">contentDocument</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&quot;click&quot;</span>,</span><br><span class="language-javascript">    <span class="hljs-keyword">function</span> (<span class="hljs-params">event</span>) &#123;  <span class="hljs-comment">// The wrapper of the event should be created in the context of the iframe.</span></span><br><span class="language-javascript">        event.<span class="hljs-property">target</span>;</span><br><span class="language-javascript">    &#125;);</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br><br>// iframe.html<br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>要确保在正确的上下文中创建DOM wrapper ，您需要确保在调用ToV8（）时必须将当前上下文设置为正确的上下文。</p><p>同步知乎：<a href="https://zhuanlan.zhihu.com/p/54135666">https://zhuanlan.zhihu.com/p/54135666</a></p>]]></content>
    
    
    <categories>
      
      <category>V8</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Isolate，</tag>
      
      <tag>Context</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>浏览器内核原理--Chromium Blink Html解析(2)</title>
    <link href="/2022/05/04/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%86%85%E6%A0%B8%E5%8E%9F%E7%90%86-Chromium-Blink-Html%E8%A7%A3%E6%9E%90-2/"/>
    <url>/2022/05/04/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%86%85%E6%A0%B8%E5%8E%9F%E7%90%86-Chromium-Blink-Html%E8%A7%A3%E6%9E%90-2/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>上一章节讲到html标签解析生成AtomicHTMLToken。这一章节主要讲解AtomicHTMLToken到生成HtmlElement</p><h2 id="AtomicHTMLToken概念"><a href="#AtomicHTMLToken概念" class="headerlink" title="AtomicHTMLToken概念"></a>AtomicHTMLToken概念</h2><figure class="highlight c++"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">CORE_EXPORT</span> AtomicHTMLToken &#123;<br>......<br><br> <span class="hljs-keyword">private</span>:<br>  HTMLToken::TokenType type_;<br><br>  <span class="hljs-comment">// &quot;name&quot; for DOCTYPE, StartTag, and EndTag</span><br>  AtomicString name_;<br><br>  <span class="hljs-comment">// &quot;data&quot; for Comment, &quot;characters&quot; for Character</span><br>  String data_;<br><br>  <span class="hljs-comment">// For DOCTYPE</span><br>  std::unique_ptr&lt;DoctypeData&gt; doctype_data_;<br><br>  <span class="hljs-comment">// For StartTag and EndTag</span><br>  <span class="hljs-type">bool</span> self_closing_;<br><br>  Vector&lt;Attribute&gt; attributes_;<br>&#125;;<br></code></pre></td></tr></table></figure><p>由上可以看到一个标签的AtomicHTMLToken 数据结构：<br>type_ 表示Token类型，有7个类型，下面详细介绍<br>name_ 表示标签的名字，如html，body，div等<br>attributes_表示标签属性，如id，class，style等</p><h2 id="TokenType类型"><a href="#TokenType类型" class="headerlink" title="TokenType类型"></a>TokenType类型</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">TokenType</span> &#123;<br>  kUninitialized,<br>  DOCTYPE,<br>  kStartTag,<br>  kEndTag,<br>  kComment,<br>  kCharacter,<br>  kEndOfFile,<br>&#125;;<br></code></pre></td></tr></table></figure><p>kStartTag是开标签，例如&lt;html&gt;,&lt;body&gt;,&lt;div&gt;,&lt;p&gt;等<br>kEndTag是闭标签，例如&lt;&#x2F;html\&gt;,&lt;&#x2F;body&gt;,&lt;&#x2F;div&gt;,&lt;&#x2F;p&gt;等<br>kComment是注释标签，例如&lt;!-- --&gt;<br>kCharacter是标签内的文本，例如script标签内的文本，style标签内的文本等<br>kEndOfFile是文件结束符</p><h2 id="插入状态"><a href="#插入状态" class="headerlink" title="插入状态"></a>插入状态</h2><p>什么是插入状态？<br>我理解的意思就是在构建dom tree时候，处理不同的Token过程中不同插入状态，其意义就是为了处理标签异常情况。<br>插入有几个状态？</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-string">&quot;initial&quot;</span><span class="hljs-string">&quot;before html&quot;</span>, <span class="hljs-string">&quot;before head&quot;</span>, <span class="hljs-string">&quot;in head&quot;</span>, <span class="hljs-string">&quot;in head noscript&quot;</span>, <span class="hljs-string">&quot;after head&quot;</span>, <span class="hljs-string">&quot;in body&quot;</span>, <span class="hljs-string">&quot;text&quot;</span>, <span class="hljs-string">&quot;in table&quot;</span>, <span class="hljs-string">&quot;in table text&quot;</span>, <span class="hljs-string">&quot;in caption&quot;</span>, <span class="hljs-string">&quot;in column group&quot;</span>, <span class="hljs-string">&quot;in table body&quot;</span>, <span class="hljs-string">&quot;in row&quot;</span>, <span class="hljs-string">&quot;in cell&quot;</span>, <span class="hljs-string">&quot;in select&quot;</span>, <span class="hljs-string">&quot;in select in table&quot;</span>, <span class="hljs-string">&quot;in template&quot;</span>, <span class="hljs-string">&quot;after body&quot;</span>, <span class="hljs-string">&quot;in frameset&quot;</span>, <span class="hljs-string">&quot;after frameset&quot;</span>, <span class="hljs-string">&quot;after after body&quot;</span>, 和<span class="hljs-string">&quot;after after frameset&quot;</span><br></code></pre></td></tr></table></figure><p>总共有23个解析状态，每个状态的意思是一目了然，我就不一一解释了。代码如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">InsertionMode</span> &#123;<br>    kInitialMode,<br>    kBeforeHTMLMode,<br>    kBeforeHeadMode,<br>    kInHeadMode,<br>    kInHeadNoscriptMode,<br>    kAfterHeadMode,<br>    kTemplateContentsMode,<br>    kInBodyMode,<br>    kTextMode,<br>    kInTableMode,<br>    kInTableTextMode,<br>    kInCaptionMode,<br>    kInColumnGroupMode,<br>    kInTableBodyMode,<br>    kInRowMode,<br>    kInCellMode,<br>    kInSelectMode,<br>    kInSelectInTableMode,<br>    kAfterBodyMode,<br>    kInFramesetMode,<br>    kAfterFramesetMode,<br>    kAfterAfterBodyMode,<br>    kAfterAfterFramesetMode,<br>  &#125;;<br></code></pre></td></tr></table></figure><h2 id="处理Token"><a href="#处理Token" class="headerlink" title="处理Token"></a>处理Token</h2><p>不同的Token类型有不同的处理方式</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">HTMLTreeBuilder::ProcessToken</span><span class="hljs-params">(AtomicHTMLToken* token)</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (token-&gt;<span class="hljs-built_in">GetType</span>() == HTMLToken::kCharacter) &#123;<br>    <span class="hljs-built_in">ProcessCharacter</span>(token);<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br><br>  <span class="hljs-comment">// Any non-character token needs to cause us to flush any pending text</span><br>  <span class="hljs-comment">// immediately. <span class="hljs-doctag">NOTE:</span> flush() can cause any queued tasks to execute, possibly</span><br>  <span class="hljs-comment">// re-entering the parser.</span><br>  tree_.<span class="hljs-built_in">Flush</span>(kFlushAlways);<br>  should_skip_leading_newline_ = <span class="hljs-literal">false</span>;<br><br>  <span class="hljs-keyword">switch</span> (token-&gt;<span class="hljs-built_in">GetType</span>()) &#123;<br>    <span class="hljs-keyword">case</span> HTMLToken::kUninitialized:<br>    <span class="hljs-keyword">case</span> HTMLToken::kCharacter:<br>      <span class="hljs-built_in">NOTREACHED</span>();<br>      <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> HTMLToken::DOCTYPE:<br>      <span class="hljs-built_in">ProcessDoctypeToken</span>(token);<br>      <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> HTMLToken::kStartTag:<br>      <span class="hljs-built_in">ProcessStartTag</span>(token);<br>      <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> HTMLToken::kEndTag:<br>      <span class="hljs-built_in">ProcessEndTag</span>(token);<br>      <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> HTMLToken::kComment:<br>      <span class="hljs-built_in">ProcessComment</span>(token);<br>      <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> HTMLToken::kEndOfFile:<br>      <span class="hljs-built_in">ProcessEndOfFile</span>(token);<br>      <span class="hljs-keyword">break</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里举个详细讲解下StartTag处理</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">HTMLTreeBuilder::ProcessStartTag</span><span class="hljs-params">(AtomicHTMLToken* token)</span> </span>&#123;<br>  <span class="hljs-built_in">DCHECK_EQ</span>(token-&gt;<span class="hljs-built_in">GetType</span>(), HTMLToken::kStartTag);<br>  <span class="hljs-keyword">switch</span> (<span class="hljs-built_in">GetInsertionMode</span>()) &#123;<br>    <span class="hljs-keyword">case</span> kInitialMode:<br>      <span class="hljs-built_in">DCHECK_EQ</span>(<span class="hljs-built_in">GetInsertionMode</span>(), kInitialMode);<br>      <span class="hljs-built_in">DefaultForInitial</span>(); <span class="hljs-comment">// 设置插入状态为kBeforeHTMLMode</span><br>    <span class="hljs-comment">// Fall through.</span><br>    <span class="hljs-keyword">case</span> kBeforeHTMLMode:<br>      <span class="hljs-built_in">DCHECK_EQ</span>(<span class="hljs-built_in">GetInsertionMode</span>(), kBeforeHTMLMode);<br>      <span class="hljs-keyword">if</span> (token-&gt;<span class="hljs-built_in">GetName</span>() == htmlTag) &#123; <span class="hljs-comment">// 如果为html开标签则执行如下流程</span><br>        tree_.<span class="hljs-built_in">InsertHTMLHtmlStartTagBeforeHTML</span>(token);  <span class="hljs-comment">// 插入html element</span><br>        <span class="hljs-built_in">SetInsertionMode</span>(kBeforeHeadMode);  <span class="hljs-comment">// 设置插入状态为kBeforeHeadMode</span><br>        <span class="hljs-keyword">return</span>;<br>      &#125;<br>      <span class="hljs-built_in">DefaultForBeforeHTML</span>(); <span class="hljs-comment">// 如果在kBeforeHTMLMode下，token不是html则需要默认插入个html element</span><br>    <span class="hljs-comment">// Fall through.</span><br>    <span class="hljs-keyword">case</span> kBeforeHeadMode:<br>      <span class="hljs-built_in">DCHECK_EQ</span>(<span class="hljs-built_in">GetInsertionMode</span>(), kBeforeHeadMode);<br>      <span class="hljs-keyword">if</span> (token-&gt;<span class="hljs-built_in">GetName</span>() == htmlTag) &#123; <span class="hljs-comment">// 在kBeforeHeadMode状态下如果当前处理的是html开标签</span><br>        <span class="hljs-built_in">ProcessHtmlStartTagForInBody</span>(token); <span class="hljs-comment">// 这里是要处理一些错误的，因为kBeforeHeadMode状态下已经插入html，但是当前的要处理的这个token又是html说明标签有问题</span><br>        <span class="hljs-keyword">return</span>;<br>      &#125;<br>      <span class="hljs-keyword">if</span> (token-&gt;<span class="hljs-built_in">GetName</span>() == headTag) &#123; <span class="hljs-comment">// 在kBeforeHeadMode状态下如果当前处理的是head开标签</span><br>        tree_.<span class="hljs-built_in">InsertHTMLHeadElement</span>(token); <span class="hljs-comment">// 插入head element</span><br>        <span class="hljs-built_in">SetInsertionMode</span>(kInHeadMode); <span class="hljs-comment">// 设置插入状态为kInHeadMode</span><br>        <span class="hljs-keyword">return</span>;<br>      &#125;<br>      <span class="hljs-built_in">DefaultForBeforeHead</span>(); <span class="hljs-comment">// 如果在kBeforeHeadMode下，token都不是html和head，则默认插入一个head element</span><br>    <span class="hljs-comment">// Fall through.</span><br>    <span class="hljs-keyword">case</span> kInHeadMode:<br>      <span class="hljs-built_in">DCHECK_EQ</span>(<span class="hljs-built_in">GetInsertionMode</span>(), kInHeadMode);<br>      <span class="hljs-keyword">if</span> (<span class="hljs-built_in">ProcessStartTagForInHead</span>(token)) <span class="hljs-comment">// 正常处理token</span><br>        <span class="hljs-keyword">return</span>;<br>      <span class="hljs-built_in">DefaultForInHead</span>(); <span class="hljs-comment">// 默认插入一个head闭标签</span><br>    <span class="hljs-comment">// Fall through.</span><br>    <span class="hljs-keyword">case</span> kAfterHeadMode: <span class="hljs-comment">// kAfterHeadMode状态是在endTag处理时候设置的</span><br>      <span class="hljs-built_in">DCHECK_EQ</span>(<span class="hljs-built_in">GetInsertionMode</span>(), kAfterHeadMode);<br>      <span class="hljs-keyword">if</span> (token-&gt;<span class="hljs-built_in">GetName</span>() == htmlTag) &#123; <span class="hljs-comment">// 在kAfterHeadMode状态下如果当前处理的是html开标签</span><br>        <span class="hljs-built_in">ProcessHtmlStartTagForInBody</span>(token);  <span class="hljs-comment">// 这里是要处理一些错误的，因为kAfterHeadMode状态下已经插入html，但是当前的要处理的这个token又是html说明标签有问题</span><br>        <span class="hljs-keyword">return</span>;<br>      &#125;<br>      <span class="hljs-keyword">if</span> (token-&gt;<span class="hljs-built_in">GetName</span>() == bodyTag) &#123; <span class="hljs-comment">// 在kAfterHeadMode状态下如果当前处理的是body开标签</span><br>        frameset_ok_ = <span class="hljs-literal">false</span>;<br>        tree_.<span class="hljs-built_in">InsertHTMLBodyElement</span>(token); <span class="hljs-comment">// 插入body element</span><br>        <span class="hljs-built_in">SetInsertionMode</span>(kInBodyMode); <span class="hljs-comment">// 设置插入状态为kInBodyMode</span><br>        <span class="hljs-keyword">return</span>;<br>      &#125;<br>      <span class="hljs-keyword">if</span> (token-&gt;<span class="hljs-built_in">GetName</span>() == framesetTag) &#123;<br>        tree_.<span class="hljs-built_in">InsertHTMLElement</span>(token);<br>        <span class="hljs-built_in">SetInsertionMode</span>(kInFramesetMode);<br>        <span class="hljs-keyword">return</span>;<br>      &#125;<br>      <span class="hljs-keyword">if</span> (token-&gt;<span class="hljs-built_in">GetName</span>() == baseTag || token-&gt;<span class="hljs-built_in">GetName</span>() == basefontTag ||<br>          token-&gt;<span class="hljs-built_in">GetName</span>() == bgsoundTag || token-&gt;<span class="hljs-built_in">GetName</span>() == linkTag ||<br>          token-&gt;<span class="hljs-built_in">GetName</span>() == metaTag || token-&gt;<span class="hljs-built_in">GetName</span>() == noframesTag ||<br>          token-&gt;<span class="hljs-built_in">GetName</span>() == scriptTag || token-&gt;<span class="hljs-built_in">GetName</span>() == styleTag ||<br>          token-&gt;<span class="hljs-built_in">GetName</span>() == templateTag || token-&gt;<span class="hljs-built_in">GetName</span>() == titleTag) &#123;<br>        <span class="hljs-built_in">ParseError</span>(token);<br>        <span class="hljs-built_in">DCHECK</span>(tree_.<span class="hljs-built_in">Head</span>());<br>        tree_.<span class="hljs-built_in">OpenElements</span>()-&gt;<span class="hljs-built_in">PushHTMLHeadElement</span>(tree_.<span class="hljs-built_in">HeadStackItem</span>());<br>        <span class="hljs-built_in">ProcessStartTagForInHead</span>(token);<br>        tree_.<span class="hljs-built_in">OpenElements</span>()-&gt;<span class="hljs-built_in">RemoveHTMLHeadElement</span>(tree_.<span class="hljs-built_in">Head</span>());<br>        <span class="hljs-keyword">return</span>;<br>      &#125;<br>      <span class="hljs-keyword">if</span> (token-&gt;<span class="hljs-built_in">GetName</span>() == headTag) &#123;<br>        <span class="hljs-built_in">ParseError</span>(token);<br>        <span class="hljs-keyword">return</span>;<br>      &#125;<br>      <span class="hljs-built_in">DefaultForAfterHead</span>();<br>    <span class="hljs-comment">// Fall through</span><br>    <span class="hljs-keyword">case</span> kInBodyMode:<br>      <span class="hljs-built_in">DCHECK_EQ</span>(<span class="hljs-built_in">GetInsertionMode</span>(), kInBodyMode);<br>      <span class="hljs-built_in">ProcessStartTagForInBody</span>(token); <span class="hljs-comment">// 处理token</span><br>      <span class="hljs-keyword">break</span>;<br>..........................................<br>..........以下处理都差不多的逻辑..............<br>..........................................<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>InsertHTMLElement函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">HTMLConstructionSite::InsertHTMLElement</span><span class="hljs-params">(AtomicHTMLToken* token)</span> </span>&#123;<br>  Element* element = <span class="hljs-built_in">CreateElement</span>(token, xhtmlNamespaceURI);<br>  <span class="hljs-built_in">AttachLater</span>(<span class="hljs-built_in">CurrentNode</span>(), element); <span class="hljs-comment">// 设置父节点</span><br>  open_elements_.<span class="hljs-built_in">Push</span>(HTMLStackItem::<span class="hljs-built_in">Create</span>(element, token)); <span class="hljs-comment">// 把htmlElement压入堆中</span><br>&#125;<br></code></pre></td></tr></table></figure><p>open_elements_的类型是HTMLElementStack</p><h2 id="HTMLElementStack讲解"><a href="#HTMLElementStack讲解" class="headerlink" title="HTMLElementStack讲解"></a>HTMLElementStack讲解</h2><p><img src="/2022/05/04/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%86%85%E6%A0%B8%E5%8E%9F%E7%90%86-Chromium-Blink-Html%E8%A7%A3%E6%9E%90-2/HTMLElementStack.jpg" alt="HTMLElementStack"><br>HTMLElementStack是一个栈的数据结构，符合先入后出的方式。HTMLElementStack主要有以下几个数据：<br>1.当前的栈顶元素ElementRecord<br>2.根节点<br>3.head节点<br>4.body节点<br>5.当前的栈深度</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">HTMLElementStack</span> &#123;<br>.......<br> <span class="hljs-keyword">private</span>:<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PushCommon</span><span class="hljs-params">(HTMLStackItem*)</span></span>;<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PushRootNodeCommon</span><span class="hljs-params">(HTMLStackItem*)</span></span>;<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PopCommon</span><span class="hljs-params">()</span></span>;<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">RemoveNonTopCommon</span><span class="hljs-params">(Element*)</span></span>;<br><br>  Member&lt;ElementRecord&gt; top_; <span class="hljs-comment">// 栈顶部元素</span><br><br>  <span class="hljs-comment">// We remember the root node, &lt;head&gt; and &lt;body&gt; as they are pushed. Their</span><br>  <span class="hljs-comment">// ElementRecords keep them alive. The root node is never popped.</span><br>  <span class="hljs-comment">// <span class="hljs-doctag">FIXME:</span> We don&#x27;t currently require type-specific information about these</span><br>  <span class="hljs-comment">// elements so we haven&#x27;t yet bothered to plumb the types all the way down</span><br>  <span class="hljs-comment">// through createElement, etc.</span><br>  Member&lt;ContainerNode&gt; root_node_; <span class="hljs-comment">// 根节点</span><br>  Member&lt;Element&gt; head_element_; <span class="hljs-comment">// head节点</span><br>  Member&lt;Element&gt; body_element_; <span class="hljs-comment">// body节点</span><br>  <span class="hljs-type">unsigned</span> stack_depth_; <span class="hljs-comment">// 栈深度</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>ElementRecord是组成HTMLElementStack栈的成员，ElementRecord的next_保存着前一个压栈的元素，所以这样就构成了栈的数据结构。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ElementRecord</span> <span class="hljs-keyword">final</span> : <span class="hljs-keyword">public</span> GarbageCollected&lt;ElementRecord&gt; &#123;<br>   <span class="hljs-built_in">WTF_MAKE_NONCOPYABLE</span>(ElementRecord);<br><br>  <span class="hljs-keyword">public</span>:<br>   <span class="hljs-function">Element* <span class="hljs-title">GetElement</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> item_-&gt;<span class="hljs-built_in">GetElement</span>(); &#125;<br>   <span class="hljs-function">ContainerNode* <span class="hljs-title">GetNode</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> item_-&gt;<span class="hljs-built_in">GetNode</span>(); &#125;<br>   <span class="hljs-function"><span class="hljs-type">const</span> AtomicString&amp; <span class="hljs-title">NamespaceURI</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> item_-&gt;<span class="hljs-built_in">NamespaceURI</span>(); &#125;<br>   <span class="hljs-function">HTMLStackItem* <span class="hljs-title">StackItem</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> item_; &#125;<br>   <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ReplaceElement</span><span class="hljs-params">(HTMLStackItem*)</span></span>;<br><br>   <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">IsAbove</span><span class="hljs-params">(ElementRecord*)</span> <span class="hljs-type">const</span></span>;<br><br>   <span class="hljs-function">ElementRecord* <span class="hljs-title">Next</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> next_.<span class="hljs-built_in">Get</span>(); &#125;<br><br>   <span class="hljs-built_in">DECLARE_TRACE</span>();<br><br>  <span class="hljs-keyword">private</span>:<br>   <span class="hljs-keyword">friend</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HTMLElementStack</span>;<br><br>   <span class="hljs-built_in">ElementRecord</span>(HTMLStackItem*, ElementRecord*);<br><br>   <span class="hljs-function">ElementRecord* <span class="hljs-title">ReleaseNext</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> next_.<span class="hljs-built_in">Release</span>(); &#125;<br>   <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SetNext</span><span class="hljs-params">(ElementRecord* next)</span> </span>&#123; next_ = next; &#125;<br><br>   Member&lt;HTMLStackItem&gt; item_; <span class="hljs-comment">// 节点信息（记录了node，属性等）</span><br>   Member&lt;ElementRecord&gt; next_; <span class="hljs-comment">// 上一个压栈的Element ，这里就构成了栈的数据结构</span><br> &#125;;<br></code></pre></td></tr></table></figure><h2 id="栈的数据结构变化"><a href="#栈的数据结构变化" class="headerlink" title="栈的数据结构变化"></a>栈的数据结构变化</h2><p>html代码</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><br>        Hello Blink<br>      <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>根据html代码查看栈变化如下图：<br><img src="/2022/05/04/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%86%85%E6%A0%B8%E5%8E%9F%E7%90%86-Chromium-Blink-Html%E8%A7%A3%E6%9E%90-2/%E5%87%BA%E6%A0%88%E5%92%8C%E5%85%A5%E6%A0%88.jpg" alt="出栈和入栈"><br><strong>入栈函数：</strong><br>root，html，head，body，普通标签分别对应不同的入栈函数，主要是为了设置成员变量，代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">HTMLElementStack::PushRootNode</span><span class="hljs-params">(HTMLStackItem* root_item)</span> </span>&#123;<br>  <span class="hljs-built_in">DCHECK</span>(root_item-&gt;<span class="hljs-built_in">IsDocumentFragmentNode</span>());<br>  <span class="hljs-built_in">PushRootNodeCommon</span>(root_item);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">HTMLElementStack::PushHTMLHtmlElement</span><span class="hljs-params">(HTMLStackItem* item)</span> </span>&#123;<br>  <span class="hljs-built_in">DCHECK</span>(item-&gt;<span class="hljs-built_in">HasTagName</span>(htmlTag));<br>  <span class="hljs-built_in">PushRootNodeCommon</span>(item);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">HTMLElementStack::PushRootNodeCommon</span><span class="hljs-params">(HTMLStackItem* root_item)</span> </span>&#123;<br>  <span class="hljs-built_in">DCHECK</span>(!top_);<br>  <span class="hljs-built_in">DCHECK</span>(!root_node_);<br>  root_node_ = root_item-&gt;<span class="hljs-built_in">GetNode</span>();<br>  <span class="hljs-built_in">PushCommon</span>(root_item);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">HTMLElementStack::PushHTMLHeadElement</span><span class="hljs-params">(HTMLStackItem* item)</span> </span>&#123;<br>  <span class="hljs-built_in">DCHECK</span>(item-&gt;<span class="hljs-built_in">HasTagName</span>(HTMLNames::headTag));<br>  <span class="hljs-built_in">DCHECK</span>(!head_element_);<br>  head_element_ = item-&gt;<span class="hljs-built_in">GetElement</span>();<br>  <span class="hljs-built_in">PushCommon</span>(item);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">HTMLElementStack::PushHTMLBodyElement</span><span class="hljs-params">(HTMLStackItem* item)</span> </span>&#123;<br>  <span class="hljs-built_in">DCHECK</span>(item-&gt;<span class="hljs-built_in">HasTagName</span>(HTMLNames::bodyTag));<br>  <span class="hljs-built_in">DCHECK</span>(!body_element_);<br>  body_element_ = item-&gt;<span class="hljs-built_in">GetElement</span>();<br>  <span class="hljs-built_in">PushCommon</span>(item);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">HTMLElementStack::Push</span><span class="hljs-params">(HTMLStackItem* item)</span> </span>&#123;<br>  <span class="hljs-built_in">DCHECK</span>(!item-&gt;<span class="hljs-built_in">HasTagName</span>(htmlTag));<br>  <span class="hljs-built_in">DCHECK</span>(!item-&gt;<span class="hljs-built_in">HasTagName</span>(headTag));<br>  <span class="hljs-built_in">DCHECK</span>(!item-&gt;<span class="hljs-built_in">HasTagName</span>(bodyTag));<br>  <span class="hljs-built_in">DCHECK</span>(root_node_);<br>  <span class="hljs-built_in">PushCommon</span>(item);<br>&#125;<br></code></pre></td></tr></table></figure><p>最终都会调用PushCommon函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">HTMLElementStack::PushCommon</span><span class="hljs-params">(HTMLStackItem* item)</span> </span>&#123;<br>  <span class="hljs-built_in">DCHECK</span>(root_node_);<br><br>  stack_depth_++;<br>  top_ = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ElementRecord</span>(item, top_.<span class="hljs-built_in">Release</span>()); <span class="hljs-comment">//设置栈顶</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>出栈函数：</strong><br>head，body分别对应不同的出栈函数，注意这里没有root和html出栈函数，其实这里不会对html单独出栈的，只有一个PopAll函数进行清空栈。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">HTMLElementStack::PopHTMLHeadElement</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-built_in">DCHECK_EQ</span>(<span class="hljs-built_in">Top</span>(), head_element_);<br>  head_element_ = <span class="hljs-literal">nullptr</span>;<br>  <span class="hljs-built_in">PopCommon</span>();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">HTMLElementStack::PopHTMLBodyElement</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-built_in">DCHECK_EQ</span>(<span class="hljs-built_in">Top</span>(), body_element_);<br>  body_element_ = <span class="hljs-literal">nullptr</span>;<br>  <span class="hljs-built_in">PopCommon</span>();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">HTMLElementStack::PopAll</span><span class="hljs-params">()</span> </span>&#123;<br>  root_node_ = <span class="hljs-literal">nullptr</span>;<br>  head_element_ = <span class="hljs-literal">nullptr</span>;<br>  body_element_ = <span class="hljs-literal">nullptr</span>;<br>  stack_depth_ = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">while</span> (top_) &#123;<br>    Node&amp; node = *<span class="hljs-built_in">TopNode</span>();<br>    <span class="hljs-keyword">if</span> (node.<span class="hljs-built_in">IsElementNode</span>()) &#123;<br>      <span class="hljs-built_in">ToElement</span>(node).<span class="hljs-built_in">FinishParsingChildren</span>();<br>      <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isHTMLSelectElement</span>(node))<br>        <span class="hljs-built_in">ToHTMLFormControlElement</span>(node).<span class="hljs-built_in">SetBlocksFormSubmission</span>(<span class="hljs-literal">true</span>);<br>    &#125;<br>    top_ = top_-&gt;<span class="hljs-built_in">ReleaseNext</span>();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>普通标签的出栈函数，实现原理就是识别到栈内最近的同名标签则停止出栈，例如当前的tag_name标签是Div，则识别到栈内最近的Div标签则停止出栈，这样div开标签和闭标签就会一一对应起来，div下的子节点完毕了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">HTMLElementStack::PopUntil</span><span class="hljs-params">(<span class="hljs-type">const</span> AtomicString&amp; tag_name)</span> </span>&#123;<br>  <span class="hljs-keyword">while</span> (!<span class="hljs-built_in">TopStackItem</span>()-&gt;<span class="hljs-built_in">MatchesHTMLTag</span>(tag_name)) &#123; <span class="hljs-comment">// 是否是同名标签</span><br>    <span class="hljs-comment">// pop() will ASSERT if a &lt;body&gt;, &lt;head&gt; or &lt;html&gt; will be popped.</span><br>    <span class="hljs-built_in">Pop</span>(); <br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>最终都会执行到PopCommon出栈函数，PopCommon函数作用：<br>1.设置栈顶为前一个入栈的元素<br>2.栈深度-1</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">HTMLElementStack::PopCommon</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-built_in">DCHECK</span>(!<span class="hljs-built_in">TopStackItem</span>()-&gt;<span class="hljs-built_in">HasTagName</span>(htmlTag));<br>  <span class="hljs-built_in">DCHECK</span>(!<span class="hljs-built_in">TopStackItem</span>()-&gt;<span class="hljs-built_in">HasTagName</span>(headTag) || !head_element_);<br>  <span class="hljs-built_in">DCHECK</span>(!<span class="hljs-built_in">TopStackItem</span>()-&gt;<span class="hljs-built_in">HasTagName</span>(bodyTag) || !body_element_);<br>  <span class="hljs-built_in">Top</span>()-&gt;<span class="hljs-built_in">FinishParsingChildren</span>();<br>  top_ = top_-&gt;<span class="hljs-built_in">ReleaseNext</span>(); <span class="hljs-comment">// 设置栈顶为前一个入栈的元素</span><br><br>  stack_depth_--; <span class="hljs-comment">// 栈深度-1</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="优化建议"><a href="#优化建议" class="headerlink" title="优化建议"></a>优化建议</h2><p>栈是有深度的，chromium HTMLElementStack栈的深度限制是512，所以标签的嵌套深度不得超过512</p><h2 id="学习建议"><a href="#学习建议" class="headerlink" title="学习建议"></a>学习建议</h2><p>html解析是有一套标准的，可以查看<a href="https://whatwg-cn.github.io/html/">https://whatwg-cn.github.io/html/</a></p><p>同步知乎：<a href="https://zhuanlan.zhihu.com/p/50628909">https://zhuanlan.zhihu.com/p/50628909</a></p>]]></content>
    
    
    <categories>
      
      <category>Chromium</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Parse</tag>
      
      <tag>Token</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>浏览器内核原理--Chromium Blink Html解析</title>
    <link href="/2022/05/04/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%86%85%E6%A0%B8%E5%8E%9F%E7%90%86-Chromium-Blink-Html%E8%A7%A3%E6%9E%90/"/>
    <url>/2022/05/04/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%86%85%E6%A0%B8%E5%8E%9F%E7%90%86-Chromium-Blink-Html%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>HTML文本是怎么解析，这是这章要讲解的内容。我调试的这个版本是没有新起个BackgroundThread解析文本的，所以下面的所有流程都是在blink的主线程执行，文章中涉及很多post task都是在主线程post和执行task的。</p><h2 id="解析数据结构变化"><a href="#解析数据结构变化" class="headerlink" title="解析数据结构变化"></a>解析数据结构变化</h2><p><img src="/2022/05/04/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%86%85%E6%A0%B8%E5%8E%9F%E7%90%86-Chromium-Blink-Html%E8%A7%A3%E6%9E%90/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8F%98%E5%8C%96.jpg" alt="数据结构变化"><br>Html (文本)-&gt; Vecter&lt;char&gt; （多个char数组）-&gt; Deque&lt;SegmentedSubstring&gt; （Deque容器） -&gt; HTMLToken （生成一系列的token） -&gt; CompactHTMLToken （每一个HTMLToken对应一个token） -&gt; TokenizedChunk （多个token组成一个chunk）-&gt; Deque&lt;std::unique_ptr&lt;TokenizedChunk&gt;&gt;（多个chunk写入Deque容器） -&gt;TokenizedChunk-&gt; AtomicHTMLToken （一个CompactHTMLToken转换成AtomicHTMLToken） -&gt; HTMLElement （根据AtomicHTMLToken生成HTMLElement）</p><h2 id="解析步骤"><a href="#解析步骤" class="headerlink" title="解析步骤"></a>解析步骤</h2><p>1.Blink端接收网络端返回的分块数据<br>2.Blink的主线程Post Task BackgroundHTMLParser::AppendRawBytesFromMainThread到当前线程执行解析操作<br>3.进行Decode解码操作，例如UTF-8，Unicode，GB2312等<br>4.解析解码后的文本为一系列的HTMLToken，然后转换成CompactHTMLToken，并保存到TokenizedChunk里<br>5.PostTask任务执行NotifyPendingTokenizedChunks，把解析好的TokenizedChunk传递到Deque&lt;std::unique_ptr&lt;TokenizedChunk&gt;&gt; speculations_。<br>6.PostTask进行唤醒解析调度器执行HTMLParserScheduler::ContinueParsing<br>7.执行ConstructTreeFromCompactHTMLToken根据CompactHTMLToken生成AtomicHTMLToken<br>8.AtomicHTMLToken生成对应的Element</p><h2 id="时序图"><a href="#时序图" class="headerlink" title="时序图"></a>时序图</h2><p><img src="/2022/05/04/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%86%85%E6%A0%B8%E5%8E%9F%E7%90%86-Chromium-Blink-Html%E8%A7%A3%E6%9E%90/%E6%97%B6%E5%BA%8F%E5%9B%BE.jpg" alt="时序图"></p><h3 id="第一步：Blink端接收网络端的分块数据，执行HTMLDocumentParser-AppendByte"><a href="#第一步：Blink端接收网络端的分块数据，执行HTMLDocumentParser-AppendByte" class="headerlink" title="第一步：Blink端接收网络端的分块数据，执行HTMLDocumentParser::AppendByte"></a>第一步：Blink端接收网络端的分块数据，执行HTMLDocumentParser::AppendByte</h3><figure class="highlight c++"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">HTMLDocumentParser::AppendBytes</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* data, <span class="hljs-type">size_t</span> length)</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (!length || <span class="hljs-built_in">IsStopped</span>())<br>    <span class="hljs-keyword">return</span>;<br><br>  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">ShouldUseThreading</span>()) &#123; <span class="hljs-comment">// 这个标志是true，但是并没有创建新的线程，还是在main线程执行</span><br>    <span class="hljs-keyword">if</span> (!have_background_parser_)<br>      <span class="hljs-built_in">StartBackgroundParser</span>();<br><br>    std::unique_ptr&lt;Vector&lt;<span class="hljs-type">char</span>&gt;&gt; buffer =<br>        WTF::MakeUnique&lt;Vector&lt;<span class="hljs-type">char</span>&gt;&gt;(length);<br>    <span class="hljs-built_in">memcpy</span>(buffer-&gt;<span class="hljs-built_in">data</span>(), data, length);  <span class="hljs-comment">// data数据做了个拷贝操作</span><br>    <span class="hljs-built_in">TRACE_EVENT1</span>(<span class="hljs-built_in">TRACE_DISABLED_BY_DEFAULT</span>(<span class="hljs-string">&quot;blink.debug&quot;</span>),<br>                 <span class="hljs-string">&quot;HTMLDocumentParser::appendBytes&quot;</span>, <span class="hljs-string">&quot;size&quot;</span>, (<span class="hljs-type">unsigned</span>)length);<br><br>    loading_task_runner_-&gt;<span class="hljs-built_in">PostTask</span>(<br>        BLINK_FROM_HERE,<br>        WTF::<span class="hljs-built_in">Bind</span>(&amp;BackgroundHTMLParser::AppendRawBytesFromMainThread,<br>                  background_parser_, WTF::<span class="hljs-built_in">Passed</span>(std::<span class="hljs-built_in">move</span>(buffer)))); <span class="hljs-comment">// post task 执行AppendRawBytesFromMainThread</span><br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br><br>  DecodedDataDocumentParser::<span class="hljs-built_in">AppendBytes</span>(data, length);<br>&#125;<br></code></pre></td></tr></table></figure><p>上面代码可以看出，这边首先判断是否启动线程去解析data，这里没搞明白，即使为true也没有创建解析线程，我能想到的是应该是以前的background线程解析代码还没有完全移除完，在共用这段代码。<br>接下这里会做个data数据拷贝操作，就是把data拷贝到std::unique_ptr&lt;Vector<char>&gt;变量上。<br>主线程给自己post task任务，传递的参数就是buffer文本数据。</p><h3 id="第二步：执行任务AppendRawBytesFromMainThread"><a href="#第二步：执行任务AppendRawBytesFromMainThread" class="headerlink" title="第二步：执行任务AppendRawBytesFromMainThread"></a>第二步：执行任务AppendRawBytesFromMainThread</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">BackgroundHTMLParser::AppendRawBytesFromMainThread</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">    std::unique_ptr&lt;Vector&lt;<span class="hljs-type">char</span>&gt;&gt; buffer)</span> </span>&#123;<br>  <span class="hljs-built_in">DCHECK</span>(decoder_);<br>  <span class="hljs-built_in">UpdateDocument</span>(decoder_-&gt;<span class="hljs-built_in">Decode</span>(buffer-&gt;<span class="hljs-built_in">data</span>(), buffer-&gt;<span class="hljs-built_in">size</span>())); <span class="hljs-comment">// 先进行data解码操作</span><br>&#125;<br></code></pre></td></tr></table></figure><p>上面可以看出decoder_-&gt;Decode进行编码解码，把解码后的数据返回。</p><h3 id="第三步：AppendDecodedBytes解码后的数据"><a href="#第三步：AppendDecodedBytes解码后的数据" class="headerlink" title="第三步：AppendDecodedBytes解码后的数据"></a>第三步：AppendDecodedBytes解码后的数据</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">BackgroundHTMLParser::AppendDecodedBytes</span><span class="hljs-params">(<span class="hljs-type">const</span> String&amp; input)</span> </span>&#123;<br>  <span class="hljs-built_in">DCHECK</span>(!input_.<span class="hljs-built_in">Current</span>().<span class="hljs-built_in">IsClosed</span>());<br>  input_.<span class="hljs-built_in">Append</span>(input); <span class="hljs-comment">// 把解码的数据保存到 BackgroundHTMLInputStream</span><br>  <span class="hljs-built_in">PumpTokenizer</span>(); <span class="hljs-comment">// 解析数据</span><br>&#125;<br></code></pre></td></tr></table></figure><p>上面可只主要做两个操作，1.保存解码后的数据 2.解析保存的数据</p><h3 id="第四步：PumpTokenizer解析数据成HTMLToken，然后转换成CompactHTMLToken"><a href="#第四步：PumpTokenizer解析数据成HTMLToken，然后转换成CompactHTMLToken" class="headerlink" title="第四步：PumpTokenizer解析数据成HTMLToken，然后转换成CompactHTMLToken"></a>第四步：PumpTokenizer解析数据成HTMLToken，然后转换成CompactHTMLToken</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">BackgroundHTMLParser::PumpTokenizer</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-built_in">TRACE_EVENT0</span>(<span class="hljs-string">&quot;loading&quot;</span>, <span class="hljs-string">&quot;BackgroundHTMLParser::pumpTokenizer&quot;</span>);<br>  HTMLTreeBuilderSimulator::SimulatedToken simulated_token =<br>      HTMLTreeBuilderSimulator::kOtherToken;<br><br>  <span class="hljs-comment">// No need to start speculating until the main thread has almost caught up.</span><br>  <span class="hljs-keyword">if</span> (input_.<span class="hljs-built_in">TotalCheckpointTokenCount</span>() &gt; outstanding_token_limit_)<br>    <span class="hljs-keyword">return</span>;<br><br>  <span class="hljs-type">bool</span> should_notify_main_thread = <span class="hljs-literal">false</span>;<br>  <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>    <span class="hljs-keyword">if</span> (xss_auditor_-&gt;<span class="hljs-built_in">IsEnabled</span>())<br>      source_tracker_.<span class="hljs-built_in">Start</span>(input_.<span class="hljs-built_in">Current</span>(), tokenizer_.<span class="hljs-built_in">get</span>(), *token_);<br><br>    <span class="hljs-keyword">if</span> (!tokenizer_-&gt;<span class="hljs-built_in">NextToken</span>(input_.<span class="hljs-built_in">Current</span>(), *token_)) &#123; <span class="hljs-comment">// 把解析文本成一个一个的token</span><br>      <span class="hljs-comment">// We&#x27;ve reached the end of our current input.</span><br>      should_notify_main_thread |= <span class="hljs-built_in">QueueChunkForMainThread</span>();<br>      <span class="hljs-keyword">break</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (xss_auditor_-&gt;<span class="hljs-built_in">IsEnabled</span>())<br>      source_tracker_.<span class="hljs-built_in">end</span>(input_.<span class="hljs-built_in">Current</span>(), tokenizer_.<span class="hljs-built_in">get</span>(), *token_);<br><br>    &#123;<br>      TextPosition position = <span class="hljs-built_in">TextPosition</span>(input_.<span class="hljs-built_in">Current</span>().<span class="hljs-built_in">CurrentLine</span>(),<br>                                           input_.<span class="hljs-built_in">Current</span>().<span class="hljs-built_in">CurrentColumn</span>());<br><br>      <span class="hljs-keyword">if</span> (std::unique_ptr&lt;XSSInfo&gt; xss_info =<br>              xss_auditor_-&gt;<span class="hljs-built_in">FilterToken</span>(<span class="hljs-built_in">FilterTokenRequest</span>(<br>                  *token_, source_tracker_, tokenizer_-&gt;<span class="hljs-built_in">ShouldAllowCDATA</span>()))) &#123;<br>        xss_info-&gt;text_position_ = position;<br>        pending_xss_infos_.<span class="hljs-built_in">push_back</span>(std::<span class="hljs-built_in">move</span>(xss_info));<br>      &#125;<br><br>      <span class="hljs-function">CompactHTMLToken <span class="hljs-title">token</span><span class="hljs-params">(token_.get(), position)</span></span>; <span class="hljs-comment">// 将token转换成CompactHTMLToken</span><br><br>      <span class="hljs-type">bool</span> is_csp_meta_tag = <span class="hljs-literal">false</span>;<br>      preload_scanner_-&gt;<span class="hljs-built_in">Scan</span>(token, input_.<span class="hljs-built_in">Current</span>(), pending_preloads_,<br>                             &amp;viewport_description_, &amp;is_csp_meta_tag); <span class="hljs-comment">// 预扫描url</span><br><br>      simulated_token =<br>          tree_builder_simulator_.<span class="hljs-built_in">Simulate</span>(token, tokenizer_.<span class="hljs-built_in">get</span>());<br><br>      <span class="hljs-comment">// Break chunks before a script tag is inserted and flag the chunk as</span><br>      <span class="hljs-comment">// starting a script so the main parser can decide if it should yield</span><br>      <span class="hljs-comment">// before processing the chunk.</span><br>      <span class="hljs-keyword">if</span> (simulated_token == HTMLTreeBuilderSimulator::kScriptStart) &#123;<br>        should_notify_main_thread |= <span class="hljs-built_in">QueueChunkForMainThread</span>();<br>        starting_script_ = <span class="hljs-literal">true</span>;<br>      &#125;<br><br>      pending_tokens_-&gt;<span class="hljs-built_in">push_back</span>(token); <span class="hljs-comment">// 把CompactHTMLToken 存放到Vector&lt;CompactHTMLToken&gt; 数组中</span><br>      <span class="hljs-keyword">if</span> (is_csp_meta_tag) &#123;<br>        pending_csp_meta_token_index_ = pending_tokens_-&gt;<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>      &#125;<br>    &#125;<br><br>    token_-&gt;<span class="hljs-built_in">Clear</span>();<br><br>    <span class="hljs-keyword">if</span> (simulated_token == HTMLTreeBuilderSimulator::kScriptEnd ||<br>        simulated_token == HTMLTreeBuilderSimulator::kStyleEnd ||<br>        simulated_token == HTMLTreeBuilderSimulator::kLink ||<br>        pending_tokens_-&gt;<span class="hljs-built_in">size</span>() &gt;= pending_token_limit_) &#123; <span class="hljs-comment">// 当解析的tokens大于限制的token数，则把 把pending_tokens_的内容传递给MainThread</span><br>      should_notify_main_thread |= <span class="hljs-built_in">QueueChunkForMainThread</span>(); <span class="hljs-comment">// 把pending_tokens_的内容传递给MainThread</span><br>      <span class="hljs-comment">// If we&#x27;re far ahead of the main thread, yield for a bit to avoid</span><br>      <span class="hljs-comment">// consuming too much memory.</span><br>      <span class="hljs-keyword">if</span> (input_.<span class="hljs-built_in">TotalCheckpointTokenCount</span>() &gt; outstanding_token_limit_) <span class="hljs-comment">// 如果主线程积累了超过限制的token没有处理，则停止文本解析</span><br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (!should_coalesce_chunks_ &amp;&amp; should_notify_main_thread) &#123;<br>      <span class="hljs-built_in">RunOnMainThread</span>(&amp;HTMLDocumentParser::NotifyPendingTokenizedChunks,<br>                      parser_); <span class="hljs-comment">// post task 到主线程执行NotifyPendingTokenizedChunks</span><br>      should_notify_main_thread = <span class="hljs-literal">false</span>;<br>    &#125;<br>  &#125;<br>  <span class="hljs-comment">// Wait to notify the main thread about the chunks until we&#x27;re at the limit.</span><br>  <span class="hljs-comment">// This lets the background parser generate lots of valuable preloads before</span><br>  <span class="hljs-comment">// anything expensive (extensions, scripts) take up time on the main thread. A</span><br>  <span class="hljs-comment">// busy main thread can cause preload delays.</span><br>  <span class="hljs-keyword">if</span> (should_notify_main_thread) &#123;<br>    <span class="hljs-built_in">RunOnMainThread</span>(&amp;HTMLDocumentParser::NotifyPendingTokenizedChunks, parser_); <span class="hljs-comment">// post task 到主线程执行NotifyPendingTokenizedChunks</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>由上可知进行以下操作：</p><p>1.执行 tokenizer_-&gt;NextToken 解析成token。<br>2.通过 CompactHTMLToken token(token_.get(), position)把HTMLToken转换成CompactHTMLToken。<br>3.preload_scanner_-&gt;Scan进行预扫描一些link，js，css的链接。（为什么要预扫描，其实是为了在解析的空闲时候，预发起网络请求提前加载子资源）<br>4.pending_tokens_-&gt;size() &gt;&#x3D; pending_token_limit_当解析的tokens大于限制的token数，则把pending_tokens_的内容传递给MainThread。 pending_token_limit_的值是1000<br>5.input_.TotalCheckpointTokenCount() &gt; outstanding_token_limit_如果主线程积累了超过限制的token没有处理，则停止文本解析。outstanding_token_limit_的值是10000，这样做的目的是为了节省内存，太多的Token没有处理生成Element，再解析下去也是没有意义的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">size_t</span> kDefaultOutstandingTokenLimit = <span class="hljs-number">10000</span>;<br><br><span class="hljs-comment">// We limit our chucks to 1000 tokens, to make sure the main thread is never</span><br><span class="hljs-comment">// waiting on the parser thread for tokens. This was tuned in</span><br><span class="hljs-comment">// https://bugs.webkit.org/show_bug.cgi?id=110408.</span><br><span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">size_t</span> kDefaultPendingTokenLimit = <span class="hljs-number">1000</span>;<br></code></pre></td></tr></table></figure><p>6.执行QueueChunkForMainThread，将解析好的pending_tokens_传递到主线程，这里的传递并没有通过函数参数，而是通过一个类的变量进行传递tokenized_chunk_queue_。函数实现如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">BackgroundHTMLParser::QueueChunkForMainThread</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (pending_tokens_-&gt;<span class="hljs-built_in">IsEmpty</span>())<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> DCHECK_IS_ON()</span><br>  <span class="hljs-built_in">CheckThatTokensAreSafeToSendToAnotherThread</span>(pending_tokens_.<span class="hljs-built_in">get</span>());<br>  <span class="hljs-built_in">CheckThatPreloadsAreSafeToSendToAnotherThread</span>(pending_preloads_);<br>  <span class="hljs-built_in">CheckThatXSSInfosAreSafeToSendToAnotherThread</span>(pending_xss_infos_);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>  std::unique_ptr&lt;HTMLDocumentParser::TokenizedChunk&gt; chunk =<br>      WTF::<span class="hljs-built_in">WrapUnique</span>(<span class="hljs-keyword">new</span> HTMLDocumentParser::TokenizedChunk);<br>  <span class="hljs-built_in">TRACE_EVENT_WITH_FLOW0</span>(<span class="hljs-string">&quot;blink,loading&quot;</span>,<br>                         <span class="hljs-string">&quot;BackgroundHTMLParser::sendTokensToMainThread&quot;</span>,<br>                         chunk.<span class="hljs-built_in">get</span>(), TRACE_EVENT_FLAG_FLOW_OUT);<br><br>  chunk-&gt;preloads.<span class="hljs-built_in">swap</span>(pending_preloads_);<br>  <span class="hljs-keyword">if</span> (viewport_description_.set)<br>    chunk-&gt;viewport = viewport_description_;<br>  chunk-&gt;xss_infos.<span class="hljs-built_in">swap</span>(pending_xss_infos_);<br>  chunk-&gt;tokenizer_state = tokenizer_-&gt;<span class="hljs-built_in">GetState</span>();<br>  chunk-&gt;tree_builder_state = tree_builder_simulator_.<span class="hljs-built_in">GetState</span>();<br>  chunk-&gt;input_checkpoint = input_.<span class="hljs-built_in">CreateCheckpoint</span>(pending_tokens_-&gt;<span class="hljs-built_in">size</span>());<br>  chunk-&gt;preload_scanner_checkpoint = preload_scanner_-&gt;<span class="hljs-built_in">CreateCheckpoint</span>();<br>  chunk-&gt;tokens = std::<span class="hljs-built_in">move</span>(pending_tokens_);<br>  chunk-&gt;starting_script = starting_script_;<br>  chunk-&gt;pending_csp_meta_token_index = pending_csp_meta_token_index_;<br>  starting_script_ = <span class="hljs-literal">false</span>;<br>  pending_csp_meta_token_index_ =<br>      HTMLDocumentParser::TokenizedChunk::kNoPendingToken;<br><br>  <span class="hljs-type">bool</span> is_empty = tokenized_chunk_queue_-&gt;<span class="hljs-built_in">Enqueue</span>(std::<span class="hljs-built_in">move</span>(chunk)); <span class="hljs-comment">// chunk存进在tokenized_chunk_queue_队列中</span><br><br>  pending_tokens_ = WTF::<span class="hljs-built_in">WrapUnique</span>(<span class="hljs-keyword">new</span> CompactHTMLTokenStream);<br>  <span class="hljs-keyword">return</span> is_empty;<br>&#125;<br></code></pre></td></tr></table></figure><p>tokenized_chunk_queue_的值是谁设置过来的？其实就是HTMLDocumentParser::tokenized_chunk_queue_</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs C++">BackgroundHTMLParser::<span class="hljs-built_in">BackgroundHTMLParser</span>(<br>    std::unique_ptr&lt;Configuration&gt; config,<br>    RefPtr&lt;WebTaskRunner&gt; loading_task_runner)<br>    : <span class="hljs-built_in">weak_factory_</span>(<span class="hljs-keyword">this</span>),<br>      <span class="hljs-built_in">token_</span>(WTF::<span class="hljs-built_in">WrapUnique</span>(<span class="hljs-keyword">new</span> HTMLToken)),<br>      <span class="hljs-built_in">tokenizer_</span>(HTMLTokenizer::<span class="hljs-built_in">Create</span>(config-&gt;options)),<br>      <span class="hljs-built_in">tree_builder_simulator_</span>(config-&gt;options),<br>      <span class="hljs-built_in">options_</span>(config-&gt;options),<br>      <span class="hljs-built_in">outstanding_token_limit_</span>(config-&gt;outstanding_token_limit),<br>      <span class="hljs-built_in">parser_</span>(config-&gt;parser),<br>      <span class="hljs-built_in">pending_tokens_</span>(WTF::<span class="hljs-built_in">WrapUnique</span>(<span class="hljs-keyword">new</span> CompactHTMLTokenStream)),<br>      <span class="hljs-built_in">pending_token_limit_</span>(config-&gt;pending_token_limit),<br>      <span class="hljs-built_in">xss_auditor_</span>(std::<span class="hljs-built_in">move</span>(config-&gt;xss_auditor)),<br>      <span class="hljs-built_in">decoder_</span>(std::<span class="hljs-built_in">move</span>(config-&gt;decoder)),<br>      <span class="hljs-built_in">loading_task_runner_</span>(std::<span class="hljs-built_in">move</span>(loading_task_runner)),<br>      <span class="hljs-built_in">tokenized_chunk_queue_</span>(std::<span class="hljs-built_in">move</span>(config-&gt;tokenized_chunk_queue)), <span class="hljs-comment">// 设置tokenized_chunk_queue_值</span><br>      <span class="hljs-built_in">pending_csp_meta_token_index_</span>(<br>          HTMLDocumentParser::TokenizedChunk::kNoPendingToken),<br>      <span class="hljs-built_in">starting_script_</span>(<span class="hljs-literal">false</span>),<br>      <span class="hljs-built_in">should_coalesce_chunks_</span>(config-&gt;should_coalesce_chunks) &#123;<br>  <span class="hljs-built_in">DCHECK_GT</span>(outstanding_token_limit_, <span class="hljs-number">0u</span>);<br>  <span class="hljs-built_in">DCHECK_GT</span>(pending_token_limit_, <span class="hljs-number">0u</span>);<br>  <span class="hljs-built_in">DCHECK_GE</span>(outstanding_token_limit_, pending_token_limit_);<br>&#125;<br></code></pre></td></tr></table></figure><p>7.post一个任务NotifyPendingTokenizedChunks，告诉主线程已经解析出来了Tokens</p><h3 id="第五步：执行NotifyPendingTokenizedChunks"><a href="#第五步：执行NotifyPendingTokenizedChunks" class="headerlink" title="第五步：执行NotifyPendingTokenizedChunks"></a>第五步：执行NotifyPendingTokenizedChunks</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">HTMLDocumentParser::NotifyPendingTokenizedChunks</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-built_in">TRACE_EVENT0</span>(<span class="hljs-string">&quot;blink&quot;</span>, <span class="hljs-string">&quot;HTMLDocumentParser::notifyPendingTokenizedChunks&quot;</span>);<br>  <span class="hljs-built_in">DCHECK</span>(tokenized_chunk_queue_);<br><br>  Vector&lt;std::unique_ptr&lt;TokenizedChunk&gt;&gt; pending_chunks;<br>  tokenized_chunk_queue_-&gt;<span class="hljs-built_in">TakeAll</span>(pending_chunks); <span class="hljs-comment">// 取出所有的chunks</span><br><br>  <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">IsParsing</span>())<br>    <span class="hljs-keyword">return</span>;<br><br>  <span class="hljs-comment">// ApplicationCache needs to be initialized before issuing preloads. We</span><br>  <span class="hljs-comment">// suspend preload until HTMLHTMLElement is inserted and ApplicationCache is</span><br>  <span class="hljs-comment">// initialized. Note: link rel preloads don&#x27;t follow this policy per the spec.</span><br>  <span class="hljs-comment">// These directives should initiate a fetch as fast as possible.</span><br>  <span class="hljs-keyword">if</span> (!tried_loading_link_headers_ &amp;&amp; <span class="hljs-built_in">GetDocument</span>()-&gt;<span class="hljs-built_in">Loader</span>() &amp;&amp;<br>      !pending_chunks.<span class="hljs-built_in">IsEmpty</span>()) &#123;<br>    <span class="hljs-comment">// Note that on commit, the loader dispatched preloads for all the non-media</span><br>    <span class="hljs-comment">// links.</span><br>    <span class="hljs-built_in">GetDocument</span>()-&gt;<span class="hljs-built_in">Loader</span>()-&gt;<span class="hljs-built_in">DispatchLinkHeaderPreloads</span>(<br>        &amp;pending_chunks.<span class="hljs-built_in">front</span>()-&gt;viewport, LinkLoader::kOnlyLoadMedia);<br>    tried_loading_link_headers_ = <span class="hljs-literal">true</span>;<br>  &#125;<br><br>  <span class="hljs-comment">// Defer preloads if any of the chunks contains a &lt;meta&gt; csp tag.</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; chunk : pending_chunks) &#123;<br>    <span class="hljs-keyword">if</span> (chunk-&gt;pending_csp_meta_token_index !=<br>        TokenizedChunk::kNoPendingToken) &#123;<br>      pending_csp_meta_token_ =<br>          &amp;chunk-&gt;tokens-&gt;<span class="hljs-built_in">at</span>(chunk-&gt;pending_csp_meta_token_index);<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">if</span> (pending_csp_meta_token_ || !<span class="hljs-built_in">GetDocument</span>()-&gt;<span class="hljs-built_in">documentElement</span>()) &#123;<br>    PreloadRequestStream link_rel_preloads;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; chunk : pending_chunks) &#123;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; request : chunk-&gt;preloads) &#123;<br>        <span class="hljs-comment">// Link rel preloads don&#x27;t need to wait for AppCache but they</span><br>        <span class="hljs-comment">// should probably wait for CSP.</span><br>        <span class="hljs-keyword">if</span> (!pending_csp_meta_token_ &amp;&amp; request-&gt;<span class="hljs-built_in">IsLinkRelPreload</span>())<br>          link_rel_preloads.<span class="hljs-built_in">push_back</span>(std::<span class="hljs-built_in">move</span>(request));<br>        <span class="hljs-keyword">else</span><br>          queued_preloads_.<span class="hljs-built_in">push_back</span>(std::<span class="hljs-built_in">move</span>(request));<br>      &#125;<br>    &#125;<br>    preloader_-&gt;<span class="hljs-built_in">TakeAndPreload</span>(link_rel_preloads);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// We can safely assume that there are no queued preloads request after the</span><br>    <span class="hljs-comment">// document element is available, as we empty the queue immediately after</span><br>    <span class="hljs-comment">// the document element is created in documentElementAvailable().</span><br>    <span class="hljs-built_in">DCHECK</span>(queued_preloads_.<span class="hljs-built_in">IsEmpty</span>());<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; chunk : pending_chunks)<br>      preloader_-&gt;<span class="hljs-built_in">TakeAndPreload</span>(chunk-&gt;preloads); <span class="hljs-comment">// 预加载子资源</span><br>  &#125;<br><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; chunk : pending_chunks)<br>    speculations_.<span class="hljs-built_in">push_back</span>(std::<span class="hljs-built_in">move</span>(chunk)); <span class="hljs-comment">// 把chunk保存到speculations_中</span><br><br>  <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">IsPaused</span>() &amp;&amp; !<span class="hljs-built_in">IsScheduledForResume</span>()) &#123;<br>    <span class="hljs-keyword">if</span> (tasks_were_suspended_)<br>      parser_scheduler_-&gt;<span class="hljs-built_in">ForceResumeAfterYield</span>();<br>    <span class="hljs-keyword">else</span><br>      parser_scheduler_-&gt;<span class="hljs-built_in">ScheduleForResume</span>(); <span class="hljs-comment">// 唤起解析调度</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>1.首先把BackgroundHTMLParser传递的TokenizedChunk放到临时变量pending_chunks中</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">TokenizedChunk</span> &#123;<br>  <span class="hljs-built_in">USING_FAST_MALLOC</span>(TokenizedChunk);<br><br> <span class="hljs-keyword">public</span>:<br>  std::unique_ptr&lt;CompactHTMLTokenStream&gt; tokens; <span class="hljs-comment">// token的集合</span><br>  PreloadRequestStream preloads;<br>  ViewportDescriptionWrapper viewport;<br>  XSSInfoStream xss_infos;<br>  HTMLTokenizer::State tokenizer_state;<br>  HTMLTreeBuilderSimulator::State tree_builder_state;<br>  HTMLInputCheckpoint input_checkpoint;<br>  TokenPreloadScannerCheckpoint preload_scanner_checkpoint;<br>  <span class="hljs-type">bool</span> starting_script;<br>  <span class="hljs-comment">// Index into |tokens| of the last &lt;meta&gt; csp tag in |tokens|. Preloads will</span><br>  <span class="hljs-comment">// be deferred until this token is parsed. Will be noPendingToken if there</span><br>  <span class="hljs-comment">// are no csp tokens.</span><br>  <span class="hljs-type">int</span> pending_csp_meta_token_index;<br><br>  <span class="hljs-type">static</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> kNoPendingToken = <span class="hljs-number">-1</span>;<br>&#125;;<br></code></pre></td></tr></table></figure><p>TokenizedChunk 为CompactHTMLToken的集合，成员变量tokens中看出。CompactHTMLTokenStream的声明可以看如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">typedef</span> Vector&lt;CompactHTMLToken&gt; CompactHTMLTokenStream;<br></code></pre></td></tr></table></figure><p>2.TakeAndPreload预加载扫描出来的子资源，为什么要预加载，因为在解析流程里如果遇到js是要停止解析，然后执行js。在执行js的时候网络线程是空闲的，blink可以提取发起子资源的请求，节省时间，提升效率。<br>3.pending_chunks遍历出来放入到speculations_中<br>4.ScheduleForResume唤起解析调度</p><h3 id="第六步：post-task执行ContinueParsing"><a href="#第六步：post-task执行ContinueParsing" class="headerlink" title="第六步：post task执行ContinueParsing"></a>第六步：post task执行ContinueParsing</h3><p>这个函数是唤醒解析调度，继续解析。一般在什么情况会调用：<br>1.当有pending_chunks过来时候会调度<br>2.解析阶段因为js执行被中断，js执行完后会调度</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">HTMLParserScheduler::ScheduleForResume</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-built_in">DCHECK</span>(!is_suspended_with_active_timer_);<br>  cancellable_continue_parse_task_handle_ =<br>      loading_task_runner_-&gt;<span class="hljs-built_in">PostCancellableTask</span>(<br>          BLINK_FROM_HERE, WTF::<span class="hljs-built_in">Bind</span>(&amp;HTMLParserScheduler::ContinueParsing,<br>                                     <span class="hljs-built_in">WrapWeakPersistent</span>(<span class="hljs-keyword">this</span>)));<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="第七步：执行PumpPendingSpeculations"><a href="#第七步：执行PumpPendingSpeculations" class="headerlink" title="第七步：执行PumpPendingSpeculations"></a>第七步：执行PumpPendingSpeculations</h3><p>执行ContinueParsing最终会执行PumpPendingSpeculations。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">HTMLDocumentParser::PumpPendingSpeculations</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-comment">// If this assert fails, you need to call validateSpeculations to make sure</span><br>  <span class="hljs-comment">// m_tokenizer and m_token don&#x27;t have state that invalidates m_speculations.</span><br>  <span class="hljs-built_in">DCHECK</span>(!tokenizer_);<br>  <span class="hljs-built_in">DCHECK</span>(!token_);<br>  <span class="hljs-built_in">DCHECK</span>(!last_chunk_before_pause_);<br>  <span class="hljs-built_in">DCHECK</span>(!<span class="hljs-built_in">IsPaused</span>());<br>  <span class="hljs-built_in">DCHECK</span>(!<span class="hljs-built_in">IsStopped</span>());<br>  <span class="hljs-built_in">DCHECK</span>(!<span class="hljs-built_in">IsScheduledForResume</span>());<br>  <span class="hljs-built_in">DCHECK</span>(!<span class="hljs-built_in">InPumpSession</span>());<br><br>  <span class="hljs-comment">// <span class="hljs-doctag">FIXME:</span> Here should never be reached when there is a blocking script,</span><br>  <span class="hljs-comment">// but it happens in unknown scenarios. See https://crbug.com/440901</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">IsWaitingForScripts</span>()) &#123;<br>    parser_scheduler_-&gt;<span class="hljs-built_in">ScheduleForResume</span>();<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br><br>  <span class="hljs-comment">// Do not allow pumping speculations in nested event loops.</span><br>  <span class="hljs-keyword">if</span> (pump_speculations_session_nesting_level_) &#123;<br>    parser_scheduler_-&gt;<span class="hljs-built_in">ScheduleForResume</span>();<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br><br>  <span class="hljs-function">probe::ParseHTML <span class="hljs-title">probe</span><span class="hljs-params">(GetDocument(), <span class="hljs-keyword">this</span>)</span></span>;<br><br>  <span class="hljs-function">SpeculationsPumpSession <span class="hljs-title">session</span><span class="hljs-params">(pump_speculations_session_nesting_level_)</span></span>;<br>  <span class="hljs-keyword">while</span> (!speculations_.<span class="hljs-built_in">IsEmpty</span>()) &#123;<br>    <span class="hljs-built_in">DCHECK</span>(!<span class="hljs-built_in">IsScheduledForResume</span>());<br>    <span class="hljs-type">size_t</span> element_token_count =<br>        <span class="hljs-built_in">ProcessTokenizedChunkFromBackgroundParser</span>(speculations_.<span class="hljs-built_in">TakeFirst</span>());<br>    session.<span class="hljs-built_in">AddedElementTokens</span>(element_token_count);<br><br>    <span class="hljs-comment">// Always check isParsing first as m_document may be null. Surprisingly,</span><br>    <span class="hljs-comment">// isScheduledForResume() may be set here as a result of</span><br>    <span class="hljs-comment">// processTokenizedChunkFromBackgroundParser running arbitrary javascript</span><br>    <span class="hljs-comment">// which invokes nested event loops. (e.g. inspector breakpoints)</span><br>    <span class="hljs-built_in">CheckIfBodyStylesheetAdded</span>();<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">IsParsing</span>() || <span class="hljs-built_in">IsPaused</span>() || <span class="hljs-built_in">IsScheduledForResume</span>())<br>      <span class="hljs-keyword">break</span>;<br><br>    <span class="hljs-keyword">if</span> (speculations_.<span class="hljs-built_in">IsEmpty</span>() ||<br>        parser_scheduler_-&gt;<span class="hljs-built_in">YieldIfNeeded</span>(<br>            session, speculations_.<span class="hljs-built_in">front</span>()-&gt;starting_script))<br>      <span class="hljs-keyword">break</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>PumpPendingSpeculations函数作用：<br>1.IsWaitingForScripts判断是否在执行js，如果在执行则停止解析，post task进行唤醒下次调度（所以在解析遇到js标签时候会停止解析，然后执行js，执行完js后再继续解析）<br>2.遍历Deque&lt;std::unique_ptr<TokenizedChunk>&gt;，根据TokenizedChunk去生成Element</p><h3 id="第八步：根据TokenizedChunk构建Tree"><a href="#第八步：根据TokenizedChunk构建Tree" class="headerlink" title="第八步：根据TokenizedChunk构建Tree"></a>第八步：根据TokenizedChunk构建Tree</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">HTMLDocumentParser::ProcessTokenizedChunkFromBackgroundParser</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">    std::unique_ptr&lt;TokenizedChunk&gt; pop_chunk)</span> </span>&#123;<br>......<br>  <span class="hljs-keyword">for</span> (Vector&lt;CompactHTMLToken&gt;::const_iterator it = tokens-&gt;<span class="hljs-built_in">begin</span>();<br>       it != tokens-&gt;<span class="hljs-built_in">end</span>(); ++it) &#123;<br>    <span class="hljs-built_in">DCHECK</span>(!<span class="hljs-built_in">IsWaitingForScripts</span>());<br>......<br>      <span class="hljs-keyword">if</span> (tokens-&gt;<span class="hljs-built_in">back</span>().<span class="hljs-built_in">GetType</span>() == HTMLToken::kEndOfFile) &#123; <span class="hljs-comment">// 识别到文件结束符则停止解析</span><br>        <span class="hljs-built_in">DCHECK</span>(<br>            speculations_<br>                .<span class="hljs-built_in">IsEmpty</span>());  <span class="hljs-comment">// There should never be any chunks after the EOF.</span><br>        <span class="hljs-built_in">PrepareToStopParsing</span>();<br>      &#125;<br>      <span class="hljs-keyword">break</span>;<br>    &#125;<br>......<br>    <span class="hljs-built_in">ConstructTreeFromCompactHTMLToken</span>(*it); <span class="hljs-comment">// 生成Element</span><br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">IsPaused</span>()) &#123;<br>      <span class="hljs-comment">// The script or stylesheet should be the last token of this bunch.</span><br>      <span class="hljs-built_in">DCHECK_EQ</span>(it + <span class="hljs-number">1</span>, tokens-&gt;<span class="hljs-built_in">end</span>());<br>      <span class="hljs-keyword">if</span> (<span class="hljs-built_in">IsWaitingForScripts</span>())<br>        <span class="hljs-built_in">RunScriptsForPausedTreeBuilder</span>();<br>      <span class="hljs-built_in">ValidateSpeculations</span>(std::<span class="hljs-built_in">move</span>(chunk));<br>      <span class="hljs-keyword">break</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (it-&gt;<span class="hljs-built_in">GetType</span>() == HTMLToken::kEndOfFile) &#123;  <span class="hljs-comment">// 识别到文件结束符则停止解析</span><br>      <span class="hljs-comment">// The EOF is assumed to be the last token of this bunch.</span><br>      <span class="hljs-built_in">DCHECK_EQ</span>(it + <span class="hljs-number">1</span>, tokens-&gt;<span class="hljs-built_in">end</span>());<br>      <span class="hljs-comment">// There should never be any chunks after the EOF.</span><br>      <span class="hljs-built_in">DCHECK</span>(speculations_.<span class="hljs-built_in">IsEmpty</span>());<br>      <span class="hljs-built_in">PrepareToStopParsing</span>();<br>      <span class="hljs-keyword">break</span>;<br>    &#125;<br>......<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="第九步：CompactHTMLToken转换成AtomicHTMLToken"><a href="#第九步：CompactHTMLToken转换成AtomicHTMLToken" class="headerlink" title="第九步：CompactHTMLToken转换成AtomicHTMLToken"></a>第九步：CompactHTMLToken转换成AtomicHTMLToken</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">HTMLDocumentParser::ConstructTreeFromCompactHTMLToken</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-type">const</span> CompactHTMLToken&amp; compact_token)</span> </span>&#123;<br>  <span class="hljs-function">AtomicHTMLToken <span class="hljs-title">token</span><span class="hljs-params">(compact_token)</span></span>; <span class="hljs-comment">// 把CompactHTMLToken转换成AtomicHTMLToken</span><br>  tree_builder_-&gt;<span class="hljs-built_in">ConstructTree</span>(&amp;token);<br>  <span class="hljs-built_in">CheckIfBodyStylesheetAdded</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="第十步：ConstructTree生成Element，建立DomTree"><a href="#第十步：ConstructTree生成Element，建立DomTree" class="headerlink" title="第十步：ConstructTree生成Element，建立DomTree"></a>第十步：ConstructTree生成Element，建立DomTree</h3><p>这个下章再讲解</p><h2 id="优化思路"><a href="#优化思路" class="headerlink" title="优化思路"></a>优化思路</h2><p>1.在解析过程中如果遇到js标签会暂停解析流程执行js，所以head标签内的js尽量少并且短小精悍，可以适当用直接写在标签内，尽量在head里面少用url，因为url还需要发起网络加载（网络加载是耗时的），当前还可以用js async属性延迟执行，这样做可以快速出首帧，增强体验。<br>2.调整Token的个数限制，可以加快Dom Tree的构建，从而加快排版渲染首帧展示。</p><p>同步知乎：<a href="https://zhuanlan.zhihu.com/p/48524320">https://zhuanlan.zhihu.com/p/48524320</a></p>]]></content>
    
    
    <categories>
      
      <category>Chromium</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Parse</tag>
      
      <tag>Token</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>浏览器内核原理--Chromium Blink流程 PaintLayer和GraphicsLayer</title>
    <link href="/2022/05/04/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%86%85%E6%A0%B8%E5%8E%9F%E7%90%86-Chromium-Blink%E6%B5%81%E7%A8%8B-PaintLayer%E5%92%8CGraphicsLayer/"/>
    <url>/2022/05/04/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%86%85%E6%A0%B8%E5%8E%9F%E7%90%86-Chromium-Blink%E6%B5%81%E7%A8%8B-PaintLayer%E5%92%8CGraphicsLayer/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>上一章讲到生成layout tree，这一章主要讲解后面生成paint layer流程。</p><h2 id="PaintLayer介绍"><a href="#PaintLayer介绍" class="headerlink" title="PaintLayer介绍"></a>PaintLayer介绍</h2><p>早期blink的命名不是PaintLayer，而是RenderLayer。一个PaintLayer对应一个LayoutBoxModelObject，不是每个LayoutBoxModelObject会创建PaintLayer，是有条件才会创建。<br><img src="/2022/05/04/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%86%85%E6%A0%B8%E5%8E%9F%E7%90%86-Chromium-Blink%E6%B5%81%E7%A8%8B-PaintLayer%E5%92%8CGraphicsLayer/Layout-PaintLayer.jpg" alt="Layout Tree到PaintLayer Tree"></p><h3 id="PaintLayer的创建"><a href="#PaintLayer的创建" class="headerlink" title="PaintLayer的创建"></a>PaintLayer的创建</h3><p>StyleDidChange（样式变更）-&gt;LayerTypeRequired（根据当前元素样式是否获取layer类型，用于判断是否创建PaintLayer）-&gt;CreateLayerAfterStyleChange（创建PaintLayer）</p><figure class="highlight c++"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></div></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">LayoutBoxModelObject::StyleDidChange</span><span class="hljs-params">(StyleDifference diff,</span></span><br><span class="hljs-params"><span class="hljs-function">                                          <span class="hljs-type">const</span> ComputedStyle* old_style)</span> </span>&#123;<br>*****************************************************************************<br>******************************此处代码省略*************************************<br>*****************************************************************************<br>  PaintLayerType type = <span class="hljs-built_in">LayerTypeRequired</span>();<span class="hljs-comment">// 获取样式的Layer类型，判断是否需要创建Layer</span><br>  <span class="hljs-keyword">if</span> (type != kNoPaintLayer) &#123;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">Layer</span>()) &#123;<br>      <span class="hljs-comment">// In order to update this object properly, we need to lay it out again.</span><br>      <span class="hljs-comment">// However, if we have never laid it out, don&#x27;t mark it for layout. If</span><br>      <span class="hljs-comment">// this is a new object, it may not yet have been inserted into the tree,</span><br>      <span class="hljs-comment">// and if we mark it for layout then, we risk upsetting the tree</span><br>      <span class="hljs-comment">// insertion machinery.</span><br>      <span class="hljs-keyword">if</span> (<span class="hljs-built_in">EverHadLayout</span>())<br>        <span class="hljs-built_in">SetChildNeedsLayout</span>();<br><br>      <span class="hljs-built_in">CreateLayerAfterStyleChange</span>();<span class="hljs-comment">// 创建PainterLayer函数</span><br>    &#125;<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Layer</span>() &amp;&amp; <span class="hljs-built_in">Layer</span>()-&gt;<span class="hljs-built_in">Parent</span>()) &#123;<br>    PaintLayer* parent_layer = <span class="hljs-built_in">Layer</span>()-&gt;<span class="hljs-built_in">Parent</span>();<br>    <span class="hljs-comment">// Either a transform wasn&#x27;t specified or the object doesn&#x27;t support</span><br>    <span class="hljs-comment">// transforms, so just null out the bit.</span><br>    <span class="hljs-built_in">SetHasTransformRelatedProperty</span>(<span class="hljs-literal">false</span>);<br>    <span class="hljs-built_in">SetHasReflection</span>(<span class="hljs-literal">false</span>);<br>    <span class="hljs-built_in">Layer</span>()-&gt;<span class="hljs-built_in">UpdateFilters</span>(old_style, <span class="hljs-built_in">StyleRef</span>());<br>    <span class="hljs-built_in">Layer</span>()-&gt;<span class="hljs-built_in">UpdateClipPath</span>(old_style, <span class="hljs-built_in">StyleRef</span>());<br>    <span class="hljs-comment">// Calls DestroyLayer() which clears the layer.</span><br>    <span class="hljs-built_in">Layer</span>()-&gt;<span class="hljs-built_in">RemoveOnlyThisLayerAfterStyleChange</span>();<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">EverHadLayout</span>())<br>      <span class="hljs-built_in">SetChildNeedsLayout</span>();<br>    <span class="hljs-keyword">if</span> (had_transform_related_property) &#123;<br>      <span class="hljs-built_in">SetNeedsLayoutAndPrefWidthsRecalcAndFullPaintInvalidation</span>(<br>          LayoutInvalidationReason::kStyleChange);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">NeedsLayout</span>()) &#123;<br>      <span class="hljs-comment">// <span class="hljs-doctag">FIXME:</span> We should call a specialized version of this function.</span><br>      parent_layer-&gt;<span class="hljs-built_in">UpdateLayerPositionsAfterLayout</span>();<br>    &#125;<br>  &#125;<br>*****************************************************************************<br>******************************此处代码省略*************************************<br>*****************************************************************************<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="创建PaintLayer的条件"><a href="#创建PaintLayer的条件" class="headerlink" title="创建PaintLayer的条件"></a>创建PaintLayer的条件</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-number">1.</span>It<span class="hljs-number">&#x27;</span>s the root object <span class="hljs-keyword">for</span> the page<br><span class="hljs-number">2.</span><span class="hljs-function">It has <span class="hljs-keyword">explicit</span> CSS position <span class="hljs-title">properties</span> <span class="hljs-params">(relative, absolute <span class="hljs-keyword">or</span> a transform)</span></span><br><span class="hljs-function">3.It is transparent</span><br><span class="hljs-function">4.Has overflow, an alpha mask <span class="hljs-keyword">or</span> reflection</span><br><span class="hljs-function">5.Has a CSS filter</span><br><span class="hljs-function">6.Corresponds to &lt;canvas&gt; element that has a 3<span class="hljs-title">D</span> <span class="hljs-params">(WebGL)</span> context <span class="hljs-keyword">or</span> an accelerated 2D context</span><br><span class="hljs-function">7.Corresponds to a &lt;video&gt; element</span><br></code></pre></td></tr></table></figure><p>函数实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">PaintLayerType <span class="hljs-title">LayoutBox::LayerTypeRequired</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>  <span class="hljs-comment">// hasAutoZIndex only returns true if the element is positioned or a flex-item</span><br>  <span class="hljs-comment">// since position:static elements that are not flex-items get their z-index</span><br>  <span class="hljs-comment">// coerced to auto.</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">IsPositioned</span>() || <span class="hljs-built_in">CreatesGroup</span>() || <span class="hljs-built_in">HasClipPath</span>() ||<br>      <span class="hljs-built_in">HasTransformRelatedProperty</span>() || <span class="hljs-built_in">HasHiddenBackface</span>() || <span class="hljs-built_in">HasReflection</span>() ||<br>      <span class="hljs-built_in">Style</span>()-&gt;<span class="hljs-built_in">SpecifiesColumns</span>() || <span class="hljs-built_in">Style</span>()-&gt;<span class="hljs-built_in">IsStackingContext</span>() ||<br>      <span class="hljs-built_in">Style</span>()-&gt;<span class="hljs-built_in">ShouldCompositeForCurrentAnimations</span>() ||<br>      RootScrollerUtil::<span class="hljs-built_in">IsEffective</span>(*<span class="hljs-keyword">this</span>))<br>    <span class="hljs-keyword">return</span> kNormalPaintLayer;<br><br>  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">HasOverflowClip</span>())<br>    <span class="hljs-keyword">return</span> kOverflowClipPaintLayer;<br><br>  <span class="hljs-keyword">return</span> kNoPaintLayer;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="PaintLayer-Tree到GraphicsLayer-Tree创建流程"><a href="#PaintLayer-Tree到GraphicsLayer-Tree创建流程" class="headerlink" title="PaintLayer Tree到GraphicsLayer Tree创建流程"></a>PaintLayer Tree到GraphicsLayer Tree创建流程</h3><p>![PaintLayer Tree到GraphocsLayer Tree创建流程](PaintLayer -GraphocsLayer创建流程.jpg)<br>以下是函数流程：<br>PaintLayerCompositor::UpdateIfNeededRecursiveInternal（递归调用所有LocalFrame进行更新PaintLayerCompositor）-&gt;PaintLayerCompositor::UpdateIfNeeded-&gt;CompositingLayerAssigner::Assign（CompositingLayerMapping创建或者删除）-&gt;GraphicsLayerUpdater::Update（GraphicsLayer属性更新）-&gt;GraphicsLayerTreeBuilder::Rebuild（重新创建GraphicsLayer Tree）<br><img src="/2022/05/04/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%86%85%E6%A0%B8%E5%8E%9F%E7%90%86-Chromium-Blink%E6%B5%81%E7%A8%8B-PaintLayer%E5%92%8CGraphicsLayer/%E6%97%B6%E5%BA%8F%E5%9B%BE.jpg" alt="时序图"><br>入口函数PaintLayerCompositor::UpdateIfNeeded函数主要做以下事情：<br>1.构建CompositingLayerMapping<br>2.GraphicsLayerUpdater更新GraphicsLayer属性（例如更新GraphicsLayer Transform，Opacity，Filters，位置等）<br>3.根据GraphicsLayerUpdater.NeedsRebuildTree()是否需要重新创建GraphicsLayer Tree<br>4.设置RootGraphicsLayer</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PaintLayerCompositor::UpdateIfNeeded</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">    DocumentLifecycle::LifecycleState target_state,</span></span><br><span class="hljs-params"><span class="hljs-function">    CompositingReasonsStats&amp; compositing_reasons_stats)</span> </span>&#123;<br>  <span class="hljs-built_in">DCHECK</span>(target_state &gt;= DocumentLifecycle::kCompositingInputsClean);<br><br>  <span class="hljs-built_in">Lifecycle</span>().<span class="hljs-built_in">AdvanceTo</span>(DocumentLifecycle::kInCompositingUpdate); <span class="hljs-comment">//更新document的生命周期</span><br><br>*****************************************************************************<br>******************************此处代码省略************************************<br>*****************************************************************************<br><br>  CompositingUpdateType update_type = pending_update_type_;<br>  pending_update_type_ = kCompositingUpdateNone;<br><br>  <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">HasAcceleratedCompositing</span>()) &#123; <span class="hljs-comment">// 如果未开启硬件合成则返回</span><br>    <span class="hljs-built_in">UpdateWithoutAcceleratedCompositing</span>(update_type);<br>    <span class="hljs-built_in">Lifecycle</span>().<span class="hljs-built_in">AdvanceTo</span>(<br>        std::<span class="hljs-built_in">min</span>(DocumentLifecycle::kCompositingClean, target_state));<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br><br>*****************************************************************************<br>******************************此处代码省略************************************<br>*****************************************************************************<br>  PaintLayer* update_root = <span class="hljs-built_in">RootLayer</span>(); <span class="hljs-comment">// 获取root layer</span><br><br>  Vector&lt;PaintLayer*&gt; layers_needing_paint_invalidation;<br><br>  <span class="hljs-keyword">if</span> (update_type &gt;= kCompositingUpdateAfterCompositingInputChange) &#123;<br>    <span class="hljs-built_in">CompositingInputsUpdater</span>(update_root).<span class="hljs-built_in">Update</span>();<br><br>*****************************************************************************<br>******************************此处代码省略************************************<br>*****************************************************************************<br><br>    <span class="hljs-built_in">CompositingRequirementsUpdater</span>(layout_view_, compositing_reason_finder_)<br>        .<span class="hljs-built_in">Update</span>(update_root, compositing_reasons_stats);<br><br>    <span class="hljs-function">CompositingLayerAssigner <span class="hljs-title">layer_assigner</span><span class="hljs-params">(<span class="hljs-keyword">this</span>)</span></span>;<br>    layer_assigner.<span class="hljs-built_in">Assign</span>(update_root, layers_needing_paint_invalidation); <span class="hljs-comment">// 创建CompositingLayer</span><br><br>    <span class="hljs-type">bool</span> layers_changed = layer_assigner.<span class="hljs-built_in">LayersChanged</span>();<br><br>*****************************************************************************<br>******************************此处代码省略************************************<br>*****************************************************************************<br><br>  GraphicsLayerUpdater updater;<br>  updater.<span class="hljs-built_in">Update</span>(*update_root, layers_needing_paint_invalidation); <span class="hljs-comment">// 更新GraphicsLayer</span><br><br>  <span class="hljs-keyword">if</span> (updater.<span class="hljs-built_in">NeedsRebuildTree</span>())<br>    update_type = std::<span class="hljs-built_in">max</span>(update_type, kCompositingUpdateRebuildTree);<br><br>  <span class="hljs-keyword">if</span> (update_type &gt;= kCompositingUpdateRebuildTree) &#123;<br>    GraphicsLayerVector child_list;<br>    &#123;<br>      <span class="hljs-built_in">TRACE_EVENT0</span>(<span class="hljs-string">&quot;blink&quot;</span>, <span class="hljs-string">&quot;GraphicsLayerTreeBuilder::rebuild&quot;</span>);<br>      <span class="hljs-built_in">GraphicsLayerTreeBuilder</span>().<span class="hljs-built_in">Rebuild</span>(*update_root, child_list);<br>    &#125;<br><br>*****************************************************************************<br>******************************此处代码省略************************************<br>*****************************************************************************<br><br>  <span class="hljs-keyword">if</span> (root_layer_attachment_ == kRootLayerPendingAttachViaChromeClient) &#123;<br>    <span class="hljs-keyword">if</span> (Page* page = layout_view_.<span class="hljs-built_in">GetFrame</span>()-&gt;<span class="hljs-built_in">GetPage</span>()) &#123;<br>      page-&gt;<span class="hljs-built_in">GetChromeClient</span>().<span class="hljs-built_in">AttachRootGraphicsLayer</span>(<span class="hljs-built_in">RootGraphicsLayer</span>(),<br>                                                      layout_view_.<span class="hljs-built_in">GetFrame</span>()); <span class="hljs-comment">// 设置RootGraphicsLayer</span><br>      root_layer_attachment_ = kRootLayerAttachedViaChromeClient;<br>    &#125;<br>  &#125;<br><br>*****************************************************************************<br>******************************此处代码省略************************************<br>*****************************************************************************<br><br>  <span class="hljs-built_in">Lifecycle</span>().<span class="hljs-built_in">AdvanceTo</span>(DocumentLifecycle::kCompositingClean);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="PaintLayerCompositor"><a href="#PaintLayerCompositor" class="headerlink" title="PaintLayerCompositor"></a>PaintLayerCompositor</h2><p>创建PaintLayerCompositor</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">PaintLayerCompositor* <span class="hljs-title">LayoutView::Compositor</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (!compositor_)<br>    compositor_ = WTF::<span class="hljs-built_in">WrapUnique</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">PaintLayerCompositor</span>(*<span class="hljs-keyword">this</span>));<br><br>  <span class="hljs-keyword">return</span> compositor_.<span class="hljs-built_in">get</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>由上可以看出来一个LayoutView对应一个PaintLayerCompositor</p><h2 id="CompositedLayerMapping"><a href="#CompositedLayerMapping" class="headerlink" title="CompositedLayerMapping"></a>CompositedLayerMapping</h2><p>函数调用流程：<br>CompositingLayerAssigner::Assign-&gt;CompositingLayerAssigner::AssignLayersToBackingsInternal-&gt;PaintLayerCompositor::AllocateOrClearCompositedLayerMapping（分配获取清除CompositedLayerMapping）-&gt;PaintLayer::EnsureCompositedLayerMapping（创建CompositedLayerMapping）<br>!(时序图)[时序图-1.jpg]<br>PaintLayerCompositor::AllocateOrClearCompositedLayerMapping创建或者清除CompositedLayerMapping，具体作用：<br>1.如果当前的composited_layer_update为kAllocateOwnCompositedLayerMapping则需要为PaintLayer创建个CompositedLayerMapping<br>2.如果当前的composited_layer_update为kRemoveOwnCompositedLayerMapping和kPutInSquashingLayer则清除PaintLayer的CompositedLayerMapping</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">PaintLayerCompositor::AllocateOrClearCompositedLayerMapping</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">    PaintLayer* layer,</span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-type">const</span> CompositingStateTransitionType composited_layer_update)</span> </span>&#123;<br>  <span class="hljs-type">bool</span> composited_layer_mapping_changed = <span class="hljs-literal">false</span>;<br><br>  <span class="hljs-comment">// <span class="hljs-doctag">FIXME:</span> It would be nice to directly use the layer&#x27;s compositing reason,</span><br>  <span class="hljs-comment">// but allocateOrClearCompositedLayerMapping also gets called without having</span><br>  <span class="hljs-comment">// updated compositing requirements fully.</span><br>  <span class="hljs-keyword">switch</span> (composited_layer_update) &#123;<br>    <span class="hljs-keyword">case</span> kAllocateOwnCompositedLayerMapping: <span class="hljs-comment">// kAllocateOwnCompositedLayerMapping需要分配自己的后端合成</span><br>      <span class="hljs-built_in">DCHECK</span>(!layer-&gt;<span class="hljs-built_in">HasCompositedLayerMapping</span>());<br>      <span class="hljs-built_in">SetCompositingModeEnabled</span>(<span class="hljs-literal">true</span>);<br><br>      <span class="hljs-comment">// If we need to issue paint invalidations, do so before allocating the</span><br>      <span class="hljs-comment">// compositedLayerMapping and clearing out the groupedMapping.</span><br>      <span class="hljs-built_in">PaintInvalidationOnCompositingChange</span>(layer);<br><br>      <span class="hljs-comment">// If this layer was previously squashed, we need to remove its reference</span><br>      <span class="hljs-comment">// to a groupedMapping right away, so that computing paint invalidation</span><br>      <span class="hljs-comment">// rects will know the layer&#x27;s correct compositingState.</span><br>      <span class="hljs-comment">// <span class="hljs-doctag">FIXME:</span> do we need to also remove the layer from it&#x27;s location in the</span><br>      <span class="hljs-comment">// squashing list of its groupedMapping?  Need to create a test where a</span><br>      <span class="hljs-comment">// squashed layer pops into compositing. And also to cover all other sorts</span><br>      <span class="hljs-comment">// of compositingState transitions.</span><br>      layer-&gt;<span class="hljs-built_in">SetLostGroupedMapping</span>(<span class="hljs-literal">false</span>);<br>      layer-&gt;<span class="hljs-built_in">SetGroupedMapping</span>(<br>          <span class="hljs-literal">nullptr</span>, PaintLayer::kInvalidateLayerAndRemoveFromMapping);<br><br>      layer-&gt;<span class="hljs-built_in">EnsureCompositedLayerMapping</span>(); <span class="hljs-comment">// 创建CompositedLayerMapping</span><br>      composited_layer_mapping_changed = <span class="hljs-literal">true</span>;<br><br>      <span class="hljs-built_in">RestartAnimationOnCompositor</span>(layer-&gt;<span class="hljs-built_in">GetLayoutObject</span>());<br><br>      <span class="hljs-comment">// At this time, the ScrollingCoordinator only supports the top-level</span><br>      <span class="hljs-comment">// frame.</span><br>      <span class="hljs-keyword">if</span> (layer-&gt;<span class="hljs-built_in">IsRootLayer</span>() &amp;&amp; layout_view_.<span class="hljs-built_in">GetFrame</span>()-&gt;<span class="hljs-built_in">IsLocalRoot</span>()) &#123;<br>        <span class="hljs-keyword">if</span> (ScrollingCoordinator* scrolling_coordinator =<br>                <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">GetScrollingCoordinator</span>()) &#123;<br>          scrolling_coordinator-&gt;<span class="hljs-built_in">FrameViewRootLayerDidChange</span>(<br>              layout_view_.<span class="hljs-built_in">GetFrameView</span>());<br>        &#125;<br>      &#125;<br>      <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> kRemoveOwnCompositedLayerMapping:<br>    <span class="hljs-comment">// PutInSquashingLayer means you might have to remove the composited layer</span><br>    <span class="hljs-comment">// mapping first.</span><br>    <span class="hljs-keyword">case</span> kPutInSquashingLayer:<br>      <span class="hljs-keyword">if</span> (layer-&gt;<span class="hljs-built_in">HasCompositedLayerMapping</span>()) &#123;<br>        layer-&gt;<span class="hljs-built_in">ClearCompositedLayerMapping</span>(); <span class="hljs-comment">// 清除PaintLayer的CompositedLayerMapping</span><br>        composited_layer_mapping_changed = <span class="hljs-literal">true</span>;<br>      &#125;<br><br>      <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> kRemoveFromSquashingLayer:<br>    <span class="hljs-keyword">case</span> kNoCompositingStateChange:<br>      <span class="hljs-comment">// Do nothing.</span><br>      <span class="hljs-keyword">break</span>;<br>  &#125;<br>*****************************************************************************<br>******************************此处代码省略************************************<br>*****************************************************************************<br>&#125;<br></code></pre></td></tr></table></figure><p>NeedsOwnBacking函数介绍：</p><p>调用NeedsOwnBacking函数可以判断出否需要为PaintLayer创建一个CompositedLayerMapping，PaintLayer创建CompositedLayerMapping是会给出CompositingReason的，CompositingReason的定义可以查看CompositingReasons.h文件代码有点多就不贴出来了。PaintLayer必须满足一下条件才能创建CompositedLayerMapping</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-number">1.L</span>ayer has <span class="hljs-number">3</span>D <span class="hljs-keyword">or</span> perspective transform CSS properties   <br><span class="hljs-number">2.L</span>ayer is used by &lt;video&gt; element <span class="hljs-keyword">using</span> accelerated video decoding  <br><span class="hljs-number">3.L</span>ayer is used by a &lt;canvas&gt; element with a <span class="hljs-number">3</span>D context <span class="hljs-keyword">or</span> accelerated <span class="hljs-number">2</span>D context<br><span class="hljs-number">4.L</span>ayer is used <span class="hljs-keyword">for</span> a composited plugin<br><span class="hljs-number">5.L</span>ayer uses a CSS animation <span class="hljs-keyword">for</span> its opacity <span class="hljs-keyword">or</span> uses an animated webkit transform<br><span class="hljs-number">6.L</span>ayer uses accelerated CSS filters <br><span class="hljs-number">7.L</span>ayer has a descendant that is a compositing layer  <br><span class="hljs-number">8.L</span>ayer has a sibling with a lower z-<span class="hljs-function">index which has a compositing <span class="hljs-title">layer</span> <span class="hljs-params">(in other words the layer overlaps a composited layer <span class="hljs-keyword">and</span> should be rendered on top of it)</span></span><br></code></pre></td></tr></table></figure><p>判断是否需要创建后端的函数实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">CompositingLayerAssigner::NeedsOwnBacking</span><span class="hljs-params">(<span class="hljs-type">const</span> PaintLayer* layer)</span> <span class="hljs-type">const</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (!compositor_-&gt;<span class="hljs-built_in">CanBeComposited</span>(layer))<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">RequiresCompositing</span>(layer-&gt;<span class="hljs-built_in">GetCompositingReasons</span>()) ||<br>         (compositor_-&gt;<span class="hljs-built_in">StaleInCompositingMode</span>() &amp;&amp; layer-&gt;<span class="hljs-built_in">IsRootLayer</span>());<br>&#125;<br></code></pre></td></tr></table></figure><p>从上面可以知道主要的实现函数是RequiresCompositing，当RequiresCompositing返回为true则表示需要创建。<br>CompositedLayerMapping创建函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PaintLayer::EnsureCompositedLayerMapping</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (rare_data_ &amp;&amp; rare_data_-&gt;composited_layer_mapping)<br>    <span class="hljs-keyword">return</span>;<br><br>  <span class="hljs-built_in">EnsureRareData</span>().composited_layer_mapping =<br>      WTF::<span class="hljs-built_in">WrapUnique</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">CompositedLayerMapping</span>(*<span class="hljs-keyword">this</span>)); <span class="hljs-comment">//创建CompositedLayerMapping</span><br>  rare_data_-&gt;composited_layer_mapping-&gt;<span class="hljs-built_in">SetNeedsGraphicsLayerUpdate</span>(<br>      kGraphicsLayerUpdateSubtree);<br><br>  <span class="hljs-keyword">if</span> (PaintLayerResourceInfo* resource_info = <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">ResourceInfo</span>())<br>    resource_info-&gt;<span class="hljs-built_in">InvalidateFilterChain</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="GraphicsLayer"><a href="#GraphicsLayer" class="headerlink" title="GraphicsLayer"></a>GraphicsLayer</h2><p>每个GraphicsLayer都有一个GraphicsContext，用于绘制相关的PaintLayers<br>由上可知一个PaintLayer可能会生成一个CompositedLayerMapping，CompositedLayerMapping与GraphicsLayer是一对多的关系，一个CompositedLayerMapping一定会有会生成content layer, 可能会有背景Layer，滚动条Layer，前景Layer（可以查看CompositedLayerMapping的成员变量）。CompositedLayerMapping下的GraphicsLayer关系</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//  + m_ancestorClippingLayer [OPTIONAL]</span><br><span class="hljs-comment">//    + m_graphicsLayer</span><br><span class="hljs-comment">//      + m_childTransformLayer [OPTIONAL]</span><br><span class="hljs-comment">//      | + m_childContainmentLayer [OPTIONAL]</span><br><span class="hljs-comment">//      |   &lt;-OR-&gt;</span><br><span class="hljs-comment">//      |   (m_scrollingLayer + m_scrollingContentsLayer) [OPTIONAL]</span><br><span class="hljs-comment">//      + m_overflowControlsAncestorClippingLayer [OPTIONAL]</span><br><span class="hljs-comment">//      | + m_overflowControlsHostLayer [OPTIONAL]</span><br><span class="hljs-comment">//      |   + m_layerForVerticalScrollbar [OPTIONAL]</span><br><span class="hljs-comment">//      |   + m_layerForHorizontalScrollbar [OPTIONAL]</span><br><span class="hljs-comment">//      |   + m_layerForScrollCorner [OPTIONAL]</span><br><span class="hljs-comment">//      + m_decorationOutlineLayer [OPTIONAL]</span><br></code></pre></td></tr></table></figure><p>当创建CompositedLayerMapping就会创建网页内容的graphics_layer_ 。<br>CompositedLayerMapping-&gt;CompositedLayerMapping::CreatePrimaryGraphicsLayer-&gt;CompositedLayerMapping::CreateGraphicsLayer</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C++">CompositedLayerMapping::<span class="hljs-built_in">CompositedLayerMapping</span>(PaintLayer&amp; layer)<br>    : <span class="hljs-built_in">owning_layer_</span>(layer),<br>      <span class="hljs-built_in">content_offset_in_compositing_layer_dirty_</span>(<span class="hljs-literal">false</span>),<br>      <span class="hljs-built_in">pending_update_scope_</span>(kGraphicsLayerUpdateNone),<br>      <span class="hljs-built_in">is_main_frame_layout_view_layer_</span>(<span class="hljs-literal">false</span>),<br>      <span class="hljs-built_in">background_layer_paints_fixed_root_background_</span>(<span class="hljs-literal">false</span>),<br>      <span class="hljs-built_in">scrolling_contents_are_empty_</span>(<span class="hljs-literal">false</span>),<br>      <span class="hljs-built_in">background_paints_onto_scrolling_contents_layer_</span>(<span class="hljs-literal">false</span>),<br>      <span class="hljs-built_in">background_paints_onto_graphics_layer_</span>(<span class="hljs-literal">false</span>),<br>      <span class="hljs-built_in">draws_background_onto_content_layer_</span>(<span class="hljs-literal">false</span>) &#123;<br>  <span class="hljs-keyword">if</span> (layer.<span class="hljs-built_in">IsRootLayer</span>() &amp;&amp; <span class="hljs-built_in">GetLayoutObject</span>().<span class="hljs-built_in">GetFrame</span>()-&gt;<span class="hljs-built_in">IsMainFrame</span>())<br>    is_main_frame_layout_view_layer_ = <span class="hljs-literal">true</span>;<br><br>  <span class="hljs-built_in">CreatePrimaryGraphicsLayer</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>下面是设置CompositedLayerMapping的内容绘制的graphics_layer_</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">CompositedLayerMapping::CreatePrimaryGraphicsLayer</span><span class="hljs-params">()</span> </span>&#123;<br>  graphics_layer_ =<br>      <span class="hljs-built_in">CreateGraphicsLayer</span>(owning_layer_.<span class="hljs-built_in">GetCompositingReasons</span>(),<br>                          owning_layer_.<span class="hljs-built_in">GetSquashingDisallowedReasons</span>()); <span class="hljs-comment">// 创建graphics_layer_ </span><br><br>  <span class="hljs-built_in">UpdateShouldHitTest</span>(<span class="hljs-literal">true</span>);<br>  <span class="hljs-built_in">UpdateOpacity</span>(<span class="hljs-built_in">GetLayoutObject</span>().<span class="hljs-built_in">StyleRef</span>());<br>  <span class="hljs-built_in">UpdateTransform</span>(<span class="hljs-built_in">GetLayoutObject</span>().<span class="hljs-built_in">StyleRef</span>());<br>  <span class="hljs-built_in">UpdateFilters</span>(<span class="hljs-built_in">GetLayoutObject</span>().<span class="hljs-built_in">StyleRef</span>());<br>  <span class="hljs-built_in">UpdateBackdropFilters</span>(<span class="hljs-built_in">GetLayoutObject</span>().<span class="hljs-built_in">StyleRef</span>());<br>  <span class="hljs-built_in">UpdateLayerBlendMode</span>(<span class="hljs-built_in">GetLayoutObject</span>().<span class="hljs-built_in">StyleRef</span>());<br>  <span class="hljs-built_in">UpdateIsRootForIsolatedGroup</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>优化思路<br>一个复杂的网页生成很多Layer，前端要尽量控制Layer数，因为到cc层，Layer计算和光栅化是耗时的，每个Picture Layer都会计算自己的的tile</p><p>同步知乎：<a href="https://zhuanlan.zhihu.com/p/48515392">https://zhuanlan.zhihu.com/p/48515392</a></p>]]></content>
    
    
    <categories>
      
      <category>Chromium</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PaintLayer</tag>
      
      <tag>GraphicsLayer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>浏览器内核原理--Chromium Blink流程（1）</title>
    <link href="/2022/05/04/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%86%85%E6%A0%B8%E5%8E%9F%E7%90%86-Chromium-Blink%E6%B5%81%E7%A8%8B%EF%BC%881%EF%BC%89/"/>
    <url>/2022/05/04/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%86%85%E6%A0%B8%E5%8E%9F%E7%90%86-Chromium-Blink%E6%B5%81%E7%A8%8B%EF%BC%881%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>上章讲到Blink的架构和WebView的结构，这章主要讲解下Blink的工作流程</p><h2 id="Blink流程"><a href="#Blink流程" class="headerlink" title="Blink流程"></a>Blink流程</h2><p><img src="/2022/05/04/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%86%85%E6%A0%B8%E5%8E%9F%E7%90%86-Chromium-Blink%E6%B5%81%E7%A8%8B%EF%BC%881%EF%BC%89/Blink%E6%B5%81%E7%A8%8B.jpg" alt="Blink流程"><br>如图可知blink的流程是<strong>加载资源-&gt;解析html-&gt;生成dom tree-&gt;生成layout tree-&gt;生成paintLayer树-&gt;生成GraphicsLayer树-&gt;生成WebLayer树</strong>（这个是对接cc的layer）<br>下面进行每一个步骤的大致分析和函数入口。</p><h3 id="Blink-页面加载入口"><a href="#Blink-页面加载入口" class="headerlink" title="Blink 页面加载入口"></a>Blink 页面加载入口</h3><figure class="highlight c++"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">FrameLoader::Load</span><span class="hljs-params">(<span class="hljs-type">const</span> FrameLoadRequest&amp; passed_request,</span></span><br><span class="hljs-params"><span class="hljs-function">                       FrameLoadType frame_load_type,</span></span><br><span class="hljs-params"><span class="hljs-function">                       HistoryItem* history_item,</span></span><br><span class="hljs-params"><span class="hljs-function">                       HistoryLoadType history_load_type)</span> </span><br></code></pre></td></tr></table></figure><p>blink层的加载入口，FrameLoadRequest 为加载的请求，FrameLoadType 加载类型</p><h3 id="HTML-Parse"><a href="#HTML-Parse" class="headerlink" title="HTML Parse"></a>HTML Parse</h3><p>HTMLDocumentParser 是解析相关类。<br>html文本-&gt;HTMLToken-&gt;HTMLElementStack<br><img src="/2022/05/04/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%86%85%E6%A0%B8%E5%8E%9F%E7%90%86-Chromium-Blink%E6%B5%81%E7%A8%8B%EF%BC%881%EF%BC%89/Html.jpg" alt="Html"><br>HTMLDocumentParser::AppendBytes 为解析入口，代码如下。老的版本会单独创建一个线程解析文本，但是我62版本已经被关闭了，还是在blink的主线程解析。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">HTMLDocumentParser::AppendBytes</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* data, <span class="hljs-type">size_t</span> length)</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (!length || <span class="hljs-built_in">IsStopped</span>())<br>    <span class="hljs-keyword">return</span>;<br><br>  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">ShouldUseThreading</span>()) &#123;<br>    <span class="hljs-keyword">if</span> (!have_background_parser_)<br>      <span class="hljs-built_in">StartBackgroundParser</span>();<br><br>    std::unique_ptr&lt;Vector&lt;<span class="hljs-type">char</span>&gt;&gt; buffer =<br>        WTF::MakeUnique&lt;Vector&lt;<span class="hljs-type">char</span>&gt;&gt;(length);<br>    <span class="hljs-built_in">memcpy</span>(buffer-&gt;<span class="hljs-built_in">data</span>(), data, length);<br>    <span class="hljs-built_in">TRACE_EVENT1</span>(<span class="hljs-built_in">TRACE_DISABLED_BY_DEFAULT</span>(<span class="hljs-string">&quot;blink.debug&quot;</span>),<br>                 <span class="hljs-string">&quot;HTMLDocumentParser::appendBytes&quot;</span>, <span class="hljs-string">&quot;size&quot;</span>, (<span class="hljs-type">unsigned</span>)length);<br><br>    loading_task_runner_-&gt;<span class="hljs-built_in">PostTask</span>(<br>        BLINK_FROM_HERE,<br>        WTF::<span class="hljs-built_in">Bind</span>(&amp;BackgroundHTMLParser::AppendRawBytesFromMainThread, <span class="hljs-comment">// post一个解析任务给解析线程，buffer为文本数据</span><br>                  background_parser_, WTF::<span class="hljs-built_in">Passed</span>(std::<span class="hljs-built_in">move</span>(buffer))));<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br><br>  DecodedDataDocumentParser::<span class="hljs-built_in">AppendBytes</span>(data, length);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Dom-Tree"><a href="#Dom-Tree" class="headerlink" title="Dom Tree"></a>Dom Tree</h3><p><img src="/2022/05/04/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%86%85%E6%A0%B8%E5%8E%9F%E7%90%86-Chromium-Blink%E6%B5%81%E7%A8%8B%EF%BC%881%EF%BC%89/Dom_Tree.jpg" alt="Dom Tree"><br>如何生成dom tree，主要是HTMLElementStack的栈机制（先入后出）。当遇到一个EndTag时候，会找到最近的对应StartTag元素，然后进行出栈，然后把StartTag和EndTag之间的元素挂在当前的元素下面，形成子节点。<br>Dom Tree创建的函数，代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">HTMLTreeBuilder::ConstructTree</span><span class="hljs-params">(AtomicHTMLToken* token)</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">ShouldProcessTokenInForeignContent</span>(token))<br>    <span class="hljs-built_in">ProcessTokenInForeignContent</span>(token);<br>  <span class="hljs-keyword">else</span><br>    <span class="hljs-built_in">ProcessToken</span>(token);<br><br>  <span class="hljs-keyword">if</span> (parser_-&gt;<span class="hljs-built_in">Tokenizer</span>()) &#123;<br>    <span class="hljs-type">bool</span> in_foreign_content = <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">if</span> (!tree_.<span class="hljs-built_in">IsEmpty</span>()) &#123;<br>      HTMLStackItem* adjusted_current_node = <span class="hljs-built_in">AdjustedCurrentStackItem</span>();<br>      in_foreign_content =<br>          !adjusted_current_node-&gt;<span class="hljs-built_in">IsInHTMLNamespace</span>() &amp;&amp;<br>          !HTMLElementStack::<span class="hljs-built_in">IsHTMLIntegrationPoint</span>(adjusted_current_node) &amp;&amp;<br>          !HTMLElementStack::<span class="hljs-built_in">IsMathMLTextIntegrationPoint</span>(<br>              adjusted_current_node);<br>    &#125;<br><br>    parser_-&gt;<span class="hljs-built_in">Tokenizer</span>()-&gt;<span class="hljs-built_in">SetForceNullCharacterReplacement</span>(<br>        insertion_mode_ == kTextMode || in_foreign_content);<br>    parser_-&gt;<span class="hljs-built_in">Tokenizer</span>()-&gt;<span class="hljs-built_in">SetShouldAllowCDATA</span>(in_foreign_content);<br>  &#125;<br><br>  tree_.<span class="hljs-built_in">ExecuteQueuedTasks</span>();<br>  <span class="hljs-comment">// We might be detached now.</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Layout-Tree"><a href="#Layout-Tree" class="headerlink" title="Layout Tree"></a>Layout Tree</h3><p><img src="/2022/05/04/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%86%85%E6%A0%B8%E5%8E%9F%E7%90%86-Chromium-Blink%E6%B5%81%E7%A8%8B%EF%BC%881%EF%BC%89/Layout_Tree.jpg" alt="Layout Tree"><br>一个Node节点创建对应的LayoutObject（LayoutObject是所有Layout节点的基类）。但不是所有节点都会创建LayoutObject，不可见Node不会创建LayoutObject，例如上面的head标签就不会创建LaoutObject。<br>在右图中有个匿名块的慨念，<strong>匿名块（anonymous）</strong>的对应的node节点是null的，匿名块的作用是为了方便后面的排版算法实现引入的。什么情况下才会创建匿名块？当前节点是的LayoutInline，而兄弟节点是LayoutBlock时候，这个时候会创建一个匿名块，然后当前LayoutInline会挂在匿名块的节点下。<br>注意：匿名块没有单独的类，LayoutBlock用个了位标志表示是否是匿名块，代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-built_in">ADD_BOOLEAN_BITFIELD</span>(is_anonymous_, IsAnonymous);<br></code></pre></td></tr></table></figure><p>LayoutObject节点创建入口，只有节点样式变更时候才会去创建节点，因为不同的Css样式属性会创建不同的LayoutObject：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ContainerNode::AttachLayoutTree</span><span class="hljs-params">(AttachContext&amp; context)</span> </span>&#123;<br>  <span class="hljs-keyword">for</span> (Node* child = <span class="hljs-built_in">firstChild</span>(); child; child = child-&gt;<span class="hljs-built_in">nextSibling</span>()) &#123;<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> DCHECK_IS_ON()</span><br>    <span class="hljs-built_in">DCHECK</span>(child-&gt;<span class="hljs-built_in">NeedsAttach</span>() ||<br>           <span class="hljs-built_in">ChildAttachedAllowedWhenAttachingChildren</span>(<span class="hljs-keyword">this</span>));<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>    <span class="hljs-keyword">if</span> (child-&gt;<span class="hljs-built_in">NeedsAttach</span>())<br>      child-&gt;<span class="hljs-built_in">AttachLayoutTree</span>(context);<br>  &#125;<br><br>  <span class="hljs-built_in">ClearChildNeedsStyleRecalc</span>();<br>  <span class="hljs-built_in">ClearChildNeedsReattachLayoutTree</span>();<br>  Node::<span class="hljs-built_in">AttachLayoutTree</span>(context);<br>&#125;<br></code></pre></td></tr></table></figure><p>创建LayoutObject函数实现</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">LayoutObject* <span class="hljs-title">LayoutObject::CreateObject</span><span class="hljs-params">(Element* element,</span></span><br><span class="hljs-params"><span class="hljs-function">                                         <span class="hljs-type">const</span> ComputedStyle&amp; style)</span> </span>&#123;<br>  <span class="hljs-built_in">DCHECK</span>(<span class="hljs-built_in">IsAllowedToModifyLayoutTreeStructure</span>(element-&gt;<span class="hljs-built_in">GetDocument</span>()));<br><br>  <span class="hljs-comment">// Minimal support for content properties replacing an entire element.</span><br>  <span class="hljs-comment">// Works only if we have exactly one piece of content and it&#x27;s a URL.</span><br>  <span class="hljs-comment">// Otherwise acts as if we didn&#x27;t support this feature.</span><br>  <span class="hljs-type">const</span> ContentData* content_data = style.<span class="hljs-built_in">GetContentData</span>();<br>  <span class="hljs-keyword">if</span> (content_data &amp;&amp; !content_data-&gt;<span class="hljs-built_in">Next</span>() &amp;&amp; content_data-&gt;<span class="hljs-built_in">IsImage</span>() &amp;&amp;<br>      !element-&gt;<span class="hljs-built_in">IsPseudoElement</span>()) &#123;<br>    LayoutImage* image = <span class="hljs-keyword">new</span> <span class="hljs-built_in">LayoutImage</span>(element);<br>    <span class="hljs-comment">// LayoutImageResourceStyleImage requires a style being present on the image</span><br>    <span class="hljs-comment">// but we don&#x27;t want to trigger a style change now as the node is not fully</span><br>    <span class="hljs-comment">// attached. Moving this code to style change doesn&#x27;t make sense as it</span><br>    <span class="hljs-comment">// should be run once at layoutObject creation.</span><br>    image-&gt;<span class="hljs-built_in">SetStyleInternal</span>(<span class="hljs-built_in">const_cast</span>&lt;ComputedStyle*&gt;(&amp;style));<br>    <span class="hljs-keyword">if</span> (<span class="hljs-type">const</span> StyleImage* style_image =<br>            <span class="hljs-built_in">ToImageContentData</span>(content_data)-&gt;<span class="hljs-built_in">GetImage</span>()) &#123;<br>      image-&gt;<span class="hljs-built_in">SetImageResource</span>(LayoutImageResourceStyleImage::<span class="hljs-built_in">Create</span>(<br>          <span class="hljs-built_in">const_cast</span>&lt;StyleImage*&gt;(style_image)));<br>      image-&gt;<span class="hljs-built_in">SetIsGeneratedContent</span>();<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      image-&gt;<span class="hljs-built_in">SetImageResource</span>(LayoutImageResource::<span class="hljs-built_in">Create</span>());<br>    &#125;<br>    image-&gt;<span class="hljs-built_in">SetStyleInternal</span>(<span class="hljs-literal">nullptr</span>);<br>    <span class="hljs-keyword">return</span> image;<br>  &#125;<br><br>  <span class="hljs-keyword">switch</span> (style.<span class="hljs-built_in">Display</span>()) &#123; <span class="hljs-comment">// 只有Display属性非none才会创建LayoutObject</span><br>    <span class="hljs-keyword">case</span> EDisplay::kNone:<br>    <span class="hljs-keyword">case</span> EDisplay::kContents:<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>    <span class="hljs-keyword">case</span> EDisplay::kInline:<br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">LayoutInline</span>(element);<br>    <span class="hljs-keyword">case</span> EDisplay::kBlock:<br>    <span class="hljs-keyword">case</span> EDisplay::kFlowRoot:<br>    <span class="hljs-keyword">case</span> EDisplay::kInlineBlock:<br>      <span class="hljs-keyword">if</span> (RuntimeEnabledFeatures::<span class="hljs-built_in">LayoutNGEnabled</span>()) <span class="hljs-comment">// 如果启用了NG排版，则创建NG的Block</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">LayoutNGBlockFlow</span>(element);<br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">LayoutBlockFlow</span>(element);<br>    <span class="hljs-keyword">case</span> EDisplay::kListItem:<br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">LayoutListItem</span>(element);<br>    <span class="hljs-keyword">case</span> EDisplay::kTable:<br>    <span class="hljs-keyword">case</span> EDisplay::kInlineTable:<br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">LayoutTable</span>(element);<br>    <span class="hljs-keyword">case</span> EDisplay::kTableRowGroup:<br>    <span class="hljs-keyword">case</span> EDisplay::kTableHeaderGroup:<br>    <span class="hljs-keyword">case</span> EDisplay::kTableFooterGroup:<br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">LayoutTableSection</span>(element);<br>    <span class="hljs-keyword">case</span> EDisplay::kTableRow:<br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">LayoutTableRow</span>(element);<br>    <span class="hljs-keyword">case</span> EDisplay::kTableColumnGroup:<br>    <span class="hljs-keyword">case</span> EDisplay::kTableColumn:<br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">LayoutTableCol</span>(element);<br>    <span class="hljs-keyword">case</span> EDisplay::kTableCell:<br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">LayoutTableCell</span>(element);<br>    <span class="hljs-keyword">case</span> EDisplay::kTableCaption:<br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">LayoutTableCaption</span>(element);<br>    <span class="hljs-keyword">case</span> EDisplay::kWebkitBox:<br>    <span class="hljs-keyword">case</span> EDisplay::kWebkitInlineBox:<br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">LayoutDeprecatedFlexibleBox</span>(*element);<br>    <span class="hljs-keyword">case</span> EDisplay::kFlex:<br>    <span class="hljs-keyword">case</span> EDisplay::kInlineFlex:<br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">LayoutFlexibleBox</span>(element);<br>    <span class="hljs-keyword">case</span> EDisplay::kGrid:<br>    <span class="hljs-keyword">case</span> EDisplay::kInlineGrid:<br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">LayoutGrid</span>(element);<br>  &#125;<br><br>  <span class="hljs-built_in">NOTREACHED</span>();<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>由上可以看出不同Display类型创建不同的Layout对象。<br>display:block 创建的是LayoutBlockFlow<br>display:inline 创建的是LayoutInline<br>display:table 创建的是LayoutTable</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>文本解析是个比较复杂的模块，里面还涉及到预解析，执行js，后面有时间用专门的章节讲解。</p><p>同步知乎：<a href="https://zhuanlan.zhihu.com/p/48164718">https://zhuanlan.zhihu.com/p/48164718</a></p>]]></content>
    
    
    <categories>
      
      <category>Chromium</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Page</tag>
      
      <tag>Frame</tag>
      
      <tag>Blink</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>浏览器内核原理--Chromium渲染流程</title>
    <link href="/2022/05/04/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%86%85%E6%A0%B8%E5%8E%9F%E7%90%86-Chromium%E6%B8%B2%E6%9F%93%E6%B5%81%E7%A8%8B/"/>
    <url>/2022/05/04/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%86%85%E6%A0%B8%E5%8E%9F%E7%90%86-Chromium%E6%B8%B2%E6%9F%93%E6%B5%81%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>写作如编码。作为一个优秀的码农，不仅要技术深厚，而且要写的一手好文章。<br>看过很多大牛写的chromium技术文章，在此也感谢大牛们的开放学习思维。为了锻炼自己的写作能力和技术，把自己研究的技术分享出来，当然里面可能有出入，也请各位看客及时指出。<br>后续所有chromium分析文章是基于chromium版本是62.0.3202.84，单进程架构，平台是Android 8.0，所以一般不会讲到chromium进程的概念。</p><h2 id="Chromium渲染流程"><a href="#Chromium渲染流程" class="headerlink" title="Chromium渲染流程"></a>Chromium渲染流程</h2><p><img src="/2022/05/04/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%86%85%E6%A0%B8%E5%8E%9F%E7%90%86-Chromium%E6%B8%B2%E6%9F%93%E6%B5%81%E7%A8%8B/%E6%B8%B2%E6%9F%93%E6%B5%81%E7%A8%8B.jpg" alt="渲染流程"><br>Chromium的渲染类似流水线，内部的渲染机制是非常复杂的，上图只是我简化的操作，每个步骤介绍如下：</p><p><strong>图左边是线程概念</strong><br><strong>Blink</strong>指的是chromium的render线程。 线程名（Chrome_InProcRendererThread）<br><strong>Cc</strong>指的是合成线程。线程名（Compositor）<br><strong>Raster</strong>指的是光栅化线程。线程名（CompositorTileWorker）<br><strong>Ui</strong>指的是Android的主线程。线程名（Main）<br><strong>Render</strong>指的是Android系统的Render线程 （此线程只有在Android 5.0上才有）。线程名（RenderThread）</p><p><strong>图右边是渲染流程：</strong><br><strong>第一步：</strong>BeginMainFrame 主要做Blink的layout（排版），paint（绘制），commit操作<br><img src="/2022/05/04/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%86%85%E6%A0%B8%E5%8E%9F%E7%90%86-Chromium%E6%B8%B2%E6%9F%93%E6%B5%81%E7%A8%8B/BeginMainFrame.jpg" alt="BeginMainFrame"><br><strong>第二步：</strong>Commit 指的是NotifyReadyToCommit，主要是把第一步绘制好的layer提交到合成线程<br><img src="/2022/05/04/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%86%85%E6%A0%B8%E5%8E%9F%E7%90%86-Chromium%E6%B8%B2%E6%9F%93%E6%B5%81%E7%A8%8B/Commit.jpg" alt="Commit"><br><strong>第三步：</strong>Raster-tile 主要是将layer分块好的Tile进行光栅化<br><img src="/2022/05/04/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%86%85%E6%A0%B8%E5%8E%9F%E7%90%86-Chromium%E6%B8%B2%E6%9F%93%E6%B5%81%E7%A8%8B/Raster-Tile.jpg" alt="Raster-Tile"><br><strong>第四步：</strong>Activate 指的是NotifyReadyToActivate，主要是光栅化结束后penging layer变成activate layer<br><img src="/2022/05/04/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%86%85%E6%A0%B8%E5%8E%9F%E7%90%86-Chromium%E6%B8%B2%E6%9F%93%E6%B5%81%E7%A8%8B/Activate.jpg" alt="Activate"><br><strong>第五步：</strong>Vsync 是应用向Android系统请求的信号<br><strong>第六步：</strong>BeginImplFrame是Vsync向合成线程发个IPC进行BeginImplFrame<br><img src="/2022/05/04/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%86%85%E6%A0%B8%E5%8E%9F%E7%90%86-Chromium%E6%B8%B2%E6%9F%93%E6%B5%81%E7%A8%8B/VSync.jpg" alt="VSync"><br><strong>第七步：</strong>onDraw 是android的view.onDraw，会向合成线程发送个SyncCompositorMsg_DemandDrawHw，然后cc进行DrawLayers，最后把RenderPass返回给Ui线程<br><img src="/2022/05/04/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%86%85%E6%A0%B8%E5%8E%9F%E7%90%86-Chromium%E6%B8%B2%E6%9F%93%E6%B5%81%E7%A8%8B/onDraw.jpg" alt="onDraw"><br><img src="/2022/05/04/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%86%85%E6%A0%B8%E5%8E%9F%E7%90%86-Chromium%E6%B8%B2%E6%9F%93%E6%B5%81%E7%A8%8B/DrawLayers.jpg" alt="DrawLayers"><br><strong>第八步：</strong>DrawGL 是webview启用了硬件加速才会有的，DrawGL是系统call回来的。DrawGL 会有三个操作，CommitFrame，DrawFrame，SwapBuffers。<strong>只有触发了SwapBuffers才是真正的上屏，一帧结束。</strong><br><img src="/2022/05/04/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%86%85%E6%A0%B8%E5%8E%9F%E7%90%86-Chromium%E6%B8%B2%E6%9F%93%E6%B5%81%E7%A8%8B/DrawGL-CommitFrame.jpg" alt="DrawGL-CommitFrame"><br><img src="/2022/05/04/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%86%85%E6%A0%B8%E5%8E%9F%E7%90%86-Chromium%E6%B8%B2%E6%9F%93%E6%B5%81%E7%A8%8B/DrawGL-DrawFrame-SwapBuffers.jpg" alt="DrawGL-DrawFrame-SwapBuffers"><br><strong>优化思路</strong><br>1.由上可以看出chromium的渲染流水线非常长，一帧的显示需要经过很多步骤，这里是可以在流水线上做个优化的。比如在首帧的时候可以采用跳过cc，直接利用系统的onDraw的软绘上屏。<br>2.webview是没有提供首帧上屏的回调的，是否第一个SwapBuffers结束后可以提供个回调应用层用？<br>3.这里提个问题webview如何适配Android 5.0以下的系统？这里打个伏笔，后面我会给出是怎么解决的。</p><p>同步知乎：<a href="https://zhuanlan.zhihu.com/p/48030698">https://zhuanlan.zhihu.com/p/48030698</a></p>]]></content>
    
    
    <categories>
      
      <category>Chromium</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Compositor</tag>
      
      <tag>Raster</tag>
      
      <tag>DrawGL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>浏览器内核原理--Chromium blink基础</title>
    <link href="/2022/05/04/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%86%85%E6%A0%B8%E5%8E%9F%E7%90%86-Chromium-blink%E5%9F%BA%E7%A1%80/"/>
    <url>/2022/05/04/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%86%85%E6%A0%B8%E5%8E%9F%E7%90%86-Chromium-blink%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>chromium早期的排版引擎是Webkit，后面慢慢的Webkit被google改成了blink，虽然名字改了但是目前很多框架和原理还是Webkit。不过随着浏览器内核的发展，blink和webkit将越走越远，最近的一个大改动就是使用最新的NG排版引擎。</p><h2 id="Blink架构"><a href="#Blink架构" class="headerlink" title="Blink架构"></a>Blink架构</h2><p><img src="/2022/05/04/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%86%85%E6%A0%B8%E5%8E%9F%E7%90%86-Chromium-blink%E5%9F%BA%E7%A1%80/blink%E6%9E%B6%E6%9E%84.jpg" alt="blink架构"><br>解释：<br>1.WebApi 是blink对chromium的content层提供的接口，都是WebXXX。例如WebNode，WebDocument，WebElement……<br>2.Css 是解析相关，例如css属性解析<br>3.Style 是样式相关，ComputedStyle一个元素的样式集合<br>4.Frame 解释为框架，一个WebView可以对应多个Frame，但是有个是MainFrame<br>5.Html 是HTTMLElement相关，每个标签都对应一个HTTMLXXXElement名称。<br>6.Layout 排版相关，主要是排版算法，排版类。<br>7.Loader 加载相关，资源的加载管理，ResourceFetcher资源加载，但是这里只是blink的管理，发起网络加载的还是chromium net。<br>8.Page 页面管理，ChromeClient，页面弹框管理<br>9.Paint 绘制相关，BlockPainter 块绘制<br>10.Event 事件相关，TouchEventManager 事件管理，EventHandler事件处理<br>11.Inspector chrome调试相关<br>12.Svg<br>13.V8 js引擎</p><h2 id="WebView结构"><a href="#WebView结构" class="headerlink" title="WebView结构"></a>WebView结构</h2><p>WebView与Page关系<br><img src="/2022/05/04/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%86%85%E6%A0%B8%E5%8E%9F%E7%90%86-Chromium-blink%E5%9F%BA%E7%A1%80/web-page.jpg" alt="WebView与Page关系"><br>WebView与Page是1:1的关系，一个WebView对应一个Page，WebView是对外的接口管理类<br><img src="/2022/05/04/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%86%85%E6%A0%B8%E5%8E%9F%E7%90%86-Chromium-blink%E5%9F%BA%E7%A1%80/page-frame.jpg" alt="Page与LocalFrame关系"><br>Page与LocalFrame关系<br>Page与LocalFrame是1：N的关系，但是只有一个main frame。当页面上有iframe标签时候，就对应有一个LocalFrame<br><img src="/2022/05/04/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%86%85%E6%A0%B8%E5%8E%9F%E7%90%86-Chromium-blink%E5%9F%BA%E7%A1%80/localFrame.jpg" alt="LocalFrame"><br>LocalFrame结构<br>LocalFrame分别对应一个Document，LocalFrameView，FrameLoader。</p><h2 id="Webkit到Blink的改进大事件"><a href="#Webkit到Blink的改进大事件" class="headerlink" title="Webkit到Blink的改进大事件"></a>Webkit到Blink的改进大事件</h2><p><strong>Oilpan</strong><br>早期Blink采用的是引用计数管理内存，Chromium WebView在访问946个网站之后，有294个WebCore::Document对象没有得到释放。</p><p>引用计数管理内存存在以下风险：</p><p>1.引用计数有循环引用的风险</p><p>2.C++中可以通过Raw指针绕开引进计数的管理，存在风险</p><p>所以Blink是实现了Oilpan垃圾自动回收机制，具体使用方法：</p><p><a href="https://chromium.googlesource.com/chromium/src/+/master/third_party/blink/renderer/platform/heap/BlinkGCAPIReference.md">https://chromium.googlesource.com/chromium/src/+/master/third_party/blink/renderer/platform/heap/BlinkGCAPIReference.md</a></p><p><strong>Slimming-Paint</strong></p><p>Slimming Paint是一个Paint团队项目用于重新实现Blink &lt; - &gt; cc picture recording API ，以便在全局显示列表而不是GraphicsLayer的树中工作。 它将大大简化复合层在Blink和cc中的表示方式，从而提高性能，正确性和灵活性。</p><p>Paint文件夹就是Slimming Paint相关代码</p><p><strong>LayoutNg</strong></p><p>NG排版引擎是Blink的新布局系统在设计时考虑了片段，可扩展性和可中断性。目前在62上还没有上线，只有部分代码。</p><p>NG的介绍查看<a href="https://docs.google.com/document/d/1uxbDh4uONFQOiGuiumlJBLGgO4KDWB8ZEkp7Rd47fw4/edit">https://docs.google.com/document/d/1uxbDh4uONFQOiGuiumlJBLGgO4KDWB8ZEkp7Rd47fw4/edit</a></p><h2 id="优化建议"><a href="#优化建议" class="headerlink" title="优化建议"></a>优化建议</h2><p>每个加载数据，接受到第一份数据，才会创建V8的上下文，创建都需要50到80mm，是否这里可以做个提前创建优化（或者开启V8快照）？</p>]]></content>
    
    
    <categories>
      
      <category>Chromium</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Page</tag>
      
      <tag>Frame</tag>
      
      <tag>Blink</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
